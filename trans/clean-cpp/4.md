# 四、干净的 C++ 基础

正如我在这本书的介绍中已经解释过的(见第 [1](1.html) 章)，很多 C++ 代码并不干净。在许多项目中，软件熵占据了上风。即使您正在处理一个正在进行的开发项目，例如，一个正在维护的软件，代码库的大部分通常是非常旧的。代码看起来就像上个世纪写的一样。这并不奇怪，因为大部分代码是在上个世纪写的！有很多项目的生命周期很长，它们的根源都在 90 年代甚至 80 年代。此外，许多程序员只是从遗留项目中复制代码片段，并修改它们来完成工作。

一些程序员将语言视为众多工具中的一种。他们看不到改进的理由，因为他们胡乱拼凑的东西不知何故会起作用。不应该是那样的，因为它会很快导致软件熵的增加，项目会比你想象的更快地变得一团糟。

在这一章中，我描述了 clean C++ 的基本知识。这些有时是通用的东西，通常与编程语言无关。例如，在所有编程语言中，起一个好名字是必不可少的。其他几个方面，比如常量正确性、智能指针的使用，或者 move 语义的巨大优势，都是 C++ 特有的。

但在我讨论具体话题之前，我想指出一条一般性的建议:

如果您还没有这样做，现在就开始使用 C++11(或更高版本)吧！

随着 2011 年新标准的出现，C++ 在许多方面都得到了改进，C++11 的一些特性，以及后续标准 C++14 和 C++17 的一些特性都非常有用，不容忽视。这不仅仅是性能的问题。这种语言无疑变得更加容易使用，甚至变得更加强大。C++11 不仅能让你的代码更短、更清晰、更易读:它还能提高你的生产率。此外，这种语言标准及其后继标准的特性使您能够编写更加正确和异常安全的代码。

但是现在让我们一步一步地探索干净而现代的 C++ 的关键元素…

## 好名字

程序必须是为人们阅读而写的，并且只是附带地为机器执行而写。——哈尔·阿伯尔森和杰拉德·让伊·萨斯曼，1984 年

下面这段源代码摘自众所周知的 Apache open office 3 . 4 . 1 版，这是一个开源的办公软件套件。Apache OpenOffice 有着悠久的历史，可以追溯到 1984 年。它源自甲骨文 OpenOffice.org(OOo)，是早期 StarOffice 的开源版本。2011 年，甲骨文停止了 OpenOffice.org 的开发，解雇了所有开发人员，并将代码和商标捐献给了阿帕奇软件基金会。所以，请宽容一点，牢记阿帕奇软件基金会继承了一个近 30 年的古兽和一笔庞大的技术债务。

```cpp
// Building the info struct for single elements
SbxInfo* ProcessWrapper::GetInfo( short nIdx )
{
    Methods* p = &pMethods[ nIdx ];
    // Wenn mal eine Hilfedatei zur Verfuegung steht:
    // SbxInfo* pResultInfo = new SbxInfo( Hilfedateiname, p->nHelpId );
    SbxInfo* pResultInfo = new SbxInfo;
    short nPar = p->nArgs & _ARGSMASK;
    for( short i = 0; i < nPar; i++ )
    {
        p++;
        String aMethodName( p->pName, RTL_TEXTENCODING_ASCII_US );
        sal_uInt16 nInfoFlags = ( p->nArgs >> 8 ) & 0x03;
        if( p->nArgs & _OPT )
            nInfoFlags |= SBX_OPTIONAL;
        pResultInfo->AddParam( aMethodName, p->eType, nInfoFlags );
    }
    return pResultInfo;
}
Listing 4-1.An excerpt from Apache’s OpenOffice 3.4.1 source code

```

我有一个简单的问题要问你:这个函数是做什么的？

乍一看似乎很容易给出答案，因为代码片段很小(不到 20 LOC)，缩进也还可以。但实际上，不可能一目了然地说出这个函数到底是做什么的，原因不仅仅在于你可能不知道的领域。

这一小段代码有许多不好的味道(例如，注释掉的代码、德语注释、类似于`0x03`的魔法文字等等)。)但一个主要问题是糟糕的命名。这个函数的名字`GetInfo()`非常抽象，最多给我们一个这个函数实际做什么的模糊概念。此外，名称空间名称`ProcessWrapper`也不是很有帮助。也许您可以使用这个函数来检索正在运行的进程的信息。嗯，难道`RetrieveProcessInformation()`不是一个更好的名字吗？

在分析了该函数的实现之后，您还会注意到这个名字具有误导性，因为`GetInfo()`不像您可能怀疑的那样只是一个简单的 getter。还有一些用`new`操作符创建的东西。也许你也注意到了函数上方的注释，它谈到了构建，而不仅仅是获取。换句话说，调用站点将接收在堆上分配的资源，并且必须管理它。为了强调这个事实，像`CreateProcessInformation()`这样的名字不是更好吗？

接下来看看函数的参数和返回值。什么是`SbxInfo`？什么是`nIdx`？也许参数`nIdx`包含一个用于访问数据结构中的元素的值(即索引)，但这只是一种猜测。其实我们也不是很清楚。

开发人员阅读源代码的次数要比编译器翻译源代码的次数多得多。因此，源代码应该是可读的，好的名称是增加其可读性的关键因素。如果您与多人一起处理一个项目，好的命名是必不可少的，这样您和您的团队成员可以快速理解您的代码。即使你必须在几周或几个月后编辑或阅读你自己写的一段代码，好的类名、方法名和变量名也会帮助你回忆起你的意图。

所以，这是我的基本建议:

源代码文件、命名空间、类、模板、函数、参数、变量和常量应该有有意义和有表现力的名称。

当我设计软件或写代码时，我会花很多时间考虑名字。我相信现在是考虑好名字的好时机，即使有时并不容易，需要 5 分钟或更长时间。我很少能马上为一件事物找到一个合适的名字。所以我经常重命名，有了好的编辑器或者有重构能力的集成开发环境(IDE)就很容易了。

如果为一个变量、函数或类找到一个合适的名称似乎很困难或几乎不可能，这可能表明其他地方可能出错了。可能存在设计问题，您应该找到并解决命名问题的根本原因。

这里有一些找到好名字的建议。

### 名称应该是不言自明的

我致力于自我记录代码的概念。自文档化代码是不需要注释来解释其目的的代码(也参见下面关于注释和如何避免注释的部分)。自文档化代码要求其名称空间、类、变量、常数和函数有自解释的名称。

使用简单但描述性和自我解释的名称。

```cpp
unsigned int num;

bool flag;
std::vector<Customer> list;
Product data;
Listing 4-2.Some examples of bad names

```

多变的命名惯例经常会变成一场宗教战争，但是我非常确定大家都同意`num`、`flag`、`list`和`data`是非常糟糕的名字。什么是`data`？一切都是`data`。这个名字绝对没有语义。这就像你将你的货物和动产包装在移动的盒子里，而不是在上面写下它们真正包含的东西，例如，“炊具”，你会在每个纸箱上都写下“东西”这个词。在新房子里，当纸箱到达时，这些信息是完全无用的。

下面是一个例子，说明如何更好地命名前面代码示例中的四个变量:

```cpp
unsigned int numberOfArticles;

bool isChanged;
std::vector<Customer> customers;
Product orderedProduct;
Listing 4-3.Some examples of good names

```

人们现在可以说名字越长越好。考虑以下示例:

```cpp
unsigned int totalNumberOfCustomerEntriesWithMangledAddressInformation;
Listing 4-4.A very exhaustive variable name

```

毫无疑问，这个名字极具表现力。即使不知道这些代码来自哪里，读者也很清楚这个变量的用途。但是，这样的名字也有问题。例如，你不容易记住这么长的名字。而且它们很难打字。如果在表达式中使用如此冗长的名称，代码的可读性甚至会受到影响:

```cpp
totalNumberOfCustomerEntriesWithMangledAddressInformation =
  amountOfCustomerEntriesWithIncompleteOrMissingZipCode +
  amountOfCustomerEntriesWithoutCityInformation +
  amountOfCustomerEntriesWithoutStreetInformation;
Listing 4-5.A naming chaos

, caused by too verbose names

```

当试图使我们的代码干净时，过长和冗长的名字是不合适的或不可取的。如果使用变量的上下文是清楚的，那么更短和更少描述的名字是可能的。例如，如果变量是一个类的成员(属性)，类名通常为变量提供足够的上下文:

```cpp
class CustomerRepository {

private:

  unsigned int numberOfMangledEntries;
  // ...
};
Listing 4-6.The class’s name provides enough context information for the attribute

```

### 使用域中的名称

你可能已经听说过领域驱动设计(DDD)。术语“领域驱动设计”是由 Eric Evans 在他 2004 年的同名著作中提出的。DDD 是复杂的面向对象软件开发中的一种方法，主要关注核心领域和领域逻辑。换句话说，DDD 试图通过将业务领域的事物和概念映射到代码中，使你的软件成为现实系统的模型。例如，如果要开发的软件应该支持汽车租赁中的业务流程，那么汽车租赁的事物和概念(例如，租赁汽车、拼车、承租人、租赁期、租赁确认、会计等。)应该可以在这个软件的设计中发现。另一方面，如果软件是在航空航天工业中开发的，航空航天领域应该在其中得到反映。

这种方法的优点是显而易见的:首先，使用领域术语有助于开发人员和其他利益相关者之间的交流。DDD 帮助软件开发团队在公司的业务和 IT 涉众之间创建一个公共模型，团队可以用它来交流业务需求、数据实体和过程模型。

领域驱动设计的详细介绍超出了本书的范围。然而，以一种可以重新发现应用程序领域中的元素和概念的方式来命名组件、类和函数基本上总是一个非常好的主意。这使得我们能够尽可能自然地交流软件设计。它将使代码更容易被任何参与解决问题的人理解，例如，测试人员或业务专家。

以上面提到的汽车租赁为例。负责为某个客户预订汽车的用例的类可能如下:

```cpp
class ReserveCarUseCaseController {

public:

  Customer identifyCustomer(const UniqueIdentifier& customerId);
  CarList getListOfAvailableCars(const Station& atStation, const RentalPeriod& desiredRentalPeriod) const;
  ConfirmationOfReservation reserveCar(const UniqueIdentifier& carId, const RentalPeriod& rentalPeriod) const;

private:

  Customer& inquiringCustomer;
};

Listing 4-7.The interface of a use case controller class to reserve a car

```

现在看一下所有用于类、方法、参数和返回类型的名称。它们代表了汽车租赁领域的典型事物。如果你从头到尾阅读这些方法，这些是租车所需的各个步骤。这是 C++ 代码，但是具有领域知识的非技术利益相关者也很有可能理解它。

### 在适当的抽象层次上选择名称

为了控制当今软件系统的复杂性，这些系统通常被分层分解。软件系统的层次分解意味着整个问题被分割成更小的部分，分别作为子任务，直到开发人员确信他们能够管理这些更小的部分。进行这种分解有不同的方法和标准。前一节中提到的领域驱动的设计，以及面向对象的分析和设计(OOAD)是这种分解的两种方法，在这两种方法中创建组件和类的基本标准是业务领域。

通过这样的分解，软件模块在不同的抽象层次上被创建:从大型组件或子系统开始，到非常小的构建块，如类。处于较高抽象级别的构件所完成的任务应该通过下一个较低抽象级别的构件的交互来完成。

这种方法引入的抽象层次也对命名有影响。每当我们在层次结构中更深入一步，元素的名称就变得更加具体。

想象一个网店。在顶层，可能存在一个大型组件，它的单一职责是创建发票。该组件可以有一个简短的描述性名称，如`Billing`。通常，这个组件由更小的组件或类组成。例如，这些较小的模块之一可以负责折扣的计算。另一个模块可以负责创建发票行项目。因此，这些模块的好名字应该是`DiscountCalculator`和`LineItemFactory`。如果我们现在深入分解层次，组件、类以及函数或方法的标识符变得越来越具体、冗长，因此也越来越长。例如，类中最深层次的一个小方法可以有一个非常详细和冗长的名字，比如`calculateReducedValueAddedTax()`。

### 选择名字时避免重复

选择一个提供清晰上下文的类名或其他名称，并将其作为构建成员变量名称的一部分是多余的，例如，如下所示:

```cpp
#include <string>

class Movie {

private:

  std::string movieTitle;
  // ...
};

Listing 4-8.Don’t repeat the class’s name in its attributes

```

别这样！这是对 DRY 原则的一个微小的违反。而是将其命名为`Title`。成员变量在类`Movie`的名称空间中，所以很清楚谁的标题是指:电影的标题！

这是冗余的另一个例子:

```cpp
#include <string>

class Movie {
  // ...

private:

  std::string stringTitle;
};

Listing 4-9.Don’t include the attribute’s type in its name

```

它是一部电影的片名，所以很明显它是一个字符串而不是整数！不要在其名称中包含变量或常数的类型。

### 避免隐晦的缩写

为变量或常量选择名称时，使用完整的单词而不是晦涩的缩写。原因很明显:晦涩的缩写会大大降低代码的可读性。此外，当开发人员谈论他们的代码时，变量名应该易于发音。

还记得 Open Office 代码片段中第 8 行名为`nPar`的变量吗？它的意思既不清楚，也不能很好地发音。

这里还有几个该做和不该做的例子:

```cpp
std::size_t idx;           // Bad!
std::size_t index;         // Good; might be sufficient in some cases
std::size_t customerIndex; // To be preferred, especially in situations where
                           // several objects are indexed

Car ctw;       // Bad!
Car carToWash; // Good

Polygon ply1;         // Bad!
Polygon firstPolygon; // Good

unsigned int nBottles;       // Bad!

unsigned int bottleAmount;   // Better

unsigned int bottlesPerHour; // Ah, the variable holds a work value,
                             // and not an absolute number. Excellent!

const double GOE = 9.80665; // Bad!

const double gravityOfEarth = 9.80665; // More expressive, but misleading. The constant is
                                       // not a gravitation, which would be a force in physics.

const double gravitationalAccelerationOnEarth = 9.80665; // Good.

constexpr Acceleration gravitationalAccelerationOnEarth = 9.80665_ms2; // Wow!

Listing 4-10.Some examples for good and bad names

```

看最后一行，我已经用“哇！”这看起来很方便，因为这是科学家们熟悉的符号。这看起来就像在学校教物理一样。是的，这在 C++ 中确实是可能的，正如你将在第 [5](5.html) 章中关于类型丰富编程的下一节中所学到的。

### 避免匈牙利符号和前缀

你知道查尔斯·西蒙尼吗？查尔斯·西蒙尼是匈牙利裔美国计算机软件专家，20 世纪 80 年代在微软担任首席架构师。也许你在不同的背景下记得他的名字。查尔斯·西蒙尼是一名太空游客，已经两次进入太空，其中一次是去国际空间站。

但是他也发展了一种在计算机软件中命名变量的符号约定，命名为匈牙利符号，这种符号在微软内部被广泛使用，后来也被其他软件制造商使用。

当使用匈牙利表示法时，变量的类型，有时还有范围，被用作该变量的命名前缀。这里有几个例子:

```cpp
bool fEnabled;       // f = a boolean flag

int nCounter;        // n = number type (int, short, unsigned, ...)

char* pszName;       // psz = a pointer to a zero-terminated string
std::string strName; // str = a C++ stdlib string

int m_nCounter;      // The prefix 'm_' marks that it is a member variable,
                     // i.e. it has class scope.

char* g_pszNotice;   // That's a global(!) variable. Believe me, I've seen
                     // such a thing.

int dRange;          // d = double-precision floating point. In this case it's
                     // a stone-cold lie!
Listing 4-11.Some examples for Hungarian notation with explanations

```

我对 21 世纪的建议是:

不要使用匈牙利符号，或任何其他基于前缀的符号，在名称中对变量的类型进行编码！

匈牙利符号在弱类型语言(如 c)中有潜在的帮助。在开发人员使用简单的编辑器进行编程，而不是具有“智能感知”功能的 ide 时，它可能是有用的

现代和复杂的开发工具今天很好地支持了开发者，并且显示了变量的类型和范围。没有更好的理由在名称中对变量的类型进行编码。远非如此，这样的前缀会妨碍代码的可读性。

最坏的情况是，在开发过程中，变量的类型在没有修改其名称前缀的情况下发生了改变。换句话说:前缀往往会变成谎言，正如你在上面的例子中看到的最后一个变量。那真的很糟糕！

另一个问题是，在支持多态性的面向对象语言中，前缀不容易指定，或者前缀甚至可能令人费解。哪个匈牙利前缀适合可以是整数也可以是双精度的多态变量？`idX`？`diX`？如何为一个实例化的 C++ 模板确定一个合适的、明确无误的前缀？

顺便说一句，即使是微软所谓的通用命名约定也强调不要使用匈牙利符号。

### 避免出于不同目的使用相同的名称

一旦你为任何种类的软件实体(例如，一个类或者组件)，一个函数，或者一个变量引入了一个有意义的和表达性的名字，你应该注意它的名字永远不会被用于任何其他的目的。

我认为很明显，出于不同的目的使用相同的名称会令人困惑，并且会误导代码的读者。别这样。关于这个话题，我只能说这么多。

## 评论

真理只能在一个地方找到:代码。—罗伯特·c·马丁，干净代码[Martin09]

你还记得你作为一名专业软件开发人员的开端吗？你还记得当年你们公司的编码标准吗？也许你还年轻，从事商业的时间还不长，但是老一点的人会证实，这些标准中的大部分都包含一条规则，即适当的专业代码必须总是被适当地注释。这条规则的绝对可理解的推理是，任何其他开发人员或新的团队成员都可以很容易地理解代码的意图。

乍一看，这条规则似乎是个好主意。因此，在许多公司中，代码被广泛地注释。在一些项目中，代码和注释之间的比例几乎是 50:50。不幸的是，这不是一个好主意。相反:这个规则绝对是个坏主意！它曾经是，而且在几个方面是完全错误的，因为在大多数情况下，注释是一种代码味道。当需要解释和澄清时，评论是必要的。这通常意味着开发人员无法编写简单明了的代码。

请不要误解:评论有一些合理的用例。在某些情况下，注释可能会有所帮助。在这一节的最后，我将介绍一些相当罕见的案例。但是对于任何其他情况，这条规则应该适用，这也是下一节的标题:“让代码讲故事！”

### 让代码讲述一个故事

想象一下在电影院看一部电影，只有用图片下面的文字描述来解释个别场景，这才是可以理解的。这部电影肯定不会成功。相反，它会被批评家们批评得体无完肤。没有人会看这么糟糕的电影。因此，好电影非常成功，因为它们主要是通过画面和演员的对话来讲述一个扣人心弦的故事。

讲故事在很多领域都是一个成功的概念，不仅仅是在电影制作中。当你考虑构建一个伟大的软件产品时，你应该像向世界讲述一个伟大而迷人的故事一样去思考它。像 Scrum 这样的敏捷项目管理框架使用被称为“用户故事”的东西作为从用户的角度捕捉需求的方法，这并不奇怪。正如我在一个关于偏好特定域名的章节中所解释的，你应该用利益相关者自己的语言和他们交流。

所以，我的建议是:

代码应该讲述一个故事，并且不言自明。尽可能避免评论。

评论不是字幕。每当你想在代码中写一个注释，因为你想解释一些东西的时候，你应该考虑如何更好地写代码，这样它是不言自明的，注释变得多余。像 C++ 这样的现代编程语言具备了编写清晰而富于表现力的代码所必需的一切。优秀的程序员利用这种表现力来讲述故事。任何傻瓜都能写出计算机能理解的代码。优秀的程序员编写人类能够理解的代码。

马丁·福勒，1999 年

### 不要评论显而易见的事情

我们再一次来看一小段被广泛评论的典型源代码。

```cpp
customerIndex++;                                        // Increment index
Customer* customer = getCustomerByIndex(customerIndex); // Retrieve the customer at the
                                                        // given index
CustomerAccount* account = customer->getAccount();      // Retrieve the customer's account
account->setLoyaltyDiscountInPercent(discount);         // Grant a 10% discount
Listing 4-12.Are these comments useful?

```

请不要侮辱读者的智力！很明显这些评论完全没用。代码本身很大程度上是不言自明的。它们不仅没有增加任何新的或相关的信息。更糟糕的是，这些无用的注释是代码的一种复制。它们违反了我们在第 3 章讨论过的干燥原则。

也许你注意到了另一个细节。看一下最后一行。注释字面上说的是 10%的折扣，但是在代码中有一个名为`discount`的变量或常量被传递给函数或方法`setLoyaltyDiscountInPercent()`。这里发生了什么事？一个合理的怀疑是，这个评论已经变成了一个谎言，因为代码被修改了，但是评论没有被改编。那真的不好，误导。

### 不要用注释禁用代码

有时注释被用来禁用一堆不应该被编译器翻译的代码。一些开发人员对这种做法经常给出的理由是，人们可能会在以后再次使用这段代码。他们认为，“也许有一天…我们会再次需要它。”

```cpp
// This function is no longer used (John Doe, 2013-10-25):
/*
double calcDisplacement(double t) {
  const double goe = 9.81; // gravity of earth
  double d = 0.5 * goe * pow(t, 2); // calculation of distance
  return d;
}
*/
Listing 4-13.An example for commented-out code

```

注释掉的代码的一个主要问题是，它增加了混乱，却没有真正的好处。想象一下，上面例子中被禁用的函数不是唯一的一个，而是代码被注释掉的许多地方中的一个。代码很快就会变得一团糟，被注释掉的代码片段会增加很多干扰，影响可读性。此外，注释掉的代码片段没有质量保证，也就是说，它们没有被编译器翻译、测试和维护。我的建议是:

除非是为了快速试验，否则不要使用注释来禁用代码。有版本控制系统！

如果不再使用代码，只需将其删除。放手吧。如果有必要，你有一个“时间机器”来取回它:你的版本控制系统。但是，往往事实证明，这种情况非常罕见。只需看一下开发人员在上面的例子中添加的时间戳。这段代码已经很老了。再次需要它的可能性有多大？

为了在开发过程中快速尝试一些东西，例如，在寻找一个 bug 的原因时，暂时注释掉一段代码当然是有帮助的。但是必须确保这种修改后的代码不会在版本控制系统中签入。

### 不要写块状注释

像下面这样的评论可以在很多项目中找到。

```cpp
#ifndef _STUFF_H_
#define _STUFF_H_

// -------------------------------------
// stuff.h: the interface of class Stuff
// John Doe, created: 2007-09-21
// -------------------------------------

class Stuff {

public:

  // ----------------
  // Public interface
  // ----------------

  // ...

protected:

  // -------------
  // Overrideables
  // -------------

  // ...

private:

  // ------------------------
  // Private member functions
  // ------------------------

  // ...

  // ------------------
  // Private attributes
  // ------------------

  // ...

};

#endif

Listing 4-14.An example of block comments

```

这些类型的评论(我不是指我用来掩盖不相关部分的那些)被称为“块评论”，或者“横幅”它们通常用于将内容摘要放在源代码文件的顶部。或者它们用于标记代码中的特殊位置。例如，他们引入了一个代码段，在这里可以找到一个类的所有私有成员函数。

这类评论大多是纯粹的乱七八糟，应该马上删除。

很少有例外，这样的评论是有益的。在一些罕见的情况下，一组特殊类别的函数可以聚集在这样一个注释下。但是你不应该使用由连字符(`-`)、斜线(`/`)、数字符号(`#`)或星号(`*`)组成的混乱的字符串来包围它。像下面这样的评论绝对足以介绍这样一个地区:

```cpp
private:

  // Event handlers:
  void onUndoButtonClick();
  void onRedoButtonClick();
  void onCopyButtonClick();
  // ...
Listing 4-15.Sometimes useful: a comment to introduce a category of functions

```

在一些项目中，编码标准说在任何源代码文件的顶部带有版权和许可文本的大标题是强制性的。它们可能看起来像这样:

```cpp
/**************************************************************
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 *************************************************************/
Listing 4-16.The license header

in any source code file of Apache OpenOffice 3.4.1

```

首先，我想说一些关于版权的基本知识。你不需要添加关于版权的评论，或者做任何其他事情，就可以拥有你作品的版权。根据伯尔尼保护文学和艺术作品公约(Wipo1886)(简称伯尔尼公约)，这种评论没有法律意义。

有时需要这样的评论。在美国于 1989 年签署《伯尔尼公约》之前，如果你想在美国执行你的版权，这种版权声明是强制性的。但那是过去的事了。如今，这些评论已不再需要。

我的建议是干脆省略它们。它们只是笨重无用的包袱。然而，如果你想，或者甚至需要在你的项目中提供版权和许可信息，那么你最好把它们写在单独的文件中，比如`license.txt`和`copyright.txt`。如果软件许可证要求在所有情况下许可证信息都必须包含在每个源代码文件的头区域，那么如果您的 ide 有一个所谓的折叠编辑器，您可以隐藏这些注释。

#### 不要用注释来代替版本控制

有时——这是非常糟糕的——横幅注释被用于变更日志，如下例所示。

```cpp
// ############################################################################
// Change log:
// 2016-06-14 (John Smith) Change method rebuildProductList to fix bug #275
// 2015-11-07 (Bob Jones) Extracted four methods to new class ProductListSorter
// 2015-09-23 (Ninja Dev) Fixed the most stupid bug ever in a very smart way
// ############################################################################
Listing 4-17.Managing the change history in the source code file

```

别这样！跟踪项目中每个文件的更改历史是版本控制系统的主要任务之一。例如，如果您正在使用 Git，您可以使用`git log -- [filename]`来获取文件的更改历史。编写上述注释的程序员很可能是那些在提交时总是将签入注释框留空的人。

### 注释有用的罕见情况

当然，并不是所有的源代码注释基本上都是无用的、错误的或者不好的。有些情况下，注释很重要，甚至是不可或缺的。

在少数非常特殊的情况下，可能会发生这样的情况，即使您对所有变量和函数都使用了完美的名称，您的代码的某些部分仍然需要一些进一步的解释来支持读者。例如，如果一段代码具有高度的内在复杂性，以至于不具备深厚专业知识的每个人都不容易理解，则注释是合理的。例如，复杂的数学算法或公式就是这种情况。或者软件系统处理非日常(商业)领域，即不是每个人都容易理解的应用领域，例如，实验物理学、自然现象的复杂模拟或雄心勃勃的加密方法。在这种情况下，一些写得很好的解释事情的评论是非常有价值的。

写一次评论的另一个好理由是，在这种情况下，你必须故意偏离一个好的设计原则。例如，DRY 原则(参见第 [3](3.html) 章)当然在大多数情况下都是有效的，但是可能有一些非常罕见的情况，例如，您必须故意复制一段代码，以满足关于性能的雄心勃勃的质量要求。这证明了解释你为什么违反了原则的评论是正确的；否则你的队友可能无法理解你的决定。

挑战是这样的:好的有意义的评论很难写。这可能比写代码更难。正如不是每个开发团队成员都擅长设计用户界面一样，也不是每个人都擅长写作。技术写作是一种通常有专家的技能。

因此，这里有一些写评论的建议，由于上述原因，这些建议是不可避免的:

*   确保你的评论增加了代码的价值。这个上下文中的值意味着注释为其他人(通常是其他开发人员)添加了重要的信息，这些信息从代码本身是看不到的。
*   总是解释为什么，而不是如何。从代码本身来看，一段代码是如何工作的应该非常清楚，对变量和函数进行有意义的命名是实现这一目标的关键。仅使用注释来解释某段代码存在的原因。例如，您可以提供选择特定算法或方法的理由。
*   尽量简短，有表现力。喜欢简短的评论，最好是单句，避免冗长的文字。永远记住，评论也需要维护。事实上，保持简短的评论比冗长的解释要容易得多。

Tip

在带有语法颜色的集成开发环境(IDE)中，注释的颜色通常预先配置为绿色或蓝绿色。你应该把这个颜色改成红色！源代码中的注释应该是特别的，应该引起开发人员的注意。

#### 从源代码生成文档

注释的一种特殊形式是可以由文档生成器提取的注释。这种工具的一个例子是 Doxygen ( [`http://doxygen.org`](http://doxygen.org) )，它在 C++ 世界中广泛使用，并在 GNU 通用公共许可证(GPLv2)下发布。这种工具解析带注释的 C++ 源代码，并且可以创建可读和可打印文档(例如，PDF)形式的文档，或者可以用浏览器查看的一组互连的 web 文档(HTML)。结合可视化工具，Doxygen 甚至可以生成类图，包括依赖图和调用图。因此，Doxygen 也可以用于代码分析。

为了让这样的工具产生有意义的文档，必须用具体的注释对源代码进行深入的注释。下面是一个不太好的 Doxygen 风格注释的例子:

```cpp
//! Objects of this class represent a customer account in our system.

class CustomerAccount {
  // ...

  //! Grant a loyalty discount.
  //! @param discount is the discount value in percent.
  void grantLoyaltyDiscount(unsigned short discount);

  // ...
};

Listing 4-18.A class annotated with documentation comments for Doxygen

```

什么事？类别`CustomerAccount`的对象代表客户账户。真的吗？！和`grantLoyaltyDiscount`授予忠诚度折扣？废话！

但是说真的，伙计们！对我来说，这种形式的文档是有利有弊的。

一方面，注释可能非常有用，特别是带有这种注释的库或框架的公共接口(API ),并从中生成文档。特别是如果软件的客户是未知的(公共可用库和框架的典型情况)，如果他们想在他们的项目中使用该软件，这样的文档会非常有帮助。

另一方面，这样的注释给你的代码增加了大量的噪音。代码和注释行的比例可以很快达到 50:50。从上面的例子可以看出，这样的评论也倾向于解释显而易见的事情(记住本章中的“不要评论显而易见的事情”)。最后，有史以来最好的文档——“可执行文档”——是一组精心制作的单元测试(参见第 [2 章](2.html)中关于单元测试的部分和第 [8 章](8.html)中关于测试驱动开发的部分),它确切地展示了如何使用库的 API。

反正我对这个话题没有定论。如果你想或者必须不惜一切代价用 Doxygen 风格的注释来注释你的软件组件的公共 API，那么，看在上帝的份上，去做吧。如果做得好，会很有帮助。我强烈建议你只关注你的公共 API 头！对于软件的所有其他部分，例如，内部使用的模块或私有函数，我建议不要给它们配备 Doxygen 注释。

如果使用应用领域的术语和解释，上面的例子可以得到显著的改进。

```cpp
//! Each customer must have an account, so bookings can be made. The account
//! is also necessary for the creation of monthly invoices.
//! @ingroup entities
//! @ingroup accounting

class CustomerAccount {
  // ...

  //! Regular customers occasionally receive a regular discount on their
  //! purchases.
  void grantDiscount(const PercentageValue& discount);

  // ...
};

Listing 4-19.A class annotated with comments from a business perspective for Doxygen

```

也许你已经注意到，我已经不再用 Dogygen 的`@param`标签来评论这个方法的参数了。相反，我将它的类型从无意义的`unsigned short`改为名为`PercentageValue`的自定义类型的常量引用。因此，该参数已经变得不言自明。为什么这是一个比任何注释都好得多的方法，你可以在第 5 章[的](5.html)中阅读关于类型丰富编程的章节。

下面是源代码中 Doxygen 风格注释的一些最终提示:

*   不要使用 Doxygen 的`@file [<name>]`标签在文件本身的某个地方写文件名。一方面，这是没有用的，因为 Dogygen 无论如何都会自动读取文件名。另一方面，它违反了干原则(见第 [3 章](3.html))。这是多余的信息，如果您必须重命名文件，您必须记住也要重命名`@file`标记。
*   不要手动编辑`@version`、`@author,`和`@date`标签，因为你的版本控制系统可以比任何应该手动编辑它们的开发者更好地管理和跟踪这些信息。如果这样的管理信息在所有情况下都应该出现在源代码文件中，那么这些标签应该由版本控制系统自动填充。在所有其他情况下，我会完全没有他们。
*   不要使用`@bug`或`@todo`标签。相反，您应该立即修复错误，或者使用问题跟踪软件来记录错误，以便以后进行故障排除，并分别管理开放点。
*   强烈建议使用`@mainpage`标签提供一个描述性的项目主页(最好是在一个单独的头文件中),因为这样的主页可以作为一个入门指南，并帮助目前不熟悉手头项目的开发人员进行定位。
*   我不会使用`@example`标签来提供包含如何使用 API 的源代码示例的注释块。正如已经提到的，这样的注释给代码增加了很多噪音。相反，我会提供一套精心制作的单元测试(参见关于单元测试的第 [2](2.html) 章和关于测试驱动开发的第 [8](8.html) 章)，因为这些是最好的使用示例——可执行的示例！此外，单元测试总是正确的和最新的，因为当 API 改变时它们必须被调整(否则测试将失败)。另一方面，带有用法示例的注释可能会在没有人注意到的情况下出错。
*   一旦一个项目发展到一个特定的规模，建议在 Dogygen 的分组机制(标签:`@defgroup <name>`、`@addtogroup <name>`和`@ingroup <name>`)的帮助下，将某些类别的软件单元集中起来。例如，当您想要表达某些软件单元属于更高抽象层次上的内聚模块(例如，组件或子系统)的事实时，这是非常有用的。这种机制还允许将某些类别的类组合在一起，例如所有实体、所有适配器(参见第 [9](9.html) 章中的适配器模式)或所有对象工厂(参见第 [9](9.html) 章中的工厂模式)。例如，前面代码示例中的类`CustomerAccount`位于实体组(包含所有业务对象的组)中，但它也是会计组件的一部分。

## 功能

功能(同义词:方法、过程、服务、操作)是任何软件系统的核心。它们代表代码行之上的第一个组织单位。写得好的函数大大提高了程序的可读性和可维护性。出于这个原因，它们应该精心制作。在这一节中，我给出了编写好函数的几个重要线索。

然而，在我解释我认为对精心制作的功能很重要的东西之前，让我们再次检查一个令人生畏的例子，取自 Apache 的 OpenOffice 3.4.1。

```cpp
1780  sal_Bool BasicFrame::QueryFileName(String& rName, FileType nFileType, sal_Bool bSave )
1781  {
1782      NewFileDialog aDlg( this, bSave ? WinBits( WB_SAVEAS ) :
1783                          WinBits( WB_OPEN ) );
1784      aDlg.SetText( String( SttResId( bSave ? IDS_SAVEDLG : IDS_LOADDLG ) ) );
1785
1786      if ( nFileType & FT_RESULT_FILE )
1787      {
1788        aDlg.SetDefaultExt( String( SttResId( IDS_RESFILE ) ) );
1789        aDlg.AddFilter( String( SttResId( IDS_RESFILTER ) ),
1790              String( SttResId( IDS_RESFILE ) ) );
1791          aDlg.AddFilter( String( SttResId( IDS_TXTFILTER ) ),
1792              String( SttResId( IDS_TXTFILE ) ) );
1793          aDlg.SetCurFilter( SttResId( IDS_RESFILTER ) );
1794      }
1795
1796      if ( nFileType & FT_BASIC_SOURCE )
1797      {
1798          aDlg.SetDefaultExt( String( SttResId( IDS_NONAMEFILE ) ) );
1799          aDlg.AddFilter( String( SttResId( IDS_BASFILTER ) ),
1800              String( SttResId( IDS_NONAMEFILE ) ) );
1801          aDlg.AddFilter( String( SttResId( IDS_INCFILTER ) ),
1802              String( SttResId( IDS_INCFILE ) ) );
1803          aDlg.SetCurFilter( SttResId( IDS_BASFILTER ) );
1804      }
1805
1806      if ( nFileType & FT_BASIC_LIBRARY )
1807      {
1808          aDlg.SetDefaultExt( String( SttResId( IDS_LIBFILE ) ) );
1809          aDlg.AddFilter( String( SttResId( IDS_LIBFILTER ) ),
1810              String( SttResId( IDS_LIBFILE ) ) );
1811          aDlg.SetCurFilter( SttResId( IDS_LIBFILTER ) );
1812      }
1813
1814      Config aConf(Config::GetConfigName( Config::GetDefDirectory(),
1815          CUniString("testtool") ));
1816      aConf.SetGroup( "Misc" );
1817      ByteString aCurrentProfile = aConf.ReadKey( "CurrentProfile", "Path" );
1818      aConf.SetGroup( aCurrentProfile );
1819      ByteString aFilter( aConf.ReadKey( "LastFilterName") );
1820      if ( aFilter.Len() )

1821          aDlg.SetCurFilter( String( aFilter, RTL_TEXTENCODING_UTF8 ) );
1822      else

1823          aDlg.SetCurFilter( String( SttResId( IDS_BASFILTER ) ) );
1824
1825      aDlg.FilterSelect(); // Selects the last used path
1826  //  if ( bSave )
1827      if ( rName.Len() > 0 )
1828          aDlg.SetPath( rName );
1829
1830      if( aDlg.Execute() )
1831      {
1832          rName = aDlg.GetPath();
1833  /*      rExtension = aDlg.GetCurrentFilter();
1834          var i:integer;
1835          for ( i = 0 ; i < aDlg.GetFilterCount() ; i++ )
1836              if ( rExtension == aDlg.GetFilterName( i ) )
1837                  rExtension = aDlg.GetFilterType( i );
1838  */
1839          return sal_True;
1840      } else return sal_False;
1841  }
Listing 4-20.Another excerpt from Apache's OpenOffice 3.4.1 source code

```

问题:第一次看到名为`QueryFileName()`的成员函数时，你期待的是什么？

你希望打开一个文件选择对话框吗(记得在第 [3](3.html) 章中讨论的最小惊讶原则)？可能不会，但这正是这里所做的。很明显，用户被要求与应用程序进行一些交互，因此这个成员函数更好的名字应该是`AskUserForFilename()`。

但这还不够。如果你仔细观察第一行，你会发现有一个布尔参数`bSave`用来区分打开文件的对话框和保存文件的对话框。你预料到了吗？函数名中的术语`Query…`如何与事实相匹配？因此，这个成员函数更好的名字可能是`AskUserForFilenameToOpenOrSave()`。

下面几行处理函数的参数`nFileType`。显然，有三种不同的文件类型。参数`nFileType`被一个叫做`FT_RESULT_FILE`、`FT_BASIC_SOURCE`和`FT_BASIC_LIBRARY`的东西屏蔽了。根据这种按位 AND 运算的结果，文件对话框会有不同的配置，例如设置过滤器。正如布尔参数`bSave`之前所做的那样，三个`if`语句引入了替代路径。这增加了函数的圈复杂度。

Cyclomatic Complexity

美籍数学家托马斯·j·麦凯布于 1976 年开发了度量圈复杂度的定量软件。

该度量是通过一段源代码(例如，一个函数)的线性独立路径的数量的直接计数。如果一个函数不包含`if` -或`switch`-语句，也不包含`for` -或`while`-循环，则只有一条路径通过该函数，其圈复杂度为 1。如果该函数包含一个代表单个决策点的`if`语句，则有两条路径通过该函数，圈复杂度为 2。

如果圈复杂度很高，受影响的代码通常更难理解、测试和修改，因此容易出现错误。

这三个`if`提出了另一个问题:这个函数是进行这种配置的合适地方吗？肯定不是！这不属于这里。

以下行(从 1814 开始)正在访问附加的配置数据。无法准确确定，但看起来好像上次使用的文件筛选器(“LastFilterName”)是从包含配置数据的源(配置文件或 Windows 注册表)加载的。尤其令人困惑的是，在前面三个`if`-块(`aDlg.SetCurFilter(...)`)中设置的已经定义的过滤器将总是在这个位置被覆盖(见第 1820-1823 行)。那么，在之前的三个`if`-街区设置这个滤镜有什么意义呢？

结束前不久，参考参数`rName`开始发挥作用。等等……请问什么名字？！大概是文件名吧，没错，但是为什么不命名为`filename`以排除一切怀疑的可能呢？还有为什么文件名不是这个函数的返回值？(为什么您应该避免所谓的输出参数是本章稍后讨论的主题。)

似乎这还不够糟糕，该函数还包含注释掉的代码。

这个函数只有大约 50 行，但是它有很多不好的代码味道。函数太长，圈复杂度很高，混合了不同的关注点，有很多参数，并且包含死代码。函数名`QueryFileName()`不具体，可能会引起误解。谁被询问？一个数据库？`AskUserForFilename()`会好很多，因为它强调与用户的互动。大部分代码难以阅读和理解。`nFileType & FT_BASIC_LIBRARY`是什么意思？

但是关键的一点是，这个函数要执行的任务(文件名选择)证明了一个自己的类是正确的，因为作为应用程序 UI 一部分的类`BasicFrame`绝对不负责这些事情。

够了。让我们来看看一个软件设计师在设计好的功能时需要考虑什么。

### 一件事，不能再多了！

一个函数必须有一个非常精确定义的任务，这个任务应该用它重要的名字来表示。在他杰出的著作《干净的代码》中，美籍软件开发人员 Robert C. Martin 将它表述如下:

> The function should do one thing. They should do it well. This is the only thing they should do. —Robert C. Martin, clean code [Martin09]

你现在可能会问:但是我怎么知道一个函数做了太多的事情？以下是一些可能的迹象:

1.  这个函数很大，也就是说，它包含许多行代码(参见下面关于小函数的部分)。
2.  您试图为函数找到一个有意义、有表现力的名称，准确描述其用途，但您无法避免使用连词，如“and”或“or”，来构建名称。(另请参见以下关于名称的章节之一。)
3.  使用空行将函数体垂直分成代表后续步骤的组。通常这些群组还会被引入类似标题的评论。
4.  圈复杂度很高。该函数包含许多“if”、“else”或“switch-case”语句。
5.  该函数有许多参数(参见本章后面关于参数和返回值的部分)，尤其是一个或多个类型为`bool`的标志参数。

### 让他们变小

关于函数的一个中心问题是:函数的最大长度应该是多少？

对于函数的长度，有许多经验法则和启发法。例如，有些人说函数应该垂直显示在屏幕上。好吧，乍一看，这似乎是一个不错的规则。如果一个功能适合屏幕，开发者就不需要滚动。另一方面，我的屏幕高度真的应该决定一个功能的最大尺寸吗？屏幕高度不尽相同。所以，我个人认为这不是一个好的规则。以下是我对这个话题的建议:

函数应该非常小。理想情况下 4-5 行，最多 12-15 行，但不能更多。

恐慌！我已经可以听到抗议声:“许多微小的功能？你说真的吗？!"

是的，我是认真的。正如 Robert C. Martin 在他的书《干净的代码》[Martin09]中所写的:函数应该很小，而且应该更小。

大型函数通常具有很高的复杂性。开发人员通常不能一眼看出这样的函数是做什么的。如果一个功能太大，它通常会有太多的职责(见上一节)，而且不能做一件事情。功能越大，越难理解和维护。这种函数通常包含许多嵌套的决策(`if`、`else`、`switch`)和循环。这也被称为高圈复杂度。

当然，和任何规则一样，很少有合理的例外。例如，一个包含一个大的`switch`语句的函数，如果读起来非常简洁明了，可能是可以接受的。您可以在一个函数中有一个 400 行的`switch`语句(在电信系统中，有时需要处理不同类型的输入数据)，这完全没问题。

#### “但是通话时间开销很大！”

人们现在可能会提出异议，许多小函数降低了程序的执行速度。他们可能会争辩说任何函数调用都是昂贵的。

让我解释一下为什么我认为这些恐惧在大多数情况下是没有根据的。

是的，有时候 C++ 编译器不擅长优化，CPU 也相对较慢。在神话传播的时候，C++ 通常比 C 慢。这种神话是由不太懂语言的人传播的。而且时代变了。

现在的现代 C++ 编译器非常擅长优化。例如，它们可以执行多种局部和全局加速优化。它们可以将许多 C++ 结构(如循环或条件语句)简化为功能相似的高效机器码序列。如果这些函数基本上可以内联的话，它们现在足够智能来自动内联这些函数(…当然，有时这是不可能的)。

甚至链接器也能够执行优化。例如，微软的 Visual-Studio 编译器/链接器提供了一个称为整体程序优化的功能，它允许编译器和链接器使用程序中所有模块的信息来执行全局优化。使用 Visual Studio 的另一项功能(称为分析导向优化),编译器使用从。exe 或。dll 文件。

即使我们不想使用编译器的优化选项，当我们考虑一个函数调用时，我们在谈论什么呢？

英特尔酷睿 i7 2600K CPU 能够在 3.4 GHz 的时钟速度下每秒执行 128，300 百万条指令(MIPS)。女士们，先生们，当我们谈论函数调用时，我们谈论的是几纳秒！光在一纳秒(0.000000001 秒)内传播大约 30 厘米。与计算机上的其他操作相比，如缓存外的内存访问或硬盘访问，函数调用要快得多。

开发人员应该把宝贵的时间花在真正的性能问题上，这些问题通常源于糟糕的架构和设计。只有在非常特殊的情况下，才需要担心函数调用开销。

### 函数命名

一般来说，可以说变量和常量的命名规则尽可能适用于函数和方法。函数名应该清晰、有表现力、不言自明。你不必阅读函数体就能知道它做什么。因为函数定义了程序的行为，所以它们的名字中通常有一个动词。一些特殊的函数被用来提供关于一个状态的信息。他们的名字通常以“是……”或“有……”开头

函数的名字应该以动词开头。谓词，即关于一个对象的可能为真或为假的语句，应该以“是”或“有”开头。

以下是一些表达性方法名称的示例:

```cpp
void CustomerAccount::grantDiscount(DiscountValue discount);

void Subject::attachObserver(const Observer& observer);

void Subject::notifyAllObservers() const;

int Bottling::getTotalAmountOfFilledBottles() const;

bool AutomaticDoor::isOpen() const;

bool CardReader::isEnabled() const;

bool DoubleLinkedList::hasMoreElements() const;
Listing 4-21.Just a few examples of expressive and self-explanatory names for member functions

```

### 使用透露意图的名字

看一下下面的代码行，当然，这只是一个大程序的一小段摘录:

```cpp
std::string head = html.substr(startOfHeader, lengthOfHeader);

```

这行代码原则上看起来不错。有一个名为`html`的 C++ 字符串(头文件`<string>`)，显然包含了一段 HTML(超文本标记语言)。当这一行被执行时，一个子串`html`的副本被检索并分配给一个名为`head`的新字符串。子字符串由两个参数定义:一个参数设置子字符串的起始索引，另一个参数定义子字符串中包含的字符数。

好了，我已经详细解释了如何从一段 HTML 中提取标题。让我向您展示相同代码的另一个版本:

```cpp
std::string ReportRenderer::extractHtmlHeader(const std::string& html) {
  return html.substr(startOfHeader, lengthOfHeader);
}

// ...

std::string head = extractHtmlHeader(html);

Listing 4-22.After introducing an intention-revealing name the code is better understandable.

```

你能看到这样一个小小的改变能给你的代码带来多少清晰吗？我们已经引入了一个小的成员函数，通过它的语义名称来解释它的意图。在原来可以找到字符串操作的地方，我们用新函数的调用代替了对`std::string::substr()`的直接调用。

函数的名字应该表达它的意图/目的，而不是解释它是如何工作的。

工作是如何完成的，这就是你应该从函数体的代码中看到的。不要在函数名中解释 How。相反，从商业的角度来表达功能的目的。

另外，我们还有一个优势。如何从 HTML 页面中提取标题的部分功能已经被准隔离，现在可以更容易地替换，而不必在调用函数的地方摸索。

### 参数和返回值

在我们详细讨论了函数名之后，对于好的干净的函数来说，还有一个重要的方面:函数的参数和返回值。这两者都有助于客户更好地理解和使用函数或方法。

#### 参数数量

一个函数(同义词:方法、操作)最多应该有多少个实参(又名参数)？

在干净的代码中，我们发现了下面的建议:

> The ideal parameter number of the function is nil. Next is one (one yuan), followed by two (two yuan). Three parameters (triples) should be avoided as much as possible. More than three (polygons) need very special reasons-they should not be used in any case. —Robert C. Martin, clean code [Martin09]

这个建议非常有趣，因为 Martin 建议理想的函数应该没有参数。这有点奇怪，因为一个纯数学意义上的函数(y = f(x))总是至少有一个自变量(参见关于函数式编程的章节)。这意味着一个“没有参数的函数”通常会有某种副作用。

注意，Martin 在他的书中使用了用 Java 编写的代码示例，所以当他谈到函数时，他实际上指的是类的方法。我们不得不考虑对象的方法还有一个额外的隐式“参数”:`this`！`this`指针代表执行的上下文。在`this`的帮助下，成员函数可以访问其类的属性，读取或操作它们。换句话说:从成员函数的角度来看，类的属性只是全局变量。因此，马丁法则似乎是一个合适的指导方针，但我认为它主要适用于面向对象的设计。

但是为什么太多的争论是不好的呢？

首先，函数的参数列表中的每个参数都可能导致一个依赖，除了标准内置类型的参数，如`int`或`double`。如果在函数的参数列表中使用复杂类型(例如，类)，则代码依赖于该类型。必须包含包含所用类型的头文件。

此外，每个参数都必须在函数内部的某个地方进行处理(否则，该参数就是不必要的，应该立即删除)。三个参数可以导致一个相对复杂的函数，正如我们从 Apache 的 OpenOffice 的成员函数`BasicFrame::QueryFileName()`的例子中看到的。

在过程编程中，有时很难不超过三个参数。例如，在 C 语言中，你会经常看到带有更多参数的函数。一个令人望而却步的例子是毫无希望的过时的 Windows Win32-API。

```cpp
HWND CreateWindowEx
(
  DWORD dwExStyle,
  LPCTSTR lpClassName,
  LPCTSTR lpWindowName,
  DWORD dwStyle,
  int x,
  int y,
  int nWidth,
  int nHeight,
  HWND hWndParent,
  HMENU hMenu,
  HINSTANCE hInstance,
  LPVOID lpParam
);
Listing 4-23.The Win32 CreateWindowEx function
to create windows

```

显然，这个丑陋的代码来自古代。我很确定，如果它被设计成现在的样子，Windows API 看起来就不会像现在这样了。不是没有原因的，有无数的框架，如微软基础类(MFC)，Qt ( [`https://www.qt.io`](https://www.qt.io) ，或 wxWidgets ( [`https://www.wxwidgets.org`](https://www.wxwidgets.org) )，包装了这种令人毛骨悚然的界面，并提供了更简单和更面向对象的方式来创建图形用户界面(UI)。

并且几乎没有减少参数数量的可能性。您可以将`x`、`y`、`nWidth`和`nHeight`组合成一个名为`Rectangle`的新结构，但是仍然有九个参数。更糟糕的是，这个函数的一些参数是指向其他复杂结构的指针，而这些复杂结构是由许多属性组成的。

在好的面向对象设计中，通常不需要这么长的参数列表。但是 C++ 并不是一门纯面向对象的语言，比如 Java 或者 C#。在 Java 中，所有的东西都必须嵌入到一个类中，这有时会导致大量的代码。在 C++ 中，这不是必需的。在 C++ 中，允许实现独立的函数，也就是说，不是类成员的函数。这很好。

所以我对这个话题的建议是:

实函数应该有尽可能少的参数。一个参数是理想数字。一个类的成员函数(方法)通常没有参数。通常这些函数操纵对象的内部状态，或者用来从对象中查询一些东西。

#### 避免标志参数

标志参数是一种告诉函数根据其值执行不同操作的参数。标志参数大多是类型`bool`，有时甚至是枚举。

```cpp
Invoice Billing::createInvoice(const BookingItems& items, const bool withDetails) {
  if (withDetails) {
    //...
  } else {
    //...
  }
}
Listing 4-24.A flag argument to control the level of detail of an invoice

```

标志参数的基本问题是通过函数引入了两条(有时甚至更多)路径。这种参数通常在函数内部的某个地方用`if`或`switch/case`语句进行评估。它用于决定是否采取某个动作。这意味着函数没有完全正确地做一件事，正如它应该做的那样(参见本章前面的“仅此一件事”一节)。这是一种弱衔接的情况(见第 [3](3.html) 章)，违反了单一责任原则(见第 [6](6.html) 章关于对象定位)。

如果你在代码的某个地方看到函数调用，如果不详细分析函数`Billing::createInvoice()`，你就不知道`true`或`false`到底是什么意思:

```cpp
Billing billing;
Invoice invoice = billing.createInvoice(bookingItems, true);
Listing 4-25.Baffling: What does the ‘true’ in the argument list mean?

```

我的建议是你应该避免旗帜性的争论。如果对执行一个动作的关注没有从它的配置中分离出来，这种类型的争论总是必要的。

一种解决方案是提供单独的、命名良好的函数:

```cpp
Invoice Billing::createSimpleInvoice(const BookingItems& items) {
  //...
}

Invoice Billing::createInvoiceWithDetails(const BookingItems& items) {
  Invoice invoice = createSimpleInvoice(items);
  //...add details to the invoice...
}

Listing 4-26.Easier to comprehend: two member functions with intention-revealing names

```

另一个解决方案是计费的专业化层次结构:

```cpp
class Billing {

public:

  virtual Invoice createInvoice(const BookingItems& items) = 0;
  // ...
};

class SimpleBilling : public Billing {

public:

  virtual Invoice createInvoice(const BookingItems& items) override;
  // ...
};

class DetailedBilling : public Billing {

public:
  virtual Invoice createInvoice(const BookingItems& items) override;
  // ...

private:

  SimpleBilling simpleBilling;
};

Listing 4-27.Different levels of details for invoices, realized the object-oriented way

```

类型为`SimpleBilling`的私有成员变量在类`DetailedBilling`中是必需的，以便能够首先执行简单的发票创建，而不需要代码复制，然后将细节添加到发票中。

Override Specifier [C++11]

从 C++11 开始，可以明确指定虚函数应该覆盖基类虚函数。为此，引入了`override`标识符。

如果`override`紧接在成员函数声明之后出现，编译器将检查该函数是否为虚函数，并且正在从基类中重写虚函数。因此，当开发人员仅仅认为他们已经覆盖了一个虚拟函数，但实际上他们已经更改/添加了一个新函数时，例如，由于打字错误，他们可以避免出现微妙的错误。

#### 避免输出参数

输出参数，有时也称为结果参数，是用于函数返回值的函数参数。

经常提到的使用输出参数的好处之一是使用它们的函数可以一次传回多个值。下面是一个典型的例子:

```cpp
bool ScriptInterpreter::executeCommand(const std::string& name,
                        const std::vector<std::string>& arguments,
                        Result& result);

```

这个类`ScriptInterpreter`的成员函数不仅返回一个`bool`。第三个参数是对类型为`Result`的对象的非常数引用，它代表函数的实际结果。布尔返回值用于确定解释器是否成功执行了命令。此成员函数的典型调用可能如下所示:

```cpp
ScriptInterpreter interpreter;
// Many other preparations...
Result result;

if (interpreter.executeCommand(commandName, argumentList, result)) {
  // Continue normally...
} else {
  // Handle failed execution of command...
}

```

我的简单建议是:

不惜一切代价避免输出参数。

输出参数不直观，会导致混乱。调用者有时不容易发现一个被传递的对象是否被当作一个输出参数，并且可能被函数改变。

此外，输出参数使表达式的简单组合变得复杂。如果函数只有一个返回值，它们可以很容易地与链接的函数调用相互连接。相反，如果函数有多个输出参数，开发人员就不得不准备和处理所有保存结果值的变量。因此，调用这些函数的代码会很快变得一团糟。

特别是如果应该培养不变性并且必须减少副作用，那么输出参数绝对是一个可怕的想法。不出所料，仍然无法将一个不可变的对象(见第 [9](9.html) 章)作为输出参数传递。

如果一个方法应该返回一些东西给它的调用者，让方法返回它作为方法返回值。如果该方法必须返回多个值，请重新设计它，以返回保存这些值的对象的单个实例。或者，可以使用`std::tuple`(见侧栏)或`std::pair`。

std::tuple AND std::make_tuple [C++11]

从 C++11 开始，有时有用的类模板就可用了，它可以保存固定大小的不同种类值的集合。对象:`std::tuple`。在标题`<tuple>`中定义如下:

```cpp
template< class... Types >

class tuple;

```

它是一个所谓的可变模板，也就是说，它是一个可以接受可变数量的模板参数的模板。例如，如果您必须将不同类型的几个不同值保存为一个对象，您可以编写以下代码:

```cpp
using Customer = std::tuple<std::string, std::string, std::string, Money, unsigned int>;
// ...
Customer aCustomer = std::make_tuple("Stephan", "Roth", "Bad Schwartau",
  outstandingBalance, timeForPaymentInDays);

```

`std::make_tuple`创建元组对象，从参数类型中推导出目标类型。使用`auto`关键字，你可以让编译器从初始化器中推断出`aCustomer`的类型:

```cpp
auto aCustomer = std::make_tuple("Stephan", "Roth", "Bad Schwartau",
  outstandingBalance, timeForPaymentInDays);

```

不幸的是，只能通过索引来访问`std::tuple`实例的单个元素。例如，要从客户处检索城市，您必须编写以下代码:

```cpp
auto city = std::get<2>(aCustomer);

```

这是违反直觉的，会降低代码的可读性。

我的建议是只在特殊情况下使用`std::tuple`类模板。它只应该用来临时组合那些无论如何都不属于一起的东西。一旦数据(属性、对象)必须放在一起，因为它们的内聚性很高，这通常证明了为这一堆数据引入显式类型是正确的:类！

如果你还必须基本区分成功和失败，那么你可以使用所谓的特例对象模式(参见第 [9](9.html) 章关于设计模式)来返回一个代表无效结果的对象。

#### 不要传递或返回 0 (NULL，nullptr)

The Billion Dollar Mistake

查尔斯·安东尼·理查德·霍尔爵士，通常被称为东尼·霍尔或 C. A. R .霍尔，是英国著名的计算机科学家。他主要以快速排序算法而闻名。1965 年，东尼·霍尔与瑞士计算机科学家尼克劳斯·沃斯一起进一步开发了程序语言 ALGOL。他在编程语言 ALGOL W 中引入了空引用，ALGOL W 是 PASCAL 的前身。

40 多年后，东尼·霍尔后悔了这个决定。在伦敦 QCon 2009 会议的一次演讲中，他说引入空引用可能是一个历史性的十亿美元的错误。他认为，在过去的几个世纪中，空引用已经造成了如此多的问题，其成本可能约为 10 亿美元。

在 C++ 中，指针可以指向`NULL`或者`0`。具体来说，这意味着指针指向的内存地址`0\. NULL`只是一个宏定义:

```cpp
#define NULL    0

```

从 C++11 开始，该语言提供了新的关键字`nullptr`，其类型为`std::nullptr_t`。

有时我会看到这样的函数:

```cpp
Customer* findCustomerByName(const std::string& name) const {
  // Code that searches the customer by name...
  // ...and if the customer could not be found:
  return nullptr; // ...or NULL;
}

```

接收`NULL`或`nullptr`(从这里开始，为了简单起见，我在下面的文本中只使用`nullptr`)作为一个函数的返回值可能会令人困惑。打电话的人该怎么处理？这是什么意思？在上面的例子中，具有给定名称的客户可能不存在。但这也意味着可能出现了严重错误。一个`nullptr`可以意味着失败，可以意味着成功，几乎可以意味着任何事情。

我的建议是:

如果函数或方法的结果不可避免地要返回一个常规指针，不要返回`nullptr`！

换句话说:如果你被迫返回一个常规指针作为函数的结果(我们将在后面看到可能有更好的选择)，确保你返回的指针总是指向一个有效的地址。以下是我认为这很重要的原因。

为什么不应该从函数返回`nullptr`的主要理由是，你将决定做什么的责任转移给了调用者。他们必须检查一下。他们不得不面对它。如果函数可能返回`nullptr,`，这将导致许多空检查，如下所示:

```cpp
Customer* customer = findCustomerByName("Stephan");

if (customer != nullptr) {
  OrderedProducts* orderedProducts = customer->getAllOrderedProducts();
  if (orderedProducts != nullptr) {
    // Do something with orderedProducts...
  } else {
    // And what should we do here?
  }
} else {
  // And what should we do here?
}

```

许多空检查降低了代码的可读性，增加了代码的复杂性。还有一个可见的问题直接把我们引向下一点。

如果一个函数可以返回一个有效的指针或`nullptr`，它会引入一个替代的流程，需要由调用者继续执行。这应该会导致一个合理和明智的反应。这有时很成问题。当我们指向`Customer`的指针不是指向一个有效的实例，而是指向`nullptr`时，我们程序中正确、直观的反应是什么？程序应该用一个消息中止正在运行的操作吗？在这种情况下，是否有某种类型的程序延续是强制性的要求？这些问题有时无法很好地回答。经验表明，对于涉众来说，描述他们的软件的所有所谓的快乐日案例通常是相对容易的，这些案例是正常操作期间的正面案例。描述软件在异常、错误和特殊情况下的预期行为要困难得多。

最糟糕的后果可能是这样的:如果任何空检查被遗忘，这可能导致严重的运行时错误。取消对空指针的引用将导致分段错误，并且您的应用程序会崩溃。

在 C++ 中，还有另一个问题需要考虑:对象所有权。

对于函数的调用者来说，在使用后如何处理指针所指向的资源是模糊的。它的主人是谁？是否需要删除对象？如果是:如何处置资源？对象必须用`delete`删除吗，因为它在函数内部的某个地方用`new`操作符分配了？还是对资源对象的所有权进行了不同的管理，以至于禁止了一个`delete`，会导致未定义的行为(参见第 [5](5.html) 章中的“不允许未定义的行为”一节)？它甚至可能是一种必须以非常特殊的方式处理的操作系统资源吗？

根据信息隐藏原则(参见第 [3 章](3.html))这应该与调用者无关，但事实上我们已经将资源的责任强加给他了。如果调用者没有正确处理指针，就会导致严重的错误，例如，内存泄漏、重复删除、未定义的行为，有时还会导致安全漏洞。

#### 避免常规指针的策略

##### 更喜欢在堆栈上而不是堆上构造简单的对象

创建新对象最简单的方法就是在堆栈上创建它，就像这样:

```cpp
#include "Customer.h"
// ...
Customer customer;

```

在上面的例子中，类`Customer`(在头文件`Customer.h`中定义)的一个实例在堆栈上被创建。创建实例的代码行通常可以在函数或方法体的某个地方找到。这意味着，如果函数或方法超出范围，实例会自动销毁，这发生在我们分别从函数或方法返回时。

目前为止，一切顺利。但是，如果在函数或方法中创建的对象必须返回给调用者，我们该怎么办呢？

在旧式的 C++ 中，这种挑战通常以这样一种方式来处理，即在堆上创建对象(使用操作符`new`)，然后从函数返回，作为指向该分配资源的指针。

```cpp
Customer* createDefaultCustomer() {
  Customer* customer = new Customer();
  // Do something more with customer, e.g. configuring it, and at the end...
  return customer;
}

```

这种方法的可理解的原因是，如果我们正在处理一个大的对象，可以通过这种方式避免昂贵的副本构造。但是我们已经在上一节讨论了这种解决方案的缺点。例如，如果返回的指针是`nullptr`，调用者应该做什么？此外，函数的调用者被迫负责资源管理(例如，以正确的方式删除返回的指针)。

好消息:从 C++11 开始，我们可以简单地将大型对象作为值返回，而不用担心代价高昂的副本构造。

```cpp
Customer createDefaultCustomer() {
  Customer customer;
  // Do something with customer, and at the end...
  return customer;
}

```

在这种情况下，我们不再需要担心资源管理的原因是所谓的移动语义，从 C++11 开始就支持这种语义。简单地说，移动语义的概念允许资源从一个对象“移动”到另一个对象，而不是复制它们。术语“移动”在这个上下文中意味着对象的内部数据被从旧的源对象中移除并被放置到新的对象中。它是将数据的所有权从一个对象转移到另一个对象，并且这可以极快地执行(C++11 move 语义将在下一章 [5](5.html) 中详细讨论)。

在 C++11 中，所有的标准库容器类都被扩展到支持移动语义。这不仅使它们非常有效，而且也更容易处理。例如，要以非常高效的方式从函数中返回一个包含字符串的大型向量，您可以像下面的示例所示那样进行操作:

```cpp
#include <vector>

#include <string>

using StringVector = std::vector<std::string>;

const StringVector::size_type AMOUNT_OF_STRINGS = 10000;

StringVector createLargeVectorOfStrings() {
  StringVector theVector(AMOUNT_OF_STRINGS, "Test");
  return theVector; // Guaranteed no copy construction here!
}

Listing 4-28.Since C++11, a locally instantiated and large object can be easily returned by value

```

利用移动语义是摆脱大量正则指针的一个非常好的方法。但是我们可以做得更多…

##### 在函数的参数列表中，使用(const)引用而不是指针

而不是写…

```cpp
void function(Type* argument);

```

…您应该使用 C++ 引用，就像这样:

```cpp
void function(Type& argument);

```

对参数使用引用而不是指针的主要优点是不需要检查引用是否是`nullptr`。原因很简单，引用从来不是"`NULL."`(好吧，我知道有一些微妙的可能性，你仍然可以以一个空引用结束，但这些都预示着一个非常愚蠢或业余的编程风格。)

另一个好处是，你不需要借助解引用操作符(`*`)来解引用函数内部的任何东西。这将导致更干净的代码。引用可以在函数内部使用，因为它是在堆栈上本地创建的。当然，如果您不想有任何副作用，您应该使它成为一个 const 引用(参见即将到来的关于 Const 正确性的部分)。

##### 如果不可避免地要处理指向资源的指针，那么就使用智能指针

如果因为必须在堆上强制创建资源而不可避免地使用指针，您应该立即包装它，并利用所谓的 RAII 习惯用法(资源获取是初始化)。这意味着你应该为它使用一个智能指针。由于智能指针和 RAII 习惯用法在现代 C++ 中扮演着重要的角色，因此在第 [5](5.html) 章中有一个关于这个主题的专门章节。

##### 如果一个 API 返回一个原始指针…

…，那么，我们就有了一个“视情况而定”的问题

指针经常从或多或少不受我们控制的 API 中返回。典型的例子是第三方库。

幸运的是，我们面对的是一个设计良好的 API，它提供了创建资源的工厂方法，还提供了将资源交还给库进行安全和适当处理的方法，我们赢了。在这种情况下，我们可以再次利用 RAII 习惯用法(资源获取是初始化；参见第 [5 章](5.html)。我们可以创建一个定制的智能指针来包装常规指针。解除分配程序可以按照第三方库的预期处理托管资源。

#### 一致性的力量

在 C++ 中，Const 正确性是一种更好、更安全代码的强大方法。使用`const`可以省去很多麻烦和调试时间，因为违反`const`会导致编译时错误。而作为一种副作用，`const`的使用也可以支持编译器应用它的一些优化算法。这意味着正确使用这个限定符也是稍微提高程序执行性能的一种简单方法。

不幸的是，大量使用`const`的好处被许多开发者低估了。我的建议是:

注意 const 的正确性。尽可能多地使用`const`,并且总是选择变量或对象的适当声明作为可变或不可变的。

一般来说，C++ 中的关键字`const`防止对象被程序变异。但是`const`可以用在不同的上下文中。关键字有很多面。

它最简单的用法是将变量定义为常数:

```cpp
const long double PI = 3.141592653589794;

```

另一个用途是防止传递给函数的参数发生变异。因为有几种变体，所以经常会导致混淆。以下是一些例子:

1.  指针`car`指向类型`Car`的常量对象，即`Car`对象(“指针对象”)不能被修改。
2.  指针`car`是一个类型为`Car`的常量指针，也就是说，你可以修改`Car`对象，但是你不能修改指针(例如，给它分配一个`Car`的新实例)。
3.  在这种情况下，指针和指针对象(`Car`对象)都不能被修改。
4.  参数`message`通过 const 引用传递给函数，即被引用的字符串变量不允许在函数内部改变。
5.  这只是 const 引用参数的另一种表示法。它在功能上等同于第 4 行(…顺便说一下，我更喜欢第 4 行)。

```cpp
unsigned int determineWeightOfCar(Car const* car); // 1

void lacquerCar(Car* const car); // 2

unsigned int determineWeightOfCar(Car const* const car); // 3

void printMessage(const std::string& message); // 4

void printMessage(std::string const& message); // 5

```

Tip

以正确的方式阅读`const`限定符有一个简单的经验法则。如果你从右向左读，那么任何出现的`const`限定词都会修改它左边的东西。例外:如果左边什么都没有，例如，在一个声明的开头，那么`const`把它右边的东西修改了。

`const`关键字的另一个用途是将一个类的(非静态)成员函数声明为`const`，如第 5 行的例子所示:

```cpp
#include <string>

class Car {

public:

  std::string getRegistrationCode() const;
  void setRegistrationCode(const std::string& registrationCode);
  // ...

private:

  std::string _registrationCode;
  // ...
};

```

与第 6 行的 setter 相反，第 5 行的成员函数`getRegistrationCode`不能修改类`Car`的成员变量。下面的`getRegistrationCode`实现将导致编译器错误，因为该函数试图给`_registrationCode`分配一个新的字符串:

```cpp
std::string Car::getRegistrationCode() {
  std::string toBeReturned = registrationCode;
  registrationCode = "foo"; // Compile-time error!
  return toBeReturned;
}

```

## 关于 C++ 项目中的旧 C 风格

如果你研究一下相对较新的 C++ 程序(例如，在 GitHub 或 Sourceforge 上)，你会惊讶于这些所谓的“新”程序中有多少仍然包含无数行旧的 C 代码。嗯，C 仍然是 C++ 语言的一个子集。这意味着 C 的语言元素仍然可用。不幸的是，在编写干净、安全和现代的代码时，许多这些旧的 C 结构都有严重的缺陷。显然还有更好的选择。

因此，一个基本的建议是，只要有更好的 C++ 替代方案，就不要使用那些旧的、容易出错的 C 结构。这些可能性有很多。如今，在现代 C++ 中，你几乎可以完全不用 C 编程。

### 比起旧的 C 风格的字符，更喜欢 C++ 字符串和流*

所谓的 C++ 字符串是 C++ 标准库的一部分，属于类型`std::string`或`std::wstring`(都在头文件`<string>`中定义)。事实上，两者都是类模板`std::basic_string<T>`上的类型定义，并且是这样定义的:

```cpp
typedef basic_string<char> string;

typedef basic_string<wchar_t> wstring;

```

要创建这样的字符串，必须实例化这两个模板之一的对象，例如，使用它们的初始化构造函数:

```cpp
std::string name("Stephan");

```

与此相比，所谓的 C 风格字符串只是一个以所谓的零终止符(有时也称为空终止符)结尾的字符数组(类型`char`或`wchar_t`)。零终止符是一个特殊字符(`\0`，ASCII 码 0)，用来表示字符串的结束。C 风格的字符串可以这样定义:

```cpp
char name[] = "Stephan";

```

在这种情况下，零终止符会自动添加到字符串的末尾，即字符串的长度为 8 个字符。重要的一点是，我们必须记住，我们仍然在处理一组字符。这意味着，例如，它有一个固定的大小。您可以使用 index 运算符更改数组的内容，但是不能在数组末尾添加更多的字符。如果结尾的零终止符被意外覆盖，这可能会导致各种问题。

字符数组通常在指向第一个元素的指针的帮助下使用，例如，当它作为函数参数传递时:

```cpp
char* pointerToName = name;

void function(char* pointerToCharacterArray) {
  //...
}

```

然而，在许多 C++ 程序以及教科书中，C-string 仍然被频繁使用。现在的 C++ 有什么好的理由使用 C 风格的字符串吗？

是的，有些情况下你仍然可以使用 C 风格的字符串。我将介绍一些例外情况。但是对于现代 C++ 程序中应用的大量字符串，它们应该使用 C++ 字符串来实现。与旧的 C 风格字符串相比，类型分别为`std::string`和`std::wstring`的对象提供了许多优势:

*   C++ 字符串对象自己管理它们的内存，所以你可以很容易地复制、创建和销毁它们。这意味着它们将您从管理字符串数据的生命周期中解放出来，使用 C 风格的字符数组时，这可能是一项棘手且令人生畏的任务。
*   它们是可变的。可以通过各种方式轻松操作字符串:添加字符串或单个字符、连接字符串、替换字符串的一部分等。
*   C++ 字符串提供了一个方便的迭代器接口。与所有其他标准库容器类型一样，`std::string`和`std::wstring`分别允许您迭代它们的元素(即，它们的字符)。这也意味着在标题`<algorithm>`中定义的所有合适的算法都可以应用于字符串。
*   C++ 字符串与 C++ I/O 流(例如，`ostream`、`stringstream`、`fstream`等)完美地协同工作。)以便您可以轻松利用所有这些有用的流工具。
*   从 C++11 开始，标准库广泛使用 move 语义。许多算法和容器现在都是移动优化的。这也适用于 C++ 字符串。例如，`std::string`的一个实例通常可以简单地作为函数的返回值返回。以前仍然需要使用指针或引用的方法来有效地从函数返回大型字符串对象，也就是说，不需要昂贵的字符串数据复制，现在已经不再需要了。

总之，可以提出以下建议:

除了少数例外，现代 C++ 程序中的字符串应该用来自标准库的 C++ 字符串来表示。

好吧，但是证明使用旧的 C 风格字符串是正确的少数例外是什么呢？

一方面，有字符串常量，即不可变的字符串。如果你只是需要一个固定字符的固定数组，那么`std::string`提供的优势很小。例如，您可以这样定义一个字符串常量:

```cpp
const char* const PUBLISHER = "Apress Media LLC";

```

在这种情况下，既不能改变所指向的值，也不能修改指针本身(参见关于常量正确性的部分)。

使用 C 字符串的另一个原因是与 C 风格 API 各自的库兼容。许多第三方库通常具有低级接口，以确保向后兼容性，并保持其使用范围尽可能广泛。在这样的 API 中，字符串通常被认为是 C 风格的字符串。然而，即使在这种情况下，C 风格字符串的使用也应该局限于这个接口的处理。除了使用这样的 API 进行数据交换，只要有可能，就应该使用更加舒适的 C++ 字符串。

### 避免使用 printf()、sprintf()、gets()等。

`printf()`，它是 C 库的一部分，用于执行输入/输出操作(在头文件`<cstdio>`中定义)，将格式化数据打印到标准输出(stdout)。一些开发人员仍然在他们的 C++ 代码中使用大量的`printf`来进行跟踪/记录。他们经常争辩说`printf`是…不…它一定比 C++ I/O 流快得多，因为整个 C++ 开销都不见了。

首先，无论如何，I/O 都是一个瓶颈，不管你使用的是`printf()`还是`std::cout`。在标准输出上写任何东西通常都很慢，比程序中的大多数其他操作都慢。在某些情况下，`std::cout`可能比`printf()`稍慢，但是相对于 I/O 操作的总成本来说，这几微秒通常可以忽略不计。在这一点上，我还想提醒大家小心(过早的)优化(记得第 [3](3.html) 章中的“小心优化”一节)。

其次，`printf()`从根本上说是类型不安全的，因此容易出错。该函数需要一系列非类型化参数，这些参数与填充了格式说明符的 C 字符串相关，这是第一个参数。不能安全使用的函数永远不要使用，因为这会导致细微的错误、未定义的行为(参见第 [5](5.html) 章中关于未定义行为的章节)和安全漏洞。

std::to_String() [C++11]

在现代 C++ 程序中，不要使用 C 函数`sprintf()`(头文件`<cstdio>`)进行转换。从 C++11 开始，所有数值类型的变量都可以通过安全方便的`std::to_string()`和`std::to_wstring()`函数转换成 C++ 字符串，这两个函数在头文件`<string>`中定义。例如，可以通过以下方式将带符号整数转换为包含值的文本表示的`std::string`:

```cpp
int value { 42 };
std::string valueAsString = std::to_string(value);

```

`std::to_string()`、`std::to_wstring()`分别适用于所有整型或浮点型，如`int`、`long`、`long long`、`unsigned int`、`float`、`double`等。但是这个简单的转换助手的一个主要缺点是在某些情况下不准确。

```cpp
double d { 1e-9 };
std::cout << std::to_string(d) << "\n"; // Caution! Output: 0.000000

```

此外，没有配置功能来控制`to_string()`如何格式化输出字符串，例如，小数位数。这意味着这个函数实际上只能在真实程序中很小程度上使用。如果需要更精准、定制化的转换，就得自己提供。除了使用`sprintf()`，你还可以利用字符串流(头文件`<sstream>`)和头文件`<iomanip>`中定义的 I/O 操作器的配置功能，如下例所示:

```cpp
#include <iomanip>

#include <sstream>

#include <string>

std::string convertDoubleToString(const long double valueToConvert, const int precision) {
  std::stringstream stream { };
  stream << std::fixed << std::setprecision(precision) << valueToConvert;
  return stream.str();
}

```

第三，与`printf`不同，C++ I/O 流允许通过提供一个定制的插入操作符(`operator<<`)来轻松地对复杂对象进行流处理。假设我们有一个类`Invoice`(在名为`Invoice.h`的头文件中定义)，如下所示:

```cpp
01  #ifndef INVOICE_H_
02  #define INVOICE_H_
03
04  #include <chrono>
05  #include <memory>
06  #include <ostream>
07  #include <string>
08  #include <vector>
09
10  #include "Customer.h"
11  #include "InvoiceLineItem.h"
12  #include "Money.h"
13  #include "UniqueIdentifier.h"
14
15  using InvoiceLineItemPtr = std::shared_ptr<InvoiceLineItem>;
16  using InvoiceLineItems = std::vector<InvoiceLineItemPtr>;
17
18  using InvoiceRecipient = Customer;
19  using InvoiceRecipientPtr = std::shared_ptr<InvoiceRecipient>;
20
21  using DateTime = std::chrono::system_clock::time_point;
22
23  class Invoice {
24  public:

25    explicit Invoice(const UniqueIdentifier& invoiceNumber);
26    Invoice() = delete;
27    void setRecipient(const InvoiceRecipientPtr& recipient);
28    void setDateTimeOfInvoicing(const DateTime& dateTimeOfInvoicing);
29    Money getSum() const;
30    Money getSumWithoutTax() const;
31    void addLineItem(const InvoiceLineItemPtr& lineItem);
32    // ...possibly more member functions here...
33
34  private:

35    friend std::ostream& operator<<(std::ostream& outstream, const Invoice& invoice);
36    std::string getDateTimeOfInvoicingAsString() const;
37
38    UniqueIdentifier invoiceNumber;
39    DateTime dateTimeOfInvoicing;
40    InvoiceRecipientPtr recipient;
41    InvoiceLineItems invoiceLineItems;
42  };
43  // ...
Listing 4-29.An excerpt from file Invoice.h with line numbers

```

该类依赖于一个发票接受者(在本例中，它是在标题`Customer.h`中定义的`Customer`的别名);见第 18 行)，并使用代表发票号的标识符(类型`UniqueIdentifier`)，保证该发票号在所有发票号中是唯一的。此外，发票使用了一种可以表示金额的数据类型(参见第 [9](9.html) 章关于设计模式的“货币类”一节)，以及对另一种表示单个发票行项目的数据类型的依赖。后者用于使用`std::vector`管理发票内的发票项目列表(分别参见第 16 行和第 41 行)。为了表示开具发票的时间，我们使用了 Chrono 库中的数据类型`time_point`(在头文件`<chrono>`中定义)，这种数据类型从 C++11 开始就可用了。

现在让我们进一步想象，我们希望将整个发票及其所有数据流式传输到标准输出。如果我们可以写一些像…这样的东西，不是很简单和方便吗

```cpp
std::cout << instanceOfInvoice;

```

嗯，用 C++ 这是可能的。输出流的插入操作符(`<<`)可以为任何类重载。我们只需在头部的类声明中添加一个`operator<<`函数。让这个函数成为类的朋友是很重要的(见第 35 行),因为它将在不创建对象的情况下被调用。

```cpp
43  // ...
44  std::ostream& operator<<(std::ostream& outstream, const Invoice& invoice) {
45    outstream << "Invoice No.: " << invoice.invoiceNumber << "\n";
46    outstream << "Recipient: " << *(invoice.recipient) << "\n";
47    outstream << "Date/time: " << invoice.getDateTimeOfInvoicingAsString() << "\n";
48    outstream << "Items:" << "\n";
49    for (const auto& item : invoice.invoiceLineItems) {
50      outstream << "    " << *item << "\n";
51    }
52    outstream << "Amount invoiced: " << invoice.getSum() << std::endl;
53    return outstream;
54  }
55  // ...
Listing 4-30.The insertion operator for class Invoice

```

类`Invoice`的所有结构组件都被写入函数内部的输出流中。这是可能的，因为类`UniqueIdentifier`、`InvoiceRecipient`和`InvoiceLineItem`对于输出流也有它们自己的插入操作符函数(这里没有显示)。为了打印 vector 中的所有行项目，使用了一个基于 C++11 范围的 for 循环。为了获得发票日期的文本表示，我们使用一个名为`getDateTimeOfInvoicingAsString()`的内部助手方法，它返回一个格式良好的日期/时间字符串。

所以，我对现代 C++ 程序的建议是:

避免使用`printf()`，以及其他不安全的 C 函数，如`sprintf()`、`puts()`等。

### 比起简单的 C 风格数组，更喜欢标准的库容器

不要使用 C 风格的数组，应该使用从 C++11 开始可用的`std::array<TYPE, N>`模板(header `<array>`)。`std::array<TYPE, N>`的实例是固定大小的序列容器，和普通的 C 风格数组一样有效。

C 风格数组的问题与 C 风格字符串的问题大致相同(参见上一节)。c 数组是不好的，因为它们是作为指向第一个元素的原始指针传递的。这可能很危险，因为没有绑定检查来保护该数组的用户访问不存在的元素。用`std::array`构建的数组更安全，因为它们不会衰减为指针(参见本章前面的“避免常规指针的策略”一节)。

使用`std::array`的一个优点是它知道自己的大小(元素的数量)。使用数组时，数组的大小是经常需要的重要信息。普通的 C 风格数组不知道自己的大小。因此，数组的大小通常必须作为附加信息来处理，例如，在附加变量中。例如，大小必须作为附加参数传递给函数调用，如下例所示。

```cpp
const std::size_t arraySize = 10;
MyArrayType array[arraySize];

void function(MyArrayType const* array, const std::size_t arraySize) {
  // ...
}

```

严格地说，在这种情况下数组和它的大小并没有形成一个内聚的单元(参见第 [3](3.html) 章中关于强内聚的部分)。此外，从上一节关于参数和返回值的内容中，我们已经知道函数参数的数量应该尽可能少。

相反，`std::array`的实例携带它们的大小，任何实例都可以被查询。因此，函数或方法的参数列表不需要关于数组大小的额外参数:

```cpp
#include <array>

using MyTypeArray = std::array<MyType, 10>;

void function(const MyTypeArray& array) {
  const std::size_t arraySize = array.size();
  //...
}

```

`std::array`另一个值得注意的优点是它有一个兼容 STL 的接口。类模板提供了公共成员函数，所以它看起来像标准库中的其他容器。例如，一个数组的用户可以使用`std::array::begin()`和`std::array::end()`分别得到一个指向序列开始和结束的迭代器。这也意味着标题`<algorithm>`中的算法可以应用到数组中(参见下一章中关于算法的章节)。

```cpp
#include <array>

#include <algorithm>

using MyTypeArray = std::array<MyType, 10>;
MyTypeArray array;

void doSomethingWithEachElement(const MyType& element) {
  // ...
}

std::for_each(std::cbegin(array), std::cend(array), doSomethingWithEachElement);

```

Non-Member std::begin( ) and std::end( ) [C++11/14]

每个 C++ 标准库容器分别有一个`begin()``cbegin()`和一个`end()``cend()`成员函数来检索容器的迭代器和常量迭代器。

C++11 为此引入了免费的非成员函数:`std::begin(<container>)`和`std::end(<container>).`在 C++14 中，添加了仍然缺失的函数`std::cbegin(<container>)`、`std::cend(<container>)`、`std::rbegin(<container>)`和`std::rend(<container>)`。现在建议不要使用成员函数，而是使用这些非成员函数(都在 header `<iterator>`中定义)来获取容器的迭代器和常量迭代器，如下所示:

```cpp
#include <vector>

std::vector<AnyType> aVector;

auto iter = std::begin(aVector); // ...instead of 'auto iter = aVector.begin();'

```

原因是这些免费函数允许更灵活和通用的编程风格。例如，许多用户定义的容器没有`begin()`和`end()`成员函数，这使得它们无法用于标准库算法(参见第 [5](5.html) 章中关于算法的部分)或任何其他需要迭代器的用户定义的模板函数。检索迭代器的非成员函数是可扩展的，因为它们可以为任何类型的序列重载，包括旧的 C 风格的数组。换句话说:非 STL 兼容的(自定义)容器可以用迭代器功能进行改进。

例如，假设您必须处理一个 C 风格的整数数组，如下所示:

```cpp
int fibonacci[] = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 };

```

这种类型的数组现在可以用一个标准的符合库的迭代器接口来改进。对于 C 风格的数组，标准库中已经提供了这样的函数，所以您不必自己编程。它们看起来或多或少像这样:

```cpp
template <typename Type, std::size_t size>
Type* begin(Type (&element)[size]) {
    return &element[0];
}

template <typename Type, std::size_t size>
Type* end(Type (&element)[size]) {
    return &element[0] + size;
}

```

要将数组的所有元素插入到输出流中，例如，要在标准输出中打印它们，我们现在可以编写:

```cpp
int main() {
  for (auto it = begin(fibonacci); it != end(fibonacci); ++it) {
    std::cout << *it << ", ";
  }
  std::cout << std::endl;
  return 0;
}

```

为定制容器类型或旧的 C 风格数组提供重载的`begin()`和`end()`函数，可以将所有标准库算法应用于这些类型。

此外，`std::array`可以在成员函数`std::array::at(size_type n)`的帮助下访问包括绑定检查在内的元素。如果给定的索引超出界限，就会抛出类型为`std::out_of_bounds`的异常。

### 使用 C++ 强制转换代替旧的 C 风格强制转换

在一个错误的印象出现之前，我想首先提出一个重要的警告:

Warning

类型转换基本上是不好的，应该尽可能避免！它们是一个可信的迹象，表明一定存在设计问题，尽管只是相对微小的问题。

但是，如果在某种情况下无法避免类型强制转换，那么在任何情况下都不应该使用 C 样式强制转换:

```cpp
double d { 3.1415 };

int i = (int)d;

```

在这种情况下，double 被降级为整数。这种显式转换伴随着精度的损失，因为浮点数的小数位被丢弃了。C 风格类型的显式转换是这样说的:“编写这行代码的程序员知道后果。”

这当然比隐式类型转换要好。然而，您应该使用 C++ 强制转换进行显式类型转换，而不是使用旧的 C 风格强制转换，如下所示:

```cpp
int i = static_cast<int>(d);

```

对这个建议的简单解释是:C++ 风格的强制转换是由编译器在编译时检查的！c 风格的类型转换不是这样检查的，因此它们可能会在运行时失败，这可能会导致严重的错误或应用程序崩溃。例如，一个临时使用的 C-style 强制转换可能会导致堆栈损坏，如下例所示。

```cpp
int32_t i { 200 };                  // Reserves and uses 4 byte memory
int64_t* pointerToI = (int64_t*)&i; // Pointer points to 8 byte

*pointerToI = 9223372036854775807;  // Can cause run-time error through stack corruption

```

显然，在这种情况下，可以将一个 64 位的值写入一个只有 32 位大小的内存区域。问题是编译器无法将我们的注意力吸引到这段具有潜在危险的代码上。编译器翻译这段代码，即使使用非常保守的设置(`g++ -std=c++17 -pedantic -pedantic-errors -Wall -Wextra -Werror -Wconversion`)，也没有抱怨。这可能会在程序执行过程中导致非常隐蔽的错误。

现在让我们看看如果我们在第二行使用 C++ `static_cast`而不是旧的和糟糕的 C 风格类型转换会发生什么:

```cpp
int64_t* pointerToI = static_cast<int64_t*>(&i); // Pointer points to 8 byte

```

编译器现在能够发现有问题的转换，并报告相应的错误消息:

```cpp
error: invalid static_cast from type 'int32_t* {aka int*}' to type 'int64_t* {aka long int*}'

```

您应该使用 C++ 强制转换而不是旧的 C 风格强制转换的另一个原因是，在程序中很难发现 C 风格的强制转换。它们既不容易被开发人员发现，也不能使用普通编辑器或文字处理器方便地搜索。相比之下，搜索诸如`static_cast<>`、`const_cast<>`或`dynamic_cast<>`这样的术语非常容易。

一目了然，以下是关于现代设计良好的 C++ 程序的类型转换的所有建议:

1.  在任何情况下都要尽量避免类型转换(强制转换)。相反，请尝试消除迫使您使用转换的底层设计错误。
2.  如果显式类型转换不可避免，请只使用 C++ 风格的强制转换(`static_cast<>`或`const_cast<>`)，因为这些强制转换会被编译器检查。永远不要使用旧的和不好的 C 风格造型。
3.  注意`dynamic_cast<>`也不应该被使用，因为它被认为是糟糕的设计。对一个`dynamic_cast<>`的需求是一个可靠的指示，表明专门化层次结构中有问题(这个主题将在关于面向对象的第 [6](6.html) 章中更深入)。
4.  在任何情况下，都不要使用`reinterpret_cast<>`。这种类型转换标志着不安全、不可移植和依赖于实现的强制转换。它又长又不方便的名字是一个广泛的提示，让你思考你目前正在做什么。

### 避免宏

也许 C 语言最重要的遗产之一就是宏。宏是一段可以通过名称识别的代码。如果所谓的预处理器在编译时在程序的源代码中找到一个宏的名称，该名称将被其相关的代码片段替换。

一种类型的宏是类似对象的宏，通常用于为数字常量提供符号名称，如下例所示。

```cpp
#define BUFFER_SIZE 1024

#define PI 3.14159265358979
Listing 4-31.Two examples of object-like macros

```

宏的其他典型示例如下:

```cpp
#define MIN(a,b) (((a)<(b))?(a):(b))

#define MAX(a,b) (((a)>(b))?(a):(b))
Listing 4-32.Two examples of function-like macros

```

分别。`MAX`比较两个值并分别返回较小和较大的值。这种宏被称为类函数宏。虽然这些宏看起来很像函数，但它们不是。C 预处理器只是用相关的代码片段替换名称(实际上，这是一个文本查找和替换操作)。

宏有潜在的危险。它们通常表现得不像预期的那样，并且可能具有不希望的副作用。例如，让我们假设您已经定义了这样一个宏:

```cpp
#define DANGEROUS 1024+1024

```

在你代码的某个地方，你写了这个:

```cpp
int value = DANGEROUS * 2;

```

可能有人期望变量`value`包含 4096，但实际上应该是 3072。记住数学运算的顺序，它告诉我们从左到右，除法和乘法应该先发生。

另一个因使用宏而产生意外副作用的例子是以如下方式使用“MAX ”:

```cpp
int maximum = MAX(12, value++);

```

预处理器将生成以下内容:

```cpp
int maximum = (((12)>(value++))?(12):(value++));

```

现在很容易看出，`value`上的后增量操作将执行两次。这肯定不是编写上述代码的开发人员的意图。

不要再用宏了！至少从 C++11 开始，它们几乎已经过时了。除了极少数例外，宏不再是必需的，也不应该在现代 C++ 程序中使用。也许引入所谓的反射(即程序可以在运行时检查、自省和修改自己的结构和行为的能力)作为未来 C++ 标准的一部分，可以帮助完全摆脱宏。但是在时机到来之前，宏目前仍然需要用于一些特殊的目的，例如，当使用单元测试或日志框架时。

不要使用类似对象的宏，而是使用常量表达式来定义常量:

```cpp
constexpr int HARMLESS = 1024 + 1024;

```

代替类似函数的宏，简单地使用真正的函数，例如在标题`<algorithm>`中定义的函数模板`std::min`或`std::max`(参见下一章中关于`<algorithm>`标题的部分):

```cpp
#include <algorithm>
// ...

int maximum = std::max(12, value++);

```