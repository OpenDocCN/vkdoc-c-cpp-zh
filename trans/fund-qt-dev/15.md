## 第十五章

建设 Qt 项目

他的书依靠 QMake 通过使用标准的项目文件来构建示例应用程序，而没有使用任何高级特性。然而，QMake 也可以用于管理高级项目和处理产生多个可执行文件、库和插件的项目。本章介绍了当您想要创建更复杂的 Qt 项目时，您将需要的一些最常见的特性。

您还将了解到 Qmake 的一个很好的替代品:Kitware 的 CMake ( `[http://www.cmake.org/](http://www.cmake.org/)`)。和 QMake 一样，CMake 也是一个开源的跨平台构建系统。值得讨论 CMake，因为它被作为 Qt 最著名的用户之一，KDE 项目(`[http://www.kde.org/](http://www.kde.org/)`)的构建工具。

### QMake

QMake 是 Qt 附带的构建工具。它是通用的，可以用于在 Qt 支持的所有平台上构建大多数项目。它用于从项目文件生成构建环境。它还可以为 Visual Studio 和 Xcode 创建 Makefiles 和项目文件。

#### QMake 项目文件

要开始使用 QMake，让它通过执行以下命令为自己创建一个项目文件:

```cpp
qmake -project
QMake 将在当前目录和子目录中查找它所识别的文件，然后将它们添加到一个标准化的项目中以构建一个应用程序。

**注意**你应该只在创建新项目的时候使用`-project`选项。向现有项目添加文件时，您需要手动将它们添加到项目文件中；否则，您将丢失对项目文件所做的任何更改。

清单 15-1 显示了一个由 QMake 生成的项目文件。如您所见，以`cpp`、`h`和`ui`结尾的文件已经被识别。QMake 可以识别大多数在基于 Qt 的软件项目中使用的文件结尾，但是这三个是这个项目中唯一可用的文件扩展名。
让我们从最上面开始，详细地看一下项目文件。首先要注意的是，注释以一个散列字符(`#`)开始，它将该行的其余部分标记为注释。第一个未注释的行(不算空行)读`TEMPLATE = app`；它将变量`TEMPLATE`设置为`app`。现在`TEMPLATE`有了一个特殊的含义，因为它的值被用来决定你试图构建的项目的类型— `app`意味着你正在构建一个应用程序。(本章稍后将介绍其他模板选项。)
在分别设置`TARGET`、`DEPENDPATH`和`INCLUDEPATH`的`TEMPLATE`线之后有三条线。将`TARGET`设置为 nothing 意味着生成的可执行文件将以项目文件命名。例如，如果项目文件被命名为`superapp.pro`，那么生成的可执行文件将被命名为`superapp`(或者在 Windows 上被命名为`superapp.exe`)。如果你给`TARGET`指定一个名字而不是什么都没有，那么这个名字将代替项目文件的名字。
另外两个变量`DEPENDPATH`和`INCLUDEPATH`被设置为。，所以 QMake 知道您将项目的文件保存在当前目录中。两者的区别在于，QMake 在映射项目中的依赖关系时使用`DEPENDPATH`，而`INCLUDEPATH`被传递给编译器，告诉它在哪里寻找包含的文件。可以为这些变量添加更多的路径——只需用空格将它们隔开。

**注意**目录。(点号)指当前目录，正如目录..(两点)指包含当前目录的目录。

在指定了模板、选择了生成的可执行文件的名称并通知 QMake 头文件保存在哪里之后，就该告诉它编译什么了。这样做需要三个变量:`SOURCES`、`HEADERS`和`FORMS`。
`SOURCES`用于保存以`cpp`、`cc`或`cxx`结尾的源文件，具体取决于您的个人喜好。`HEADERS`用于头文件:`h`、`hpp`或`hxx`。最后，`FORMS`用于设计器表单:`ui`。

**清单 15-1。** *一个自动生成的项目文件*
######################################################################

# Automatically generated by qmake (2.01a) må 19\. mar 18:20:02 2007

######################################################################

TEMPLATE = app

TARGET =

DEPENDPATH += .

INCLUDEPATH += .

# Input

HEADERS += mainwindow.h otherdialog.h preferencedialog.h

FORMS += otherdialog.ui preferencedialog.ui

SOURCES += main.cpp mainwindow.cpp otherdialog.cpp preferencedialog.cpp 
在项目文件中，使用了两个不同的赋值操作符:`=`和`+=`。第一个，`=`，替换现有值；后者，`+=`，增加了更多的现有价值。为了理解结果，你需要知道 QMake 是什么变量。
QMake 变量是字符串列表，可以放在一行中，用空格分开，或者分成不同的赋值。下面一行:
SOURCES += main.cpp dialog.cpp mainwindow.cpp
相当于这样:
SOURCES += main.cpp

SOURCES += dialog.cpp    \

           mainwindow.cpp
请注意，该赋值使用了`\`字符分布在两行上。通过用反斜杠结束一行，换行符被视为空白，并且该行被视为继续。
如果你反复使用`+=`，然后不小心使用了`=`，你很可能会碰到一些看起来很奇怪的 bug。因为`=`操作符替换了变量的内容，所有先前的值都将丢失。奇怪行为的另一个来源可能是当重复使用`+=`并且两次意外添加相同的值时。为了避免这种情况，您可以使用`*=`操作符，该操作符向变量添加一个值，但前提是该值不存在。
还有另一个操作符可以用来控制 QMake 变量的内容:`-=`。这个操作符从列表中删除值，当您想要从 Qt 中删除一个默认选项时可以使用它。例如，下面一行从生成项目中移除用户界面模块:
QT -= gui
您必须移除该模块，因为默认情况下它是`QT`变量的一部分。
**更多项目文件选项**
清单 15-1 中自动生成的项目文件中使用的变量不是唯一可用的变量。实际上，QMake 使用了 100 多个变量——太多了，本文无法一一介绍。这里列出了最有用的，而不是全部:

```

*   `DEFINES`:该变量包含将用于配置项目的预处理器定义。有许多定义可以用来微调最终的 Qt 应用程序。例如，`QT_NO_DEBUG_OUTPUT`用于关闭`qDebug`消息，`QT_DEBUG_PLUGINS`用于打开关于插件加载的调试信息。这些定义被传递给编译器，因此您可以在代码中使用它们。
*   `LIBS`:使用该变量链接库。使用`-L` `path`命令将路径添加到目录列表中，以搜索库。然后使用`-l` `library`(破折号，小写 L，库名)添加对实际库的引用。为了链接库`/home/e8johan/mylib/libthelibrary.a`，项目文件行应该是`LIBS += -L/home/e8johan/mylib –lthelibrary`。QMake 负责将这些标志(`-L`和`-l`)转换成当前使用的编译器。
*   `DESTDIR`:如果需要控制结果文件的最终位置，可以使用这个变量。例如，通过将它设置为`../bin`，结果文件将被放置在与包含项目文件的目录相同的目录级别上的`bin`目录中。

当您构建一个 Qt 应用程序时，您最终会得到许多中间文件。设计器用户界面由用户界面编译器编译成头文件，头文件由元对象编译器编译成 C++ 源文件，所有 C++ 源文件都编译成目标文件。将这些文件与源文件和头文件放在同一个目录中会导致混乱的局面。当然，运行`make clean`将会清除它，但是您可以使用以下变量做得更好:

*   `OBJECTS_DIR`:控制中间目标文件的放置位置。
*   `UI_DIR:`控制用户界面编译器生成的中间文件的位置。
*   `MOC_DIR`:控制元对象编译器生成的中间文件放在哪里。

一个好的策略是将目标文件放在`./obj`中，将`uic`文件放在`./ui`中，将`moc`文件放在`./moc`目录中，方法是在项目文件中添加以下几行:

`OBJECTS_DIR = obj
UI_DIR = ui
MOC_DIR = moc`

* * *

**注意**添加完这些行之后，QMake 将尝试自动创建目录。在 Unix 平台上，通常使用目录`.obj`、`.ui`和`.moc`，因为它们在默认情况下是隐藏的。

* * *

**使用 QMake 管理资源**

当将资源嵌入到可执行文件中时，创建一个从项目文件中引用的资源文件。资源可以是图标、翻译或应用程序使用的任何其他文件。(参考[第 4 章](04.html#the_main_window)了解更多关于资源文件格式的信息。)

* * *

**注意**这里说的资源是 Qt 资源，不是 Windows 资源。

* * *

资源文件通常具有文件扩展名`qrc`。它们被添加到项目文件的`RESOURCES`变量中，这使得资源编译器`rcc`将指定的资源编译成一个中间 C++ 源文件。您可以通过使用`RCC_DIR`变量来控制这些中间文件的位置。

**配置 Qt**

在构建过程中，有几种方法可以配置 Qt。例如，您可以控制包含 Qt 的哪些部分以及这些部分的行为方式，这使您能够构建只使用 Qt 中所需部分的应用程序，从而减少可执行文件和内存占用。在对`DEFINES`变量的讨论中，您已经看到了一些可以用来做这件事的定义，但是您将在本节中看到更多。

控制包含 Qt 的哪些部分的两个主要变量是`QT`和`CONFIG`。`QT`控制项目中包含的模块。默认包括`core`和`gui`。以下模块可用(取决于您使用的 Qt 版本):

*   `core`:核心模块
*   `gui`:用户界面模块`QtGui`，用于所有具有图形用户界面的应用程序
*   `network`:模块`QtNetwork`，用于[第 14 章](14.html#networking)
*   `opengl`:模块`QtOpenGL`，用于[第七章](07.html#drawing_and_printing)
*   `sql`:模块`QtSql`，用于[第十三章](13.html#databases)
*   `svg`:模块`QtSvg`，用于[第七章](07.html#drawing_and_printing)
*   `xml`:模块`QtXml`，用于[第八章](08.html#files_comma_streams_comma_and_xml)
*   `qt3support`:`Qt3Support`模块，用于使 Qt 3 应用程序移植到 Qt 4 更加容易

第二个主要变量是`CONFIG`变量，默认情况下通常以合理的方式设置。最常用的值如下:

*   `thread`:如果包含的话，应用程序是支持多线程的。
*   如果包含的话，Windows 应用程序将有一个控制台。例如，该控制台用于显示`qDebug`消息。
*   `release`:以发布模式构建项目。
*   `debug`:在调试模式下构建项目。
*   `debug_and_release`:在发布和调试模式下构建项目。
*   `plugin`:构建一个插件。
*   `dll`:构建一个动态链接库，也称为共享对象。
*   `qttestlib`:为构建单元测试添加 Qt 支持库。

**构建一个 QMake 项目**

为 Qt 项目创建项目文件后，需要运行 QMake 来创建适当的 Makefile 或项目。最简单的方法是在与项目文件相同的目录下，在命令行界面中键入`qmake`。它将使用平台默认值来生成一个合适的 Makefile。

你也可以使用 QMake 为 Visual Studio 生成一个项目文件。只需运行`qmake -t vcapp`来生成这样一个文件(用`vclib`替换`vcapp`来构建一个库项目)。要为 Xcode 生成一个项目文件，运行`qmake -spec macx-xcode`。

您还可以在 QMake 调用中添加项目文件行。例如，`qmake "CONFIG+=console"`相当于将行`CONFIG+=console`添加到您的项目文件中。

如果您选择使用 QMake 创建 Makefile，那么您可以使用一个简单的`make`命令来构建您的项目(如果您使用的是 Visual Studio，那么可以使用`nmake`)。你可以使用`make clean`清理你的中间文件。稍微残酷一点的步骤是运行`make distclean`，它清理所有生成的文件，包括 Makefile。您必须再次运行 QMake 来获得`make`的 Makefile。

#### 使用不同的平台

在使用平台无关的工具包(比如 Qt)时，您可能希望能够处理平台细节，这有很多原因。例如，您可能希望在不同的平台上使用不同的图标，或者拥有一段依赖于平台的自定义源代码。根据所使用的平台，QMake 使得以稍微不同的方式构建项目变得容易。

不同的平台使用一个叫做*作用域*的概念来处理。Qt 支持很多作用域，但最常见的是:

*   `debug`:项目正在调试模式下构建。
*   `release`:项目正在以发布模式构建。
*   这个项目是在 Windows 环境下构建的。
*   这个项目是在 Mac OS X 环境下构建的。
*   `unix`(包括 Linux):项目正在 Unix 环境中构建。

您可以用两种不同的方式处理作用域。你可以使用括号，如图所示，在这里选择`if-else`结构库:

`win32 {
  LIBS += -lmywin32lib
} else macx {
  LIBS += -lmymacxlib
} else {
  LIBS += -lmyunixlib
}`

您可以使用:运算符组合作用域；比如`macx:debug: ..`。相当于写`macx { debug {`...`} }`。运算符带来了指定范围的另一种方法。您可以这样设置`LIBS`变量:

`win32:LIBS += -lmywin32lib
macx:LIBS += -lmymacxlib
!win32:!macx:LIBS += -lmyunixlib`

注意到`!`操作符被用来反转作用域。`!win32:!macx`的意思不是`win32`也不是`macx`。

**Windows 特有的功能**

如果您希望能够显示调试输出，您可以将值`console`添加到`CONFIG`变量中。更微妙的方法是限制对 Windows 和调试模式应用程序的更改:

`win32:debug:CONFIG += console`

它确保您不会为以发布模式构建的应用程序打开控制台窗口。

为 Windows 平台构建应用程序时需要注意的另一个问题是应用程序图标(Explorer 在显示可执行文件时使用的图标)。

* * *

**提示**你使用`setWindowIcon`方法来设置应用程序窗口的图标。

* * *

Windows 上的应用程序图标由一个 Windows 资源表示(不要与 Qt 资源混淆)，所以您必须创建一个 Windows 资源文件，并将其添加到 Qt 项目文件中。首先你需要创建一个文件格式为`ico`的图标。有许多工具可以创建这些文件(例如 Gimp 和 Visual Studio 中的图标编辑器，但是搜索互联网会发现许多替代工具)。

创建图标后，您需要创建 Windows 资源文件，这是一个文件扩展名为`rc`的文件。该文件应包含以下行。

`IDI_ICON1 ICON DISCARDABLE "filename.ico"`

用你的图标替换`filename.ico`。要将资源文件添加到项目文件中，只需添加一行代码`RC_FILE += filename.rc`，其中`filename.rc`是您的 Windows 资源文件。没有必要给这一行加上前缀`win32` scope，因为在它不适用的平台上它会被忽略。

**OS X 特有的特征**

Mac OS X 和 Qt 支持的其他平台之间的最大区别是能够在几个处理器平台上运行相同的应用程序。可用的处理器 PowerPC 和 Intel x86 有许多不同之处——最麻烦的是字节序。确保总是使用 Qt 流来加载和存储数据——不仅是文件，还有数据库、网络流和其他可以被两个处理器读写的缓冲区。该问题存在于多字节值的字节顺序中。例如，如果您不决定坚持哪种字节序，一个平台上的 32 位整数读数`0x12345678`在另一个平台上会被读作`0x78563412`。

在 Mac OS X 平台上配置 Qt 时，可以使用`-universal`标志，这使得创建通用二进制文件成为可能。您可以使用`CONFIG`变量以及`ppc`和`x86`值来控制支持哪些处理器。键入`CONFIG += x86 ppc`创建一个通用项目，可以在任一平台上执行。

与 Windows 应用程序一样，OS X 应用程序也有应用程序图标。Mac 平台上使用的文件格式是`icns`。您可以使用几个工具创建`icns`文件(在互联网上搜索例子)。Apple 提供了图标编辑器，这是推荐使用的工具。在您创建了一个`icns`文件之后，您需要使用一行代码`ICON =` `filename.icns`将它添加到您的项目文件中，其中`filename.icns`是您的图标文件。

**特定于 Unix 和 X11 的特性**

在 Unix 系统上构建和部署通常比在 Windows 上更困难，因为 Unix 有很多种。对于每一种风格，都有几种不同的桌面环境。(桌面环境是用户看到和使用的，可以处理开始菜单、停靠、窗口样式等等。)处理所有这些组合意味着做事有几种方式，做正确的事情有许多变体。

另一个需要解决的问题是，Qt 库可能已经安装在您的目标系统上。您需要找出什么版本和在哪里，这至少可以通过两种方式来实现。一种方法是将您的应用程序静态链接到 Qt，这意味着如果 Trolltech 决定发布您的 Qt 版本的更新，将会有更大的可执行文件并且没有自动更新。

另一个选项仅适用于 Linux 系统。您可以要求系统支持 Linux 标准库(LSB ),因为 Qt 4.1 作为可选的 LSB 模块提供。请访问`[http://www.linuxstandardbase.org](http://www.linuxstandardbase.org)`了解更多信息。

现在简单看一下，在正确安装 Qt 应用程序后，如何将它集成到当前的桌面环境中。

* * *

**提示**欲了解更多信息，请访问`[http://www.freedesktop.org](http://www.freedesktop.org)`。

* * *

让我们看看应用程序图标是如何设置的。Unix 二进制不知道图标的概念资源。相反，桌面条目文件用于描述每个应用程序。这些文件的文件扩展名为`desktop`，通常存储在`$XDG_DATA_DIRS/applications`或`/usr/share/applications`中。清单 15-2 中的[显示了一个示例文件。](#an_example_desktop_file_for_the_myapplic)

**清单 15-2。***my application 项目的示例桌面文件*

`[Desktop Entry]
Type=Application
Name=My Application
Exec=myapplication %F
MimeType=image/x-mydata;
Icon=/install/path/myicon.png`

在清单中，`[Desktop Entry]`这一行告诉您接下来是一个桌面条目。接下来是`Type`，它告诉你条目将描述一个应用。根据`Name`的说法，这个应用程序叫做`My Application`。`Exec`行告诉桌面发出什么命令来启动应用程序；这种情况下就是`myapplication`。如果用户试图打开一个或多个数据文件，那么`%F`部分告诉桌面在哪里列出文件名。使用定义 mime 类型的`MimeType`条目来处理这些数据文件和应用程序之间的连接；即应用程序处理的文件类型。

最后一行`Icon`，告诉你使用哪个图标。最简单的方法是指定图标的绝对路径。如果仅指定文件名，则必须确定存储图标文件的位置，以便桌面环境可以找到它。

在 Unix 上安装应用程序时，通常支持 make target `install`，这使用户能够键入`make install`将应用程序文件复制到一个全局位置。QMake 使用安装集支持这一点。

一个*安装集*是一个带有三个子值的 QMake 变量:`path`、`files`和`extra`。我们来看一个例子。假设您想要安装一组插件，它们位于与项目文件相关的子目录`plugins`中。当应用程序安装完成后，您希望这些文件位于`/usr/local/myapplication/plugins`中。如下指定，其中最后一行将插件安装集添加到 install make 目标:

`plugins.files = plugins/*
plugins.path = /usr/local/myapplication/plugins
INSTALLS += plugins`

您还希望在一个名为`plugins.lst`的文件中有一个插件列表，这就是`extra`子值的用途。它使您能够指定在复制文件之前要运行的命令列表。通过添加下面一行，在插件被复制到适当位置之前创建了该列表:

`plugins.extra = rm -f ./plugins/plugins.lst; ls −1 ./plugins > ./plugins/plugins.lst`

这一行由一个`rm`命令组成，该命令删除任何现有的`plugins.lst`文件，因为如果存在的话，该列表将包含在插件列表中。然后执行一个`ls`命令，构建一个新的列表，通过管道传输到`plugins.lst`文件中。

有一个特殊的安装集，代表 QMake figures 想要复制的文件:`target`。通过指定一个路径并将其添加到`INSTALLS`，QMake 负责剩下的工作:

`target.path = /usr/local/myapplication
INSTALLS += target`

因为可以在所有平台上使用 make 作为构建系统，所以建议使用平台范围来保护安装集(特别是，`extra`值中列出的命令需要适应不同的平台)。

#### 使用 QMake 构建库

到目前为止，您一直在处理构建应用程序的项目。QMake 也可以用于构建库，包括静态库、动态库和插件(一种特殊的动态库)。要让 QMake 做到这一点，您必须将`TEMPLATE`变量改为`lib`。

一个图书馆项目的例子显示在[清单 15-3](#a_project_file_for_building_a_library) 中。该项目使用`SOURCES`和`HEADERS`变量的方式与构建应用程序时相同。合并`TARGET`和`VERSION`来创建结果库的文件名，这是避免版本问题的常用方法。因为不同版本的库有不同的名称，所以问题得以避免。

* * *

**注意**使用`VERSION`意味着你的库的名字会被修改。不要让这个迷惑你。

* * *

`CONFIG`变量用于控制正在构建的库的类型。通过添加值`dll`来构建动态库。其他可能的值有`staticlib`，它构建一个静态库，还有`plugin`，它用于构建插件。注意，添加值`plugin`也隐含地添加了值`dll`，因为插件是一个动态库。

**清单 15-3。** *一个建库的项目文件*

`TEMPLATE = lib
TARGET = mylib
VERSION = 1.0.0
CONFIG += dll

HEADERS += mylib.h
SOURCES += mylib.cpp`

用于库的文件扩展名在不同的平台和编译器之间是不同的(这都是由 QMake 处理的)。例如，永远不要给`TARGET`变量指定文件扩展名；让 QMake 来处理它。

#### 使用 QMake 构建复杂的项目

通常，构建一个库或一个应用程序就足够了，但有时您的项目由几个部分组成，从而产生几个库和几个应用程序。QMake 也足够强大来处理这些情况。让我们看看它会是什么样子。

这里显示的项目由一个库和一个应用程序组成。库叫`base`，应用叫`app`。项目文件的结构如[清单 15-4](#the_files_and_directories_of_the_complex) 所示。主项目文件`complex.pro`位于基础层，还有目录`bin`、`lib`、`app`、`include`和`src`。`bin`和`lib`目录为空。

`app`目录包含应用程序的源代码和项目文件。`include`目录包含库的头文件；也就是说，库和应用程序之间共享的头文件。`src`目录包含库的源代码和项目文件。

两个空目录`lib`和`bin`，分别用于从`src`的内容构建的库和从`app`生成的应用程序二进制文件。

* * *

**注意**因为`lib`和`bin`目录仅用于保存构建的文件，所以您可以省略它们；QMake 会在被要求放置文件时创建它们。

* * *

**清单 15-4。** *复杂项目的文件和目录*

`|   complex.pro
|
+---bin
+---lib
|
+---app
|   |   app.pro
|   |   appwindow.cpp
|   |   appwindow.h
|   |   main.cpp
|
+---include
|       base.h
|
\---src
    |   base.cpp
    |   src.pro`

主项目文件`complex.pro`如[清单 15-5](#the_complex.pro_project_file) 所示。它用的是`TEMPLATE`，对你来说是新的。`subdirs`模板用于处理放置在不同子目录下的多个项目文件。需要注意的目录在`SUBDIRS`变量中列出。`CONFIG`值`ordered`告诉 QMake 按照它们被添加到`SUBDIRS`变量的顺序构建不同目录的项目。如果未指定，则构建顺序未定义。

**清单 15-5。***complex . pro 项目文件*

`TEMPLATE = subdirs
SUBDIRS = src app
CONFIG += ordered`

整个文件告诉 QMake 首先在`src`目录中构建项目，然后在`app`目录中构建项目。让我们继续跟随 QMake 到`src`目录。

在`src`目录中，QMake 找到了`src.pro`项目文件(参见[清单 15-6](#the_src.pro_project_file_for_building_a) )。根据项目文件所在的目录来命名项目文件是一种常见的策略。如果你在一个目录中运行`qmake -project`，就会发生这种情况，但是你也可以手动创建项目文件。

`src`目录中文件的目的是构建一个应用程序使用的库；也就是`app`目录的内容。库的源代码保存在`src`，头文件保存在`include`，结果库放在`lib`。头文件保存在`include`中，因为它们在复杂项目的所有部分之间共享，而`include`目录包含了按照惯例所有部分共有的头文件。

项目文件的第一部分告诉 QMake 使用`TEMPLATE`变量创建一个库。然后使用`TARGET`指定库的名称，使用`VERSION`指定版本，并设置`CONFIG`以便创建一个静态库。

这个库打算在`lib`目录中结束，所以`DESTDIR`变量被设置为`../lib`，这是到那个目录的相对路径。

项目的头文件存储在项目全局包含目录中。您必须将该路径添加到`INCLUDEPATH`和`DEPENDPATH`变量中。项目的源文件和项目文件存储在同一个目录中，所以`DEPENDPATH`也包含了对`.`目录的引用。

设置好包含文件和项目文件的路径后，列出`SOURCES`和`HEADERS`。因为包含头文件的目录包含在`DEPENDPATH`变量中，所以不必给它添加相对路径；QMake 无论如何都会找到的。

**清单 15-6。** *用于构建库的 src.pro 项目文件*

`TARGET = base
VERSION = 0.1.0
CONFIG += static

DESTDIR = ../lib

INCLUDEPATH += ../include
DEPENDPATH += . ../include

SOURCES += base.cpp
HEADERS += base.h`

在 QMake 访问了`src`目录后，它将继续访问`app`目录和`app.pro`项目文件。这个项目的目的是创建一个使用从`src`项目构建的库的应用程序。

`app.pro`项目文件如[清单 15-7](#the_app.pro_project_file_for_building_th) 所示。正如所料，它首先将`TEMPLATE`设置为`app`，表明您正在构建一个应用程序。然后，通过将`TARGET`设置为`app`并将`DESTDIR`设置为`../bin`，文件继续。这告诉 QMake 创建一个名为`app`(在 Windows 上为`app.exe`)的应用程序二进制文件，并将其放在`bin`目录中。

下一组线设置了`INCLUDEPATH`和`DEPENDPATH`。包含路径被设置为同时包含`.`和`../include`，因为应用程序使用位于`.`目录中的应用程序本地头文件和位于`include`目录中的复杂项目部分全局头文件。注意，全局头文件属于库项目，所以它们不包含在`DEPENDPATH`中。

接下来是`LIBS`行，这是由`src.pro`项目文件创建的库链接到这个项目的地方。第一个值`-L../lib`告诉 QMake 库存储在`lib`目录中。下一个值`-lbase`，告诉 QMake 将应用程序链接到`base`库。

项目文件的最后是源文件和头文件的列表。这些是应用程序项目的本地源文件。

**清单 15-7。***`app.pro`项目立项申请*

`TEMPLATE = app
TARGET = app
DESTDIR = ../bin
INCLUDEPATH += . ../include
DEPENDPATH += .

LIBS += -L../lib -lbase

SOURCES += appwindow.cpp main.cpp
HEADERS += appwindow.h`

要构建这个项目，使用命令行 shell 转到包含`complex.pro`的目录。从这里运行`qmake`会创建一个顶级的`Makefile`。奔跑中的`make`现在将依次造访`src`和`app`。当访问每个子目录时，从本地项目文件创建一个`Makefile`，然后运行`make`来构建每个子项目。

结果是先建库；然后是申请。结果文件将被放在预期的位置:在`bin`和`lib`目录中。

### CMake 构建系统

CMake 构建系统(`[http://www.cmake.org](http://www.cmake.org)`)是一个通用的构建系统。它并不专注于构建 Qt 应用程序；它专注于构建任何类型的应用程序。Qt 开发人员对此很感兴趣，因为 KDE 项目选择在 KDE 4 平台上使用 CMake。通用构建系统的缺点是使用 CMake 可能比使用 QMake 涉及的工作量稍多。然而，这并不意味着很难使用 CMake。该工具对 Qt 和 KDE 都有很好的支持。

虽然 CMake 和 QMake 都可以执行任何任务，但是 QMake 稍微偏向于 Qt 应用程序(尽管它在其他项目中也很有用)。另一方面，CMake 有一个 QMake 没有的特性:在源代码构建之外执行*的能力，因此构建过程——及其所有中间文件——可以保存在源代码树之外。当您使用 CVS 或 Subversion 这样的版本控制系统时，这个特性非常方便。因为构建过程不把它的中间文件放在项目的源代码树中，所以它可以与所有不受版本控制的文件保持清洁。这大大降低了意外向源存储库添加中间文件的风险。*

* * *

**注意**本文假设您使用的是最新版本的 CMake(至少是版本 2.4)。

* * *

#### 使用 QMake 管理简单的应用程序

让我们从使用清单 15-1 中的 QMake 项目文件构建的同一个项目开始。它包括对源文件、头文件和用户界面文件的引用，以及控制 QMake 将产生什么和如何产生的配置(见[清单 15-8](#a_cmake_project_file_for_a_basic_qt_appl) )。

所有的 CMake 项目都在一个名为`CMakeLists.txt`的文件中描述，这个文件对应于 QMake 使用的项目文件。每个 CMake 文件都是基于一个项目的，所以文件从使用`PROJECT`命令将项目名设置为`basics`开始。

您可以通过`SET`命令设置变量`basics_SOURCES`、`basics_HEADERS`和`basics_FORMS`继续。这些变量像 QMake 变量一样工作；它们被设置为一个值列表。`SET`命令接受一个参数列表，其中第一个参数是要设置的变量的名称。以下参数是值。

变量名都以前缀`basics_`开头。(这个约定不是必须的，但是很方便。)同样的约定告诉您为源、头和表单创建变量。这对于任何使用过 QMake 的人来说都很熟悉——这就是我们的目的。

接下来的两行介绍了 CMake 对 Qt 4 的支持。首先，`FIND_PACKAGE`用于定位`Qt4`包。这个包被标记为`REQUIRED`，这意味着如果 Qt 4 不存在，构建将会停止。然后使用`INCLUDE`命令设置包含 Qt 头文件和库的目录。在`INCLUDE`命令中，使用了`${` `variable` }语法(指变量值)。

下一步是使用刚刚包含的命令。首先，让元对象编译器使用`QT4_WRAP_CPP`命令从头文件创建 C++ 源文件。第一个参数是一个变量名，它包含元对象编译器创建的 C++ 源文件的名称。

当元对象编译完成后，就可以用`QT4_WRAP_UI`命令将用户界面编译成头文件了。这个命令就像`QT4_WRAP_CPP`命令一样工作，产生一个变量，该变量包含对生成的文件的引用。

当使用 CMake 构建软件时，了解如何处理外部源代码是很重要的。源文件位于由`CMAKE_CURRENT_SOURCE_DIR`定位的源目录中，而中间文件和整个构建系统位于保存在`CMAKE_CURRENT_BINARY_DIR`中的二进制目录中。在源代码树内部构建时，这两个变量指向同一个目录；否则不会。

因为用户界面编译器生成的头文件是在编译时创建的，所以它们将位于二进制目录中。因为这些文件包含在位于源树中的源文件中，所以您必须在二进制目录和源树中查找包含文件。因此，使用`INCLUDE_DIRECTORIES`命令将`CMAKE_CURRENT_BINARY_DIR`添加到包含路径中。

在准备构建之前，您需要设置正确的预处理器定义来控制 Qt 库是如何构建的。Qt 定义保存在`QT_DEFINITIONS`变量中，该变量使用`ADD_DEFINITIONS`命令添加到构建环境中。

下一个命令`ADD_EXECUTABLE`，是在应用程序中生成结果的命令。它定义了一个名为`basics`的应用程序，这个应用程序是从源代码、元对象和用户界面头构建的。用户界面头不会被编译成任何东西，因为它们是头文件。但是，应用程序有必要引用它们，否则 CMake 会错过依赖它们的内容。如果可执行文件或库不直接或间接地依赖于构建系统的一部分，那么它就不会被构建。

在创建整个构建环境之前，您必须告诉 CMake 在项目文件的最后使用`TARGET_LINK_LIBRARIES`命令将应用程序链接到 Qt 库。先前在`INCLUDE`命令中导入了`QT_LIBRARIES`变量，它包含了该项目所需的所有库的引用。

**清单 15-8。** *一个基本 Qt 应用程序的 CMake 项目文件*

`PROJECT( basics )

SET( basics_SOURCES main.cpp mainwindow.cpp otherdialog.cpp preferencedialog.cpp )
SET( basics_HEADERS mainwindow.h otherdialog.h preferencedialog.h )
SET( basics_FORMS otherdialog.ui preferencedialog.ui )

FIND_PACKAGE( Qt4 REQUIRED )
INCLUDE( ${QT_USE_FILE} )

QT4_WRAP_CPP( basics_HEADERS_MOC ${basics_HEADERS} )
QT4_WRAP_UI( basics_FORMS_HEADERS ${basics_FORMS} )

INCLUDE_DIRECTORIES( ${CMAKE_CURRENT_BINARY_DIR} )

ADD_DEFINITIONS( ${QT_DEFINITIONS} )

ADD_EXECUTABLE( basics ${basics_SOURCES}
  ${basics_HEADERS_MOC} ${basics_FORMS_HEADERS} )
TARGET_LINK_LIBRARIES( basics ${QT_LIBRARIES} )`

**运行 CMake**

要构建清单 15-8 所示的项目文件，你需要理解 CMake 是如何执行的。在查看命令行选项之前，先看看 CMake 提供的特性。

您可以从源代码树运行 CMake，就像 QMake 一样，将中间文件和结果留在源代码树中。还可以从远程目录运行 CMake，从而得到一个干净的源代码树。这意味着中间文件和结果文件(如应用程序和库)不会出现在源代码树中。通过保持源代码树没有这些文件，您可以将整个源代码树始终置于版本控制之下。这意味着在将源代码添加到版本控制中时，您不必清除任何不需要的文件，并且可以避免将中间文件添加到您可能会意外使用的版本控制系统中的风险。

您还可以使用 CMake 为许多不同的构建系统创建项目。不同的系统使用不同的生成器。在 Linux 和 Mac OS X 上，默认的生成器通常是有效的。这个生成器针对 GCC 系统。在 Windows 上，可能需要指定要使用的生成器。如果你和 MinGW 一起使用 Qt 的开源版本，要使用的生成器是`MinGW Makefiles`。您可以使用`-G`命令行选项来实现这一点——稍后将详细介绍。其他受支持的构建系统包括各种 Microsoft 编译器、Borland、Watcom、MSYS 和通用 Unix Makefiles。

当运行 CMake 时，在您的`PATH`环境变量中准备好您计划使用的所有工具是很重要的，包括您的编译器和 Qt 工具(比如`uic`和`moc`)。这些工具通常在路径中；如果没有，CMake 会告诉你它找不到什么。

那么，你如何实际运行 CMake 呢？第一步是启动一个命令提示符，将您定向到您的项目目录(包含`CMakeLists.txt`文件的目录)。在这个目录中，您可以使用下面的代码行在源代码树中构建项目:

`cmake .`

在 Windows 上，您可能需要使用`-G`命令行选项告诉 CMake 使用 MinGW 进行构建。这将为您提供以下命令:

`cmake . -G "MinGW Makefiles"`

传递给 CMake 的`.`指的是当前目录。它告诉 CMake 这是源目录。如果您想在源代码之外构建，这就是您告诉 CMake 要构建什么的方式。让我们像以前一样从项目目录开始，但是现在在您创建的单独目录中构建:

`mkdir build
cd build
cmake ..`

有时，您可能必须将`-G "MinGW Makefiles"`添加到`cmake`命令中，才能让它正常工作。通过在源代码树之外进行构建，您可以看到 CMake 创建了哪些文件以及系统是如何工作的。

可能给您带来麻烦的一个中心文件是 CMake 生成的`CMakeCache.txt`。如果您想要更改生成器，您需要删除这个文件以让 CMake 重新生成构建系统。

CMake 还创建了一个`CMakeFiles`目录，其中包含许多在构建过程中创建的中间文件。但是，元对象编译器和用户界面编译器生成的文件不放在这里。相反，它们被放在生成它们的文件旁边，或者，如果在源代码之外构建，则放在构建目录中的相应位置。

**使用 CMake 管理资源**

资源和 Qt 资源编译器的处理方式与元对象编译器和用户界面编译器相同。这些步骤包括设置一个变量，通常命名为`project` `_RESOURCES`，它包含项目的资源文件的名称。这个变量对应于 QMake 项目中的`RESOURCES`变量。

这个变量然后被传递给宏`QT4_ADD_RESOURCES`，它作为宏`QT4_WRAP_CPP`和`QT4_WRAP_UI`工作。这意味着最左边的参数是一个变量，用来保存其余参数的结果。结果变量一般命名为`project``_RESOURCES_SOURCES`；然后将其添加到`ADD_EXECUTABLE`命令的可执行文件中。

下面的列表显示了取自一个虚构项目的相关行:

`SET( foo_RESOURCES foo.qrc )
QT4_ADD_RESOURCES( foo_RESOURCES_SOURCES ${foo_RESOURCES} )

...

ADD_EXECUTABLE( foo ... ${foo_RESOURCES_SOURCES } ... )`

**配置 Qt 模块**

因为 Qt 由许多模块组成，所以能够控制使用哪些 Qt 模块是很重要的。你可以通过使用一系列的`QT_USE_QT` `module`和`QT_DONT_USE_QT` `module`变量来实现。在调用`FIND_PACKAGE`定位`Qt4`包之前，将这些变量设置为`TRUE`(使用`SET`命令)。这使得链接中使用的`QT_LIBRARIES`变量包含了对所需模块的引用。

包括和排除模块的一些可用变量如下所示:

*   `QT_DONT_USE_QTCORE`:不要链接到`QtCore`模块。这个变量几乎从来不用。
*   `QT_DONT_USE_QTGUI`:不要链接到`QtGui`模块。
*   `QT_USE_QT3SUPPORT`:链接到`Qt3Support`模块——用于帮助将 Qt 3 应用移植到 Qt 4。
*   `QT_USE_QTASSISTANT`:联动过程中包含助手模块。
*   `QT_USE_QTDESIGNER`:在联动过程中包含设计器模块。
*   `QT_USE_QTNETWORK`:联动过程中包含`QtNetwork`模块。
*   `QT_USE_QTOPENGL`:联动过程中包含`QtOpenGL`模块。
*   `QT_USE_QTSQL`:联动过程中包含`QtSql`模块。
*   `QT_USE_QTXML`:联动过程中包含`QtXml`模块。

* * *

**注意**使用`Qt3Support`模块时，间接链接到`QtNetwork`、`QtSql`和`QtXml`模块。在某些平台上，有必要明确指定您正在使用这些模块。

* * *

#### 使用不同的平台

使用 CMake 时，您会遇到与使用 QMake 时相同的特定于平台的问题。为了区分平台，有许多变量被设置为`true`，这取决于当前的 make 环境。最常见的列举如下:

*   `WIN32` : `true`如果建筑在窗户上
*   `APPLE` : `true`如果建在 OS X
*   `UNIX` : `true`如果构建在类似 Unix 的环境中，包括 OS X 和 Linux
*   `MINGW` : `true`如果使用 MinGW 编译器构建
*   `MSYS` : `true`如果在 MSYS 环境中构建
*   `MSVC` : `true`如果使用微软编译器构建

要测试变量，使用`IF( var )`...`ELSE( var )`...`ENDIF( var )`建造。如果在 Windows 上使用 MinGW 作为构建环境，你可以使用[清单 15-9](#differentiating_between_the_available_pl) 中的语句来区分平台:Windows、OS X 和 Unix/X11。只需用每个系统的平台细节替换注释行。

* * *

**注意** CMake 认为一个`#`字符右边的所有文本都是注释。

* * *

**清单 15-9。** *区分可用平台*

`IF( MINGW )
  # Windows, MinGW specifics here (i.e. Qt open source on Windows)
ELSE( MINGW )
  IF( APPLE )
    # OS X specifics here
  ELSE( APPLE )
    # Linux / Unix specifics here
  ENDIF( APPLE )
ENDIF( MINGW )`

QMake 和 CMake 在平台细节方面的差异只影响您解决给定问题的方式。要解决的问题还是一样的。

当使用这里介绍的解决方案时，您需要确保添加了前面显示的适当的`IF`命令。

**Windows 特有的功能**

在 Windows 中构建图形应用程序时，能够控制是否显示控制台非常重要。这与将`console`添加到 QMake 项目的`CONFIG`变量中所解决的问题相同。

* * *

**注意**这里介绍的特定于 Windows 的解决方案可以与 MinGW 编译器一起使用，后者是开源版 Qt for Windows 附带的编译器。如果您使用另一个编译器，您将不得不修改该编译器的解决方案。

* * *

控制控制台可用性的方法是在链接时在`windows`和`console`子系统选项之间切换。将下面一行添加到您的`CMakeLists.txt`文件将给您一个没有控制台输出的应用程序:

`SET( LINK_FLAGS -Wl,-subsystem,windows )`

相反，使用控制台运行的应用程序是通过以下代码行实现的:

`SET( LINK_FLAGS -Wl,-subsystem,console )`

您还必须修改您的`TARGET_LINK_LIBRARIES`调用，以包含`LINK_FLAGS`变量，这将为您提供如下代码行:

`TARGET_LINK_LIBRARIES( `project` ${QT_LIBRARIES} ${LINK_FLAGS} )`

另一个需要解决的问题是应用程序图标。设置应用程序图标的实际操作是使用特殊的编译器从给定的 Windows 资源文件创建一个目标文件。下面的清单显示了 Windows 资源文件`appicon.rc`是如何编译成`appicon.o`的。然后，该文件被添加到项目源代码中，以便以后包含在实际的二进制文件中。

`ADD_CUSTOM_COMMAND(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/appicon.o
  COMMAND windres.exe
    -I${CMAKE_CURRENT_SOURCE_DIR}
    -i${CMAKE_CURRENT_SOURCE_DIR}/appicon.rc
    -o ${CMAKE_CURRENT_BINARY_DIR}/appicon.o )

SET(project_SOURCES ${project_SOURCES} ${CMAKE_CURRENT_BINARY_DIR}/appicon.o)`

* * *

**注意**CMake 命令可以分成几行，这就是为什么定制命令看起来很奇怪。

* * *

`ADD_CUSTOM_COMMAND`用于将定制构建方法插入到 CMake 生成的 Makefile 中。它由`OUTPUT`部分组成，列出了定制步骤生成的文件。在前面的清单中，输出是`appicon.o`文件。第二部分是`COMMAND`部分，指定要运行的实际命令。清单运行`windres.exe`文件，将`-I`、`-i`和`-o`命令行选项传递给它。

**OS X 特有的特征**

OS X 有一些特性，包括能够为 PowerPC 和 x86 平台使用相同的可执行二进制文件——一个通用的二进制文件。要创建这样的可执行文件，使用`CMAKE_OSX_ARCHITECTURES`变量并将其设置为`ppc;i386`:

`SET( CMAKE_OSX_ARCHITECTURES ppc;i386 )`

* * *

**注意**保持`ppc;i386`值一致很重要。不要添加空格。

* * *

要使用 CMake 设置应用程序图标，需要构建一个应用程序包，这并不像看起来那么难(CMake 处理大部分细节)。你所要做的就是设置一些值，然后在最后的构建阶段做一些调整。这些变量如下:

*   `MACOSX_BUNDLE_ICON_FILE`:要使用的图标文件(以`icns`文件格式)。
*   `MACOSX_BUNDLE_BUNDLE_NAME`:捆绑包的名称。
*   `MACOSX_BUNDLE_COPYRIGHT`:版权信息。
*   `MACOSX_BUNDLE_INFO_STRING`:信息字符串。
*   `MACOSX_BUNDLE_GUI_IDENTIFIER`:作为 Java 风格包名的唯一标识符。这意味着看起来像一个颠倒的 web 服务器名称，例如，`se.thelins.exampleApplication`就是这样一个字符串。
*   `MACOSX_BUNDLE_BUNDLE_VERSION`:版本字符串。
*   `MACOSX_BUNDLE_SHORT_VERSION_STRING`:短版本字符串。
*   `MACOSX_BUNDLE_LONG_VERSION_STRING`:长版本字符串。

在为这些字符串设置值之后，您必须告诉 CMake 在调用`ADD_EXECUTABLE`命令时创建一个包，方法是将下面一行添加到`CMakeLists.txt`文件中:

`ADD_EXECUTABLE( `exename` MACOSX_BUNDLE ... )`

**特定于 Unix 和 X11 的特性**

对于 Unix 系统，你需要让运行`make install`成为可能，所以 CMake 在安装之前必须知道要构建什么，要安装什么文件。例如，您不想将任何中间文件复制到安装目录中。

CMake 希望用户在运行 CMake 创建构建环境时指定`CMAKE_INSTALL_PREFIX`变量。它可能类似于下面的代码行，其中`.`。指的是`CMakeLists.txt`文件，`/usr/local`目录是安装目标:

`cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local`

可以安装两种类型的文件:目标文件和现有文件。目标是构建过程的结果。它们可以是名为`RUNTIME`的可执行文件，名为`LIBRARY`的动态链接库，名为`ARCHIVE`的静态链接库。使用`ADD_EXECUTABLE`命令创建`RUNTIME`目标。在本章的后面，你会学到如何创建库。

使用`INSTALL`命令来指定要安装的目标和安装位置。它可能看起来像这样:

`INSTALL( TARGETS `exenames`
  RUNTIME DESTINATION bin
  LIBRARY DESTINATION lib )`

`exenames`可以是目标名称的列表，包括可执行文件和任何类型的库。`RUNTIME DESTINATION`指定了`RUNTIME`目标相对于安装前缀的位置。本节前面的`INSTALL`命令结合`cmake`命令行会将这些文件放在`/usr/local/bin`目录中。`LIBRARY DESTINATION`以同样的方式工作。如果需要安装静态链接库，可以使用`ARCHIVE DESTINATION`指令来放置它们。您通常会从静态链接库构建可执行文件，这就是为什么我没有在前面的`INSTALL`命令中为它们指定目标目录。

前面提到了目标和现有文件。现有文件可以是文档文件、图标或任何其他不是在构建过程中生成的文件。要安装这些文件，结合使用`FILES`指令和`INSTALL`命令。语法如下所示:

`INSTALL( FILES `files` DESTINATION `directory` )`

在前面一行中，`files`表示源代码树中的文件列表。`directory`的指定与安装目标时的`bin`和`lib`相同。常见的目录是`share/` `appname`，其中`appname`是应用程序的名称。

清单 15-10 显示了一个包含目标和文件的部分例子。

**清单 15-10。** *为安装设置文件*

`SET( foo_DOCS docs/index.html docs/details.html )

...

ADD_EXECUTABLE( fooexe ... )

...

INSTALL( TARGETS fooexe
  RUNTIME DESTINATION bin )
INSTALL( FILES ${foo_DOCS}
  DESTINATION share/foo/docs )`

#### 使用 CMake 构建库

用 CMake 构建库真的很容易。您可以使用`ADD_LIBRARY`命令，而不是像构建应用程序时那样使用`ADD_EXECUTABLE`命令。要指定构建的是动态加载库还是静态库，请使用如下所示的`SHARED`或`STATIC`指令:

`ADD_LIBRARY( `dllname` SHARED `dlldependencies` )
ADD_LIBRARY( `libname` STATIC `libdependencies` )`

插件是一个共享库，但是建立在特定的环境中。这意味着在创建库目标之前，您必须使用`ADD_DEFINITIONS`命令向构建环境添加三个预处理器定义:

`ADD_DEFINITIONS( -DQT_PLUGIN )
ADD_DEFINITIONS( -DQT_NO_DEBUG )
ADD_DEFINITIONS( -DQT_SHARED )
ADD_LIBRARY( `pluginname` SHARED `plugindependencies` )`

添加的定义在发布模式下创建一个插件。如果不在发布模式下创建它，它将不会出现在设计器等工具中，因为它们是在发布模式下构建的。当在你的应用程序中使用插件时，规则是在发布和调试模式时要匹配应用程序和插件。

* * *

**注意**当然，添加的定义必须与您的 Qt 库的配置相匹配。如果你的 Qt 库是静态的，`QT_SHARED`不应该被定义。

* * *

#### 使用 CMake 管理复杂项目

应用程序项目通常由多个组件组成。通常的设计由一个或多个用于构建一个或多个应用程序的库组成。建立什么依赖什么，建立这样一个系统不是一件简单的事情。

在这一节，你将使用来自[清单 15-4](#the_files_and_directories_of_the_complex) 的项目，但是用 CMake 代替 QMake。CMake 设置的文件和目录如清单 15-11 所示。比较这两个清单可以发现，所有的 QMake 项目文件都被替换成了`CMakeLists.txt`文件。`app`和`bin`目录也被替换为`build`目录，因为您将把构建过程放在源代码树之外。

**清单 15-11。** *复杂 CMake 项目中的文件和目录*

`|   CMakeLists.txt
|
+---build
|
+---app
|   |   CMakeLists.txt
|   |   appwindow.cpp
|   |   appwindow.h
|   |   main.cpp
|
+---include
|       base.h
|
\---src
    |  CMakeLists.txt
    |  base.cpp`

我们先来看一下`CMakeLists.txt`，它位于项目根目录下。您可以在[清单 15-12](#the_root_cmake_file) 中看到整个文件，它从定义一个名为`complex`的项目开始。

项目命名之后的步骤将变量`EXECUTABLE_OUTPUT_PATH`和`LIBRARY_OUTPUT_PATH`初始化到`PROJECT_BINARY_DIR`目录中的`bin`和`lib`目录。回想一下外源码构建对比内源码构建的解释:`PROJECT_BINARY_DIR`代表构建根目录。如果构建在源代码内部，它将与代表源代码根目录的`PROJECT_SOURCE_DIR`相同。

以下两个`ADD_SUBDIRECTORIES`命令构建了`src`和`app`目录的内容(按此顺序):

**清单 15-12。** *根 CMake 文件*

`PROJECT( complex )

SET( EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin )
SET( LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib )

ADD_SUBDIRECTORY( src )
ADD_SUBDIRECTORY( app )`

`src`目录下的`CMakeLists.txt`文件如[清单 15-13](#the_cmake_file_for_building_a_static_lib) 所示。整个文件遵循[清单 15-8](#a_cmake_project_file_for_a_basic_qt_appl) 中首次引入的模板，但是它的目标是一个静态库，而不是最后的应用程序。

当您使用 QMake 时，您可以设置一个依赖目录列表，在其中保存项目的源文件和头文件。因为使用 CMake 不容易做到这一点，所以您必须引用带有完整相对路径的`base.h`头文件:`../include`。

* * *

**注意**在讨论 QMake 时，依赖目录通常(但不总是)与包含文件目录相同。

* * *

因为这个库是静态的，所以假设它通过它所链接的应用程序链接到 Qt。因此你不需要在这里添加一个`TARGET_LINK_LIBRARIES`命令。

`LIBRARY_OUTPUT_PATH`的值从根`CMakeLists.txt`文件保存到这个文件中(因为这个文件是从`ADD_SUBDIRECTORIES`命令调用的)，所以结果文件将被放在正确的目录中。

**清单 15-13。** *用于构建静态库的 CMake 文件*

`SET( src_SOURCES base.cpp )
SET( src_HEADERS ../include/base.h )

FIND_PACKAGE( Qt4 REQUIRED )
INCLUDE( ${QT_USE_FILE} )

INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR}/include )

QT4_WRAP_CPP( src_HEADERS_MOC ${src_HEADERS} )

ADD_DEFINITIONS( ${QT_DEFINITIONS} )

ADD_LIBRARY( base STATIC ${src_SOURCES} ${src_HEADERS_MOC} ).`

[清单 15-14](#the_cmake_file_for_building_the_applicat) 显示了来自`app`目录的`CMakeLists.txt`文件。它很容易与[清单 15-8](#a_cmake_project_file_for_a_basic_qt_appl) 相比较，但是它有一些调整。

第一个是使用`INCLUDE_DIRECTORIES`命令添加公共的`include`目录。源文件需要这个命令来找到`base.h`文件。它还将 Qt 库旁边的`base`库添加到`TARGET_LINK_LIBRARIES`命令中的`app`目标中。

就像构建库一样，生成的可执行文件的位置由根`CMakeLists.txt`文件控制。使用由`EXECUTABLE_OUTPUT_PATH`指向的目录。

**清单 15-14。** *构建应用程序的 CMake 文件*

`SET( app_SOURCES main.cpp appwindow.cpp )
SET( app_HEADERS appwindow.h )

FIND_PACKAGE( Qt4 REQUIRED )
INCLUDE( ${QT_USE_FILE} )

QT4_WRAP_CPP( app_HEADERS_MOC ${app_HEADERS} )

INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR}/include )

ADD_DEFINITIONS( ${QT_DEFINITIONS} )

ADD_EXECUTABLE( app ${app_SOURCES} ${app_HEADERS_MOC} )
TARGET_LINK_LIBRARIES( app base ${QT_LIBRARIES} )`

通过使用命令提示符进入`build`目录，然后运行`cmake`，引用根`CMakeLists.txt`文件，您将为整个项目生成 Makefiles。运行`make`现在可以构建所有的东西。在 MinGW 环境中运行它的输出显示在[清单 15-15](#building_the_complex_project_using_cmake) 中。可能的话，输出是彩色编码的。我突出显示了红色和紫色的线，表示一个构建的开始和这个构建的最终链接。

**清单 15-15。** *使用 CMake 和 MinGW 构建复杂项目*

`[ 14%] Generating moc_base.cxx
`Scanning dependencies of target base`
[ 28%] Building CXX object src/CMakeFiles/base.dir/base.obj
[ 42%] Building CXX object src/CMakeFiles/base.dir/moc_base.obj
`Linking CXX static library ../lib/libbase.a`
[ 42%] "Built target base"
[ 57%] Generating moc_appwindow.cxx
`Scanning dependencies of target app`
[ 71%] Building CXX object app/CMakeFiles/app.dir/main.obj
[ 85%] Building CXX object app/CMakeFiles/app.dir/appwindow.obj
[100%] Building CXX object app/CMakeFiles/app.dir/moc_appwindow.obj
`Linking CXX executable ../bin/app.exe`
[100%] "Built target app"`

### 总结

比较 QMake 和 CMake 很困难。这两种工具几乎可以做任何事情，并且都很成熟，但是它们的侧重点不同。QMake 使得为所有平台构建基于 Qt 的软件变得非常容易。CMake 也使它变得很容易，但是因为这个工具更通用，所以需要做的工作稍微多一点。

如果你计划使用非 Qt 组件或者参与 KDE 项目，那么推荐使用 CMake。否则，我建议您使用 QMake。

您可以构建应用程序、库(共享的和静态的)和插件，但是您必须注意一些特定于平台的细节。这些细节包括 Windows 和 OS X 的应用程序图标，OS X 的通用二进制文件和软件包，以及对于 Windows 平台，你是否想要一个控制台。