# 8.将平行模式映射到 TBB

有人说，历史不会重复，它只是押韵。

可以说软件也是押韵的。虽然我们可能不会一遍又一遍地编写相同的代码，但是在我们解决的问题和编写的代码中会出现一些模式。我们可以借鉴类似的解决方案。

本章着眼于已经被证明在以可伸缩的方式解决问题中有效的模式，我们将它们与如何使用 TBB 实现它们联系起来(图 [8-1](#Fig1) )。为了实现可扩展的并行化，我们应该把重点放在数据并行上；数据并行是可扩展并行的最佳总体策略。我们的编码需要鼓励将任何任务细分为多个任务，任务的数量能够随着整个问题的大小而增长；大量的任务支持更好的伸缩性。在本章中我们提倡的模式的最好帮助下，编码提供大量的任务帮助我们实现算法的可伸缩性。

我们可以通过观察别人如何有效地做到这一点来学习“并行思考”。当然，我们可以站在巨人的肩膀上，走得更远。

这一章是关于从并行程序员以前的经验中学习，并且在这个过程中，学习如何更好地使用 TBB。我们将模式视为“并行思考”的灵感和有用工具我们描述模式并不是为了形成一个完美的编程分类法。

## 并行模式与并行算法

正如我们在第 [2](02.html#b978-1-4842-4398-5_2) 章中提到的，这本书的评论者建议我们“TBB 并行算法”应该被称为*模式*而不是算法。这可能是真的，但是为了与 TBB 图书馆多年来使用的术语保持一致，我们在本书和 TBB 文档中将这些特性称为通用并行*算法*。效果是一样的——它们为我们提供了从那些在我们之前探索过这些模式的最佳解决方案的人的经验中受益的机会——不仅是为了*使用*它们，而且鼓励我们更喜欢使用这些特定的模式(算法)而不是其他可能的方法，因为它们往往工作得最好(实现更好的可伸缩性)。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig1_HTML.png](Image00222.gif)

图 8-1

表达重要“工作模式”的 TBB 模板

## 模式对算法、设计等进行分类。

面向对象编程的价值是由四人组(Gamma、Helm、Johnson 和 Vlissides)和他们的标志性工作*设计模式* *:可重用面向对象软件的元素* (Addison-Wesley)描述的。许多人认为这本书给面向对象编程的世界带来了更多的秩序。他们的书收集了社区的集体智慧，并将其归结为带有名称的简单“模式”，因此人们可以谈论它们。

Mattson、Sanders 和 Massingill (Addison-Wesley)的《并行编程的模式》也从并行编程社区收集了类似的智慧。专家用常用的招数，有自己的语言来讲技巧。考虑到并行模式，程序员可以很快跟上并行编程的速度，就像面向对象的程序员在著名的“四人帮”一书中所做的那样。

*并行编程的模式*比这本书还长，阅读起来也很密集，但是在作者 Tim Mattson 的帮助下，我们可以总结出这些模式与 TBB 的关系。

Tim 等人提出程序员需要通过四个设计空间来开发一个并行程序:

1.  寻找并发性。

    对于这个设计空间，我们在我们的问题域内工作，以识别可用的并发性，并将其公开用于算法设计。TBB 通过鼓励我们找到尽可能多的任务来简化这项工作，而不必担心如何将它们映射到硬件线程。我们还提供了当任务足够大时，如何最好地将任务分成两半的信息。利用这些信息，TBB 然后自动重复划分大型任务，以帮助在处理器内核之间平均分配工作。大量的任务导致了我们算法的可扩展性。

2.  算法结构。

    这个设计空间体现了我们组织并行算法的高级策略。我们需要弄清楚我们想要如何组织我们的工作流程。图 [8-1](#Fig1) 列出了重要的模式，我们可以参考这些模式来选择最适合我们需求的模式。这些“有效模式”是麦克库尔、罗宾逊和赖因德斯(Elsevier)的*结构化并行编程*的焦点。

3.  支撑结构。

    这一步包括将算法策略转化为实际代码的细节。我们考虑如何组织并行程序，以及用于管理共享数据(尤其是可变数据)的技术。这些考虑是至关重要的，并对整个并行编程过程产生影响。TBB 的设计很好地鼓励了正确的抽象层次，所以这个设计空间通过很好地使用 TBB 而得到满足(这是我们希望在本书中教授的)。

4.  实施机制。

    这个设计空间包括线程管理和同步。线程构建模块处理所有的线程管理，让我们只需担心更高层次的设计任务。当使用 TBB 时，大多数程序员编码避免显式同步编码和调试。TBB 算法(第[章第 2](02.html#b978-1-4842-4398-5_2) 节)和流程图(第[章第 3](03.html#b978-1-4842-4398-5_3) 节)旨在最小化显式同步。第 [5](05.html#b978-1-4842-4398-5_5) 章讨论了当我们确实需要时的同步机制，第 [6](06.html#b978-1-4842-4398-5_6) 章提供了容器和线程本地存储来帮助限制对显式同步的需求。

    使用模式语言可以指导创建更好的并行编程环境，并帮助我们充分利用 TBB 来编写并行软件。

## 有效的模式

有了模式语言的武装，我们应该把它们当作工具。我们强调已被证明对开发最具伸缩性的算法有用的模式。我们知道，实现并行可伸缩性的两个先决条件是良好的数据局部性和避免开销。幸运的是，为了实现这些目标，已经开发了许多好的策略，并且可以使用 TBB 进行访问(参见图 [8-1](#Fig1) 中的表格)。考虑到需要针对真实机器进行良好的调优，TBB 内部已经提供了一些细节，包括与模式实现相关的问题，比如粒度控制和缓存的良好使用。

在这些方面，TBB 处理实现的细节，因此我们可以在更高的水平上编程。这就是为什么使用 TBB 编写的代码是可移植的，而将特定于机器的调优留在了 TBB 内部。反过来，TBB 通过任务窃取等算法，帮助最小化 TBB 端口所需的调优。将算法策略抽象成语义和实现已经证明在实践中非常有效。这种分离使得分别推理高级算法设计和低级(通常是特定于机器的)细节成为可能。

模式为讨论解决问题的方法提供了一个公共词汇表，并允许重用最佳实践。模式超越了语言、编程模型，甚至计算机体系结构，无论我们使用的编程系统是否明确支持具有特定特性的给定模式，我们都可以使用模式。幸运的是，TBB 被设计成强调经过验证的模式，这些模式导致结构良好的、可维护的和高效的程序。这些模式中的许多实际上也是确定性的(或者可以在确定性模式下运行——参见第 [16](16.html#b978-1-4842-4398-5_16) 章),这意味着它们每次执行时都会给出相同的结果。确定性是一个有用的属性，因为它使程序更容易理解、调试、测试和维护。

## 数据并行性胜出

可扩展并行的最佳总体策略是数据并行。数据并行度的定义各不相同。我们从更广的角度出发，将数据并行定义为随着数据集的增长，或者更一般地说，随着问题规模的增长而增长的任何类型的并行。通常，数据被分割成块，每个块由单独的任务处理。有时候，分裂是平的；其他时候，它是递归的。重要的是，更大的数据集产生更多的任务。

相似还是不同的操作被应用于组块与我们的定义无关。一般来说，无论问题是规则的还是不规则的，都可以应用数据并行。因为数据并行是可扩展并行的最佳策略，所以数据并行的硬件支持通常存在于所有类型的硬件中——CPU、GPU、ASIC 设计和 FPGA 设计。第 [4](04.html#b978-1-4842-4398-5_4) 章讨论了对 SIMD 的支持，正是为了连接这样的硬件支持。

数据并行的对立面是功能分解(也称为任务并行)，这是一种并行运行不同程序功能的方法。在最好的情况下，功能分解通过一个常数因子来提高性能。例如，如果一个程序有函数`f`、`g`、`and h`，并行运行它们最多能使性能提高三倍，实际上则更少。有时，功能分解可以提供满足性能目标所需的额外的并行性，但它不应该是我们的主要策略，因为它没有伸缩性。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig2_HTML.jpg](Image00223.jpg)

图 8-2

嵌套模式:一种组合模式，允许其他模式组合成一个层次结构。嵌套是指模式中的任何任务块都可以用具有相同输入输出配置和依赖关系的模式来替换。

## 嵌套模式

**嵌套**(图 [8-2](#Fig2) )可能看起来是显而易见和正常的，但在并行编程世界中却不是这样。TBB 让生活变得简单——嵌套工作正常，没有 OpenMP 等其他模型可能存在的严重超额订阅问题。

强调我们从嵌套支持中得到的两个含义:

*   当选择是否应该调用 TBB 模板时，我们不需要知道我们是在“并行区域”还是“串行区域”。因为使用 TBB 只是创建任务，所以我们不必担心线程的超额订阅。

*   我们不需要担心调用一个用 TBB 编写的库，以及控制它是否可能使用并行。

嵌套可以被认为是一种元模式，因为它意味着模式可以分层构成。这对模块化编程很重要。嵌套在串行编程中广泛用于可组合性和信息隐藏，但在并行编程中却是一个挑战。实现嵌套并行的关键是指定可选的而不是强制的并行。与其他模式相比，这是 TBB 擅长的一个领域。

当 TBB 在 2006 年被引进时，筑巢的重要性就被很好地理解了，而且它在整个 TBB 一直得到很好的支持。相比之下，OpenMP API 是在 1997 年引入的，当时我们没有充分预见到嵌套模式对未来机器的重要性。因此，整个 OpenMP 都不支持嵌套模式。这使得 OpenMP 更难用于应用程序世界之外的任何东西，这些应用程序几乎将所有工作都集中在计算密集型循环嵌套中。这些是在 20 世纪 80 年代和 90 年代创建 OpenMP 及其前身时主导我们思维的应用类型。当 TBB 被创造出来时，具有模块化和可组合性的嵌套模式是我们思考的关键(我们认为麻省理工学院的 Cilk 研究工作是对我们的思考产生重大影响的开创性工作——更多关于影响的评论，包括 Cilk，见附录 A)。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig3_HTML.jpg](Image00224.jpg)

图 8-3

映射模式:一个函数应用于一个集合的所有元素，通常产生一个与输入形状相同的新集合。

## 地图图案

**映射**模式(图 [8-3](#Fig3) )是并行编程可能的最佳模式:将工作划分为统一的独立部分，这些部分并行运行，没有依赖性。这代表了一种被称为*尴尬*并行的常规并行化。也就是说，在有独立的并行工作要做的情况下，并行性似乎最为明显。当一个算法很好地扩展时，获得高性能没有什么令人尴尬的！这种特性使得 map 模式值得尽可能地使用，因为它允许高效的并行化和高效的矢量化。

一个映射模式包含*没有*在部件之间共享可变状态；映射函数(独立的工作部分)必须是“纯的”,因为它不能修改共享状态。修改共享(可变)状态会破坏完美的独立性。这可能导致数据竞争的不确定性，并导致不确定的行为，包括可能的应用程序故障。当使用复杂的数据结构时，可能会出现隐藏的共享数据，例如`std::share_ptr`，这可能具有共享的含义。

贴图模式的用途包括图像中的伽玛校正和阈值处理、颜色空间转换、蒙特卡罗采样和光线跟踪。使用`parallel_for`通过 TBB 高效实现地图(图 [8-4](#Fig4) 中的例子)。此外，`parallel_invoke`可以用于少量的 map 类型并行，但是有限的数量不会提供太多的可伸缩性，除非并行也存在于其他级别(例如，在被调用的函数内部)。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig4_HTML.png](Image00225.gif)

图 8-4

与`parallel_for`并行实现的地图模式

## 工作瓦模式

**工作文件**模式是一种通用的映射模式，其中每个实例(映射函数)可以生成更多的实例。换句话说，工作可以被添加到“一堆”要做的事情中。例如，这可以用在树的递归搜索中，我们可能希望生成实例来处理树的每个节点的每个子节点。与 map 模式不同，对于 workpile 模式，map 函数的实例总数事先并不知道，工作的结构也不规则。这使得工作文件模式比映射模式更难矢量化(第 [4 章](04.html#b978-1-4842-4398-5_4))。使用`parallel_do`(第[章 2](02.html#b978-1-4842-4398-5_2) )与 TBB 一起高效地实现工作堆。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig5_HTML.jpg](Image00226.jpg)

图 8-5

归约模式:子任务产生子结果，这些子结果组合起来形成最终的单一答案。

## 缩减模式 _ 缩减和扫描)

**归约**模式(图 [8-5](#Fig5) )可以被认为是一个映射操作，其中每个子任务产生一个子结果，我们需要将这些子结果组合起来形成一个最终的单一答案。reduce 模式使用关联的“组合器函数”组合多个子结果。由于组合器函数的结合性，不同的组合顺序是可能的，这既是祸也是福。幸运的是，一个实现可以自由地通过以任何最有效的顺序组合来最大化性能。糟糕的是，如果由于舍入或饱和而导致每次运行的结果都有变化，这将在输出中产生不确定性。组合寻找最大数或寻找所有子结果的布尔 AND 不会遭受这些问题。然而，由于舍入变化，使用浮点数的全局加法将是不确定的。

TBB 为归约操作提供了非确定性(最高性能)和确定性(通常只有轻微的性能损失)。术语“确定性”仅指每次运行中确定的减少顺序。如果组合函数是确定性的，比如布尔 AND，那么`parallel_reduce`的非确定性顺序将产生确定性结果。

典型的组合器功能包括加法、乘法、最大值、最小值和布尔运算以及 and、OR 和 XOR。我们可以使用`parallel_reduce`(第 [2 章](02.html#b978-1-4842-4398-5_2))来实现非确定性归约。我们可以使用`parallel_deterministic_reduce`(第 [16 章](16.html#b978-1-4842-4398-5_16))来实现确定性归约。两者都允许我们定义自己的组合函数。

**扫描**模式(图 [8-6](#Fig6) )并行计算前缀(也称为扫描)。与其他缩减一样，如果`op`是关联的，这可以并行完成。这在看起来具有内在串行依赖性的场景中很有用。许多人对有一种可扩展的方式来实现这一点感到惊讶。图 [8-7](#Fig7) 显示了串行代码的示例。并行版本比串行版本需要更多的操作，但它提供了伸缩性。TBB `parallel_scan`(第 [2 章](02.html#b978-1-4842-4398-5_2))用于执行扫描操作。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig8_HTML.jpg](Image00229.jpg)

图 8-8

Fork-join 模式:允许控制流分叉成多个并行流，稍后再重新连接

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig7_HTML.png](Image00228.gif)

图 8-7

执行扫描操作的串行代码

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig6_HTML.jpg](Image00227.jpg)

图 8-6

扫描模式:复杂性给出了提供缩放所需的额外操作的可视化。

## 叉形连接模式

**fork-join** 模式(图 [8-8](#Fig8) )递归地将一个问题细分成子部分，可用于常规和非常规并行化。它对于实现**分治**策略(有时称为模式本身)或**分支绑定**策略(有时也称为模式本身)很有用。分叉连接不应与障碍混淆。屏障是跨多个线程的同步构造。在屏障中，每个线程必须等待所有其他线程到达屏障，然后它们中的任何一个才会离开。join 也等待所有线程到达一个公共点，但不同的是，在一个障碍之后，所有线程都继续，但在 join 之后，只有一个线程继续。独立运行一段时间，然后使用障碍进行同步，然后再次独立进行的工作实际上与使用中间有障碍的 map 模式是一样的。这类程序会受到 Amdahl 的法律处罚(详见前言)，因为时间是用来等待而不是工作的(序列化)。

我们应该考虑`parallel_for`和`parallel_reduce`，因为如果我们的需求不是太不规则，它们会自动实现我们需要的功能。TBB 模板`parallel_invoke`(章节 [2](02.html#b978-1-4842-4398-5_2) )、`task_group`(章节 [10](10.html#b978-1-4842-4398-5_10) )、`flow_graph (`章节 [3](03.html#b978-1-4842-4398-5_3) )是实现 fork-join 模式的方法。除了这些直接编码方法，值得注意的是，TBB 实现中的 fork-join 用法和嵌套支持使得无需显式编码就可以获得 fork-join 和嵌套的好处。一个`parallel_for`将自动使用优化的 fork-join 实现来帮助跨越可用的并行性，同时保持可组合性，以便嵌套(包括嵌套的`parallel_for`循环)和其他形式的并行性可以同时激活。

## 分治模式

**fork-join** 模式可以被认为是基本模式，而**divide-and-concurve**是我们如何分叉和加入的一种策略。这是否是一个独特的模式是一个语义问题，对于我们这里的目的并不重要。

如果一个问题可以被递归地分成更小的子问题，直到达到一个可以串行解决的基本情况，那么分治模式就适用了。分而治之可以描述为划分(分割)一个问题，然后使用 map 模式来计算分割中每个子问题的解决方案。子问题的结果解被组合起来，给出原问题的解。分而治之有助于并行实现，因为只要更多的工人(任务)有利，就可以很容易地细分工作。

当需要各个击破时，`parallel_for`和`parallel_reduce`实现应该首先考虑的功能。同样，可以使用相同的模板实现分治，这些模板可以作为实现 fork-join 模式的方法(`parallel_invoke`、`task_group`和`flow_graph`)。

## 分枝限界模式

**fork-join** 模式可以被认为是基本模式，而**分支-绑定**是我们如何分叉和连接的一种策略。这是否是一个独特的模式是一个语义问题，对于我们这里的目的并不重要。

分支限界是一种*非确定性*搜索方法，用于在可能有多个答案时找到一个满意的答案。Branch 指的是使用并发性，bound 指的是以某种方式限制计算——例如，通过使用上限(比如目前为止找到的最佳结果)。“分支定界”这个名字来源于这样一个事实:我们递归地将问题分成几个部分，然后在每个部分中绑定解决方案。相关技术，如 alpha-beta 修剪，也用于人工智能中的状态空间搜索，包括国际象棋和其他游戏的棋步评估。

与许多其他并行算法不同，分支限界可以导致超线性加速。然而，每当有多个可能的匹配时，这种模式是不确定的，因为返回哪个匹配取决于在每个子集上搜索的时间。为了获得超线性加速，需要以有效的方式取消正在进行的任务(参见第 [15 章](15.html#b978-1-4842-4398-5_15))。

搜索问题确实有助于并行实现，因为有许多点需要搜索。然而，因为枚举在计算上太昂贵，所以应该以某种方式协调搜索。一个好的解决方案是使用分支定界策略。我们没有在搜索空间中探索所有可能的点，而是选择重复地将原始问题分成更小的子问题，评估到目前为止子问题的具体特征，根据手头的信息设置约束(界限)，并消除不满足约束的子问题。这种消除通常被称为“修剪”这些边界用于“修剪”搜索空间，消除可能被证明不包含最优解的候选解。通过这种策略，可行解空间的大小可以逐渐减小。因此，我们只需要探索一小部分可能的输入组合来找到最优解。

分支限界是一种非确定性方法，也是非确定性有用的一个很好的例子。要进行并行搜索，最简单的方法是划分集合并并行搜索每个子集。考虑这样一种情况，我们只需要一个结果，任何满足搜索条件的数据都是可接受的。在这种情况下，一旦在任何一个并行子集搜索中找到匹配搜索标准的项目，就可以取消其他子集中的搜索。

分支限界还可以用于数学优化，具有一些额外的功能。在数学优化中，给我们一个目标函数、一些约束方程和一个定义域。该函数取决于某些参数。域和约束方程定义了参数的合法值。在给定的域内，优化的目标是找到使目标函数最大化(或最小化)的参数值。

`parallel_for`和`parallel_reduce`实现了在需要分支绑定时应该首先考虑的功能。同样，可以使用相同的模板实现分治，这些模板可以作为实现 fork-join 模式的方法(`parallel_invoke`、`task_group`和`flow_graph`)。理解 TBB 对取消的支持(见第 [15 章](15.html#b978-1-4842-4398-5_15))在实现分支定界时可能特别有用。

## 管道模式

**管道**模式(图 [8-9](#Fig9) )很容易被低估。通过嵌套和流水线实现并行的机会是巨大的。管道模式以常规的、不变的数据流连接生产者-消费者关系中的任务。

从概念上讲，管道的所有阶段都是同时活动的，每个阶段都可以维护状态，当数据流经这些阶段时，状态可以更新。这通过流水线操作提供了并行性。此外，由于 TBB 的嵌套支持，每个阶段内部都可以有并行性。TBB `parallel_pipeline`(第 [2 章](02.html#b978-1-4842-4398-5_2))支撑基础管线。更一般地，一组阶段可以被组装在有向非循环图(网络)中。TBB `flow_graph`(第 [3 章](03.html#b978-1-4842-4398-5_3))支持管道和广义管道。

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig10_HTML.png](Image00231.jpg)

图 8-10

基于事件的协调模式:任务以生产者-消费者关系连接，任务之间的交互不规则，并且可能不断变化

![../images/466505_1_En_8_Chapter/466505_1_En_8_Fig9_HTML.jpg](Image00230.jpg)

图 8-9

管道模式:以常规的不变的生产者-消费者关系连接的任务

## 基于事件的协调模式(反应流)

**基于事件的协调**模式(图 [8-10](#Fig10) )将生产者-消费者关系中的任务与任务间不规则的、可能变化的交互联系起来。处理异步活动是一个常见的编程挑战。

这种模式很容易被低估，原因与许多人低估管道的可伸缩性相同。通过嵌套和流水线实现并行的机会是巨大的。

我们使用术语“基于事件的协调”，但我们并不试图将其与“参与者”、“反应流”、“异步数据流”或“基于事件的异步”区分开来

这种模式所需的独特的控制流方面导致了 TBB 的`flow_graph`(第 [3 章](03.html#b978-1-4842-4398-5_3))能力的发展。

异步事件的示例包括来自多个实时数据馈送源(如图像馈送或 Twitter 馈送)的中断，或者用户界面活动(如鼠标事件)。第三章提供了更多关于`flow_graph`的细节。

## 摘要

TBB 鼓励我们思考算法思维和应用程序中存在的模式，并将这些模式映射到 TBB 提供的功能上。TBB 提供了对可伸缩应用程序有效的模式支持，同时提供了处理实现细节的抽象，以保持一切模块化和完全可组合。嵌套的“超级模式”在 TBB 得到了很好的支持，因此 TBB 提供了许多并行编程模型所没有的可组合性。

## 更多信息

TBB 可以用来实现我们没有讨论的其他模式。我们强调了我们发现的关键模式及其在 TBB 的支持，但是一章很难与整本关于模式的书相提并论。

由麦克库尔、罗宾逊和赖因德斯(Elsevier，2012)撰写的结构化并行编程提供了一个“有效模式”的实践覆盖面这是一本为希望通过实践例子更深入了解模式的程序员准备的书。

Mattson、Sanders 和 Massingill (Addison-Wesley，2004 年)的《并行编程的模式》,对模式及其分类和组件进行了更深入、更学术性的探讨。

[![Creative Commons](Image00001.jpg)](https://creativecommons.org/licenses/by-nc-nd/4.0) 

**开放存取**本章根据知识共享署名-非商业-非专用 4.0 国际许可协议(http://Creative Commons . org/licenses/by-NC-nd/4.0/)的条款进行许可，该协议允许以任何媒体或格式进行任何非商业使用、共享、分发和复制，只要您适当注明原作者和来源，提供知识共享许可协议的链接，并指出您是否修改了许可材料。根据本许可证，您无权共享从本章或其部分内容派生的改编材料。

本章中的图像或其他第三方材料包含在本章的知识共享许可中，除非在材料的信用额度中另有说明。如果材料不包括在本章的知识共享许可中，并且您的预期使用不被法律法规允许或超出了允许的使用范围，您将需要直接从版权所有者处获得许可。