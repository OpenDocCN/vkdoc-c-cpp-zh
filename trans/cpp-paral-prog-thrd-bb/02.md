# 2.通用并行算法

调度并行循环的最佳方法是什么？我们如何并行处理不支持随机访问迭代器的数据结构？向看起来像管道的应用程序添加并行性的最佳方式是什么？如果 TBB 图书馆只提供任务和任务调度程序，我们将需要自己回答这些问题。幸运的是，我们不需要费力地阅读许多关于这些主题的硕士和博士论文。TBB 图书馆的开发人员已经为我们做了这些肮脏的工作！它们以模板函数和模板类的形式提供了解决这些问题的最佳方法，这是一组被称为 TBB 通用并行算法的功能。这些算法捕获了许多处理模式，这些模式是多线程编程的基石。

### 注意

TBB 库的开发者历史上一直使用通用并行*算法*来描述这组特性。所谓的*算法*，并不是指像矩阵乘法、LU 分解这样的特定计算，甚至是像`std::find`这样的东西，而是指常见的执行模式。这本书的一些评论家认为，这些特征因此被更准确地称为*模式*而不是算法。然而，为了与 TBB 图书馆多年来一直使用的术语保持一致，我们在本书中将这些特性称为通用并行*算法*。

无论何时应用这些预先写好的算法，我们都应该优先使用它们，而不是编写我们自己的实现。TBB 的开发者已经花了数年时间来测试和改进他们的性能！当然，TBB 库中包含的算法集并没有详尽地涵盖所有可能的场景，但是如果其中一个确实符合我们的处理模式，我们应该使用它。TBB 提供的算法捕获了应用程序中大多数可扩展的并行性。在第 [8](08.html#b978-1-4842-4398-5_8) 章中，我们将讨论并行编程的设计模式，例如马特森、桑德斯和马辛吉(Addison-Wesley) 的《并行编程的 T2 模式》中描述的那些模式，以及我们如何使用 TBB 通用并行算法来实现它们。

如图 [2-1](#Fig1) 所示，所有的 TBB 通用算法都是从一个执行线程开始的。当线程遇到并行算法时，它会将与该算法相关的工作分散到多个线程中。当所有的工作都完成后，执行会合并到一起，并在最初的单线程上继续执行。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig1_HTML.png](Image00042.jpg)

图 2-1。

TBB 并行算法的分叉连接性质

TBB 算法提供了一个强大但相对容易应用的并行模型，因为它们通常可以增量地添加，并且具有所考虑的代码的相当局部的视图。我们可以寻找程序最耗时的区域，添加 TBB 并行算法来加速该区域，然后寻找下一个最耗时的区域，在那里添加并行性，等等。

但是必须明白，TBB 算法**并不能保证并行执行！相反，它们只通知库允许并行执行。如果我们从 TBB 的角度来看图 [2-1](#Fig1) ，这意味着所有的工作线程都可以参与执行部分计算，只有一部分线程可以参与，或者只有主线程可以参与。像 TBB 那样假设并行性是可选的程序和库被称为具有*宽松的顺序语义*。**

 **如果仅使用单线程执行并行程序不会改变程序的语义，则该程序具有*顺序语义*。正如我们将在本书中多次提到的，由于舍入问题和其他不精确的原因，程序的顺序和并行执行的结果可能并不总是完全匹配。我们通过使用术语*宽松序列语义来承认这些潜在的、无意义的差异。*虽然 TBB 和 OpenMP API 等模型提供了宽松的顺序语义，但 MPI 等其他模型让我们可以编写具有循环关系的应用，这些关系需要并行执行。正如在第 [1](01.html#b978-1-4842-4398-5_1) 章中介绍的以及在第 [9](pt2.html#b978-1-4842-4398-5_9) 章中更详细描述的，TBB 宽松的顺序语义是它对于编写可组合应用有用的一个重要部分。现在，我们应该记住，本章描述的任何算法都会将工作分散到一个或多个线程上，但不一定是系统中所有可用的线程。

线程构建模块 2019 发行版中可用的算法集如图 [2-2](#Fig2) 中的表格所示。它们都在名称空间 tbb 中，并且在包含 tbb.h 头文件时可用。本章介绍了**粗体**算法的基础知识，其他算法将在后面的章节中介绍。我们还提供了一个侧栏**Lambda expressions–vs-user-defined classes**，解释了虽然我们在本书的示例中几乎只使用 Lambda 表达式将代码传递给 TBB 算法，但是如果需要的话，这些参数几乎总是可以被用户定义的函数对象替换。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig2_HTML.png](Image00043.gif)

图 2-2。

线程构建模块库中的通用算法。本章将更详细地介绍粗体算法。

### Lambda 表达式–vs .用户定义的类

由于 TBB 的第一版早于将 lambda 表达式引入语言的 C++11 标准，TBB 泛型算法不需要使用 lambda 表达式。有时，我们可以对 lambda 表达式或函数对象(仿函数)使用相同的接口。在其他情况下，一个算法有两组接口:一组更适合 lambda 表达式，另一组更适合用户定义的对象。

例如，代替

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figa_HTML.png](Image00044.jpg)

我们可以使用用户定义的类并编写

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figb_HTML.png](Image00045.jpg)

通常，选择使用 lambda 表达式还是用户定义的对象只是个人喜好的问题。

## 功能/任务并行性

也许 TBB 库提供的最简单的算法是`parallel_invoke`，这个函数允许我们并行执行少至两个函数，或者我们希望指定的任意多个函数:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figc_HTML.png](Image00046.jpg)

这个概念的模式名是*map*——我们将在第 [8](08.html#b978-1-4842-4398-5_8) 章中详细讨论模式。这种算法/模式所表达的独立性使得它可以很好地扩展，当我们可以应用它时，它是首选的并行方式。我们还将看到`parallel_for`，因为循环体必须是独立的，可以用于类似的效果。

对`parallel_invoke`可用接口的完整描述可以在附录 b 中找到。如果我们有一组需要调用的函数，并且并行执行调用是安全的，那么我们使用`parallel_invoke`。例如，我们可以对两个向量`v1`和`v2`进行排序，方法是在每个向量上依次调用一个`serialQuicksort`:

```

    serialQuicksort(serial_v1.begin(), serial_v1.end());
    serialQuicksort(serial_v2.begin(), serial_v2.end());

```

或者，由于这些调用彼此独立，我们可以使用一个`parallel_invoke`来允许 TBB 库创建可以由不同工作线程并行执行的任务，以重叠这两个调用，如图 [2-3](#Fig3) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig3_HTML.png](Image00047.jpg)

图 2-3。

使用`parallel_invoke`并行执行两个`serialQuicksort`调用

如果对`serialQuicksort`的两次调用执行的时间大致相同，并且没有资源限制，那么这种并行实现可以用顺序地一个接一个调用函数所需时间的一半来完成。

### 注意

作为开发人员，我们只有在函数可以安全地并行执行时，才负责并行调用函数。也就是说，TBB 将 ***而不是*** 自动识别依赖性，并应用同步、私有化或其他并行化策略来确保代码安全。当我们使用`parallel_invoke`或本章中讨论的任何并行算法时，这就是我们的责任。

使用`parallel_invoke`很简单，但是对`parallel_invoke`的一次调用不太具有*可伸缩性*。一个可扩展的算法可以有效地利用可用的额外内核和硬件资源。

一种算法显示出*强伸缩性*如果随着额外内核的增加，解决一个固定大小的问题所需的时间减少。例如，当两个内核可用时，表现出良好的强扩展性的算法完成给定数据集的处理的速度可能比顺序算法快两倍，但是当 100 个内核可用时，完成相同数据集的处理的速度比顺序算法快 100 倍。

如果随着更多处理器的增加，每个处理器用相同的时间解决固定数据集大小*的问题，算法显示*弱伸缩*。例如，表现出良好弱伸缩性的算法在使用两个处理器的固定时间段内能够处理两倍于其顺序版本的数据，而在使用 100 个处理器的相同固定时间段内能够处理 100 倍于其顺序版本的数据。*

使用一个`parallel_invoke`来并行执行两个排序将不会显示强或弱的伸缩，因为该算法最多可以使用两个处理器。如果我们有 100 个处理器可用，其中 98 个将会闲置，因为我们没有给它们任何事情做。我们应该开发可扩展的应用程序，而不是像我们的示例那样编写代码，这样我们就可以实现一次并行，而无需在每次包含更多内核的新架构可用时都重新实施。

幸运的是，TBB 可以有效地处理嵌套并行(在第 [9](pt2.html#b978-1-4842-4398-5_9) 章中有详细描述)，因此我们可以通过在递归分治算法中使用`parallel_invoke`来创建可伸缩的并行(这种模式我们将在第 [8](08.html#b978-1-4842-4398-5_8) 章中讨论)。TBB 还包括其他通用并行算法，这将在本章后面介绍，这些算法针对的是已经证明对实现可扩展并行性有效的模式，比如循环。

### 一个稍微复杂一点的例子:Quicksort 的并行实现

递归分治算法的一个众所周知的例子是快速排序，如图 [2-4](#Fig4) 所示。Quicksort 的工作原理是递归地将一个数组放在枢轴值周围，将小于或等于枢轴值的值放在数组的左分区，将大于枢轴值的值放在数组的右分区。当递归到达基数为 1 的数组时，整个数组已经被排序。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig4_HTML.png](Image00048.jpg)

图 2-4。

快速排序的串行实现

我们可以开发一个 quicksort 的并行实现，如图 [2-5](#Fig5) 所示，用一个`parallel_invoke`代替两个对`serialQuicksort`的递归调用。除了使用`parallel_invoke`，我们还引入了一个截止值。在最初的串行快速排序中，我们一直向下递归划分到单个元素的数组。

### 注意

生成和调度 TBB 任务并不是免费的——经验法则是，任务应该至少执行 1 微秒或 10，000 个处理器周期，以减少与任务创建和调度相关的开销。在第 [16](16.html#b978-1-4842-4398-5_16) 章中，我们提供了实验来更详细地证明这一经验法则。

为了在我们的并行实现中限制开销，我们只递归调用`parallel_invoke`直到我们降到 100 个元素以下，然后直接调用`serialQuicksort`来代替。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig5_HTML.png](Image00049.jpg)

图 2-5。

使用`parallel_invoke`并行实现快速排序

您可能会注意到 quicksort 的并行实现有一个很大的局限性 shuffle 是完全串行完成的。在顶层，这意味着在任何并行工作开始之前，我们有一个在单线程上完成的`O(n)`操作。这可能会限制加速。我们让那些有兴趣的人来看看已知的并行分区实现如何解决这个限制(参见本章末尾的“更多信息”一节)。

## 循环:`parallel_for`、`parallel_reduce`和`parallel_scan`

对于许多应用程序来说，执行时间主要由循环时间决定。有几种 TBB 算法可以表达并行循环，让我们可以快速地为应用程序中的重要循环添加可扩展的并行性。图 [2-2](#Fig2) 中标记为“简单循环”的算法是那些迭代空间的开始和结束可以通过循环开始的时间容易地确定的算法。

例如，我们知道在下面的循环中将有正好 N 次迭代，所以我们将其归类为简单循环:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figd_HTML.png](Image00050.jpg)

TBB 所有的简单循环算法都基于两个重要的概念，一个*范围*和一个*主体*。范围代表一组可递归分割的值。对于循环，范围通常是迭代空间中的索引或者迭代器在遍历容器时将采用的值。主体是我们应用于范围内每个值的函数；在 TBB 中，主体通常作为 C++ lambda 表达式提供，但也可以作为函数对象提供(参见 ***Lambda 表达式–vs-用户定义的类*** )。

### `parallel_for`:对范围内的每个元素应用主体

让我们从一个小的串行`for`循环开始，它在每次迭代中将函数应用于数组的一个元素:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fige_HTML.png](Image00051.jpg)

我们可以通过使用`parallel_for`来创建这个循环的并行版本:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figf_HTML.png](Image00052.jpg)

对`parallel_for`可用接口的完整描述可以在附录 b 中找到。在小示例循环中，范围是半开区间`[0, N),`步长是 1，主体是`f(a[i])`。我们可以这样表达，如图 [2-6](#Fig6) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig6_HTML.png](Image00053.jpg)

图 2-6。

使用`parallel_for`创建并行回路

当 TBB 执行一个`parallel_for`的时候，这个范围被分成几个迭代块。与主体配对的每个块成为一个任务，该任务被调度到参与执行算法的一个线程上。TBB 库为我们处理任务的调度，所以我们需要做的就是使用`parallel_for`函数来表示循环的迭代应该并行执行。在后面的章节中，我们将讨论如何调整 TBB 并行循环的行为。现在，让我们假设对于可用内核的范围大小和数量，TBB 生成了大量的任务。在大多数情况下，这是一个很好的假设。

理解这一点很重要，通过使用`parallel_for`，我们断言以任何顺序并行执行循环迭代是安全的。TBB 库没有检查并行执行一个`parallel_for`(或者实际上任何通用算法)的迭代是否会产生与串行执行算法相同的结果——当我们选择使用并行算法时，确保这一点是我们作为开发人员的工作。在第 5 章[中，我们讨论了 TBB 的同步机制，它可以用来让一些不安全的代码变得安全。在第 6 章](05.html#b978-1-4842-4398-5_5)[中，我们将讨论提供线程安全数据结构的并发容器，这些数据结构有时也能帮助我们使代码线程安全。但最终，我们需要确保当我们使用并行算法时，读写访问模式的任何潜在变化都不会改变结果的有效性。我们还需要确保在并行代码中只使用线程安全的库和函数。](06.html#b978-1-4842-4398-5_6)

例如，下面的循环作为`parallel_for`执行是 ***而不是*** 安全的，因为每次迭代依赖于前一次迭代的结果。改变这个循环的执行顺序将改变数组`a`的元素中存储的最终值:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figg_HTML.png](Image00054.jpg)

想象一下如果数组`a={1,0,0,0,...,0}`。顺序执行此循环后，它将保持`{1,2,3,4,...,N}`。但是如果循环执行顺序错误，结果将会不同。在寻找可以安全并行执行的循环时，一个心理练习是问自己，如果循环迭代一次全部执行，或者随机执行，或者逆序执行，结果是否相同。在这种情况下，如果`a={1,0,0,0,...,0}`和循环的迭代以相反的顺序执行，当循环完成时`a`将保持`{1,2,1,1,...,1}`。显然，执行顺序对这个循环很重要！

数据依赖分析的正式描述超出了本书的范围，但可以在许多编译器和并行编程书籍中找到，包括迈克尔·沃尔夫(Pearson)的*高性能并行计算编译器*和艾伦和肯尼迪(Morgan Kaufmann)的*现代架构优化编译器*。英特尔 Parallel Studio XE 中的 Intel Inspector 等工具也可用于查找和调试线程错误，包括使用 TBB 的应用中的线程错误。

#### 稍微复杂一点的例子:并行矩阵乘法

图 [2-7](#Fig7) 显示了为`MxM`矩阵计算`C = AB`的矩阵乘法循环嵌套的非优化串行实现。我们在这里使用这个内核是为了进行演示——如果您需要在实际应用中使用矩阵乘法，并且不认为自己是优化专家——使用数学库中的高度优化的实现几乎肯定会更好，这些实现实现了基本线性代数子程序(BLAS ),如英特尔数学内核库(MKL)、BLIS 或 ATLAS。矩阵乘法在这里是一个很好的例子，因为它是一个小内核，执行一个我们都很熟悉的基本操作。有了这些免责声明，让我们继续看图 [2-7](#Fig7) 。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig7_HTML.png](Image00055.jpg)

图 2-7。

矩阵乘法的非优化实现

我们可以通过使用如图 [2-8](#Fig8) 所示的`parallel_for`快速实现图 [2-7](#Fig7) 中矩阵乘法的并行版本。在这个实现中，我们使外部的`i`循环并行。外部`i`循环的迭代执行封闭的`j`和`k`循环，因此，除非`M`非常小，否则将有足够的工作超过 1 微秒的经验法则。如果可能的话，最好使外部循环平行，以保持较低的开销。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig8_HTML.png](Image00056.jpg)

图 2-8。

矩阵乘法的简单实现

图 [2-8](#Fig8) 中的代码很快为我们提供了一个矩阵乘法的基本并行版本。虽然这是一个正确的并行实现，但由于它遍历数组的方式，它将会大大降低性能。在第 [16 章](16.html#b978-1-4842-4398-5_16)中，我们将讨论`parallel_for`中可以用来调优性能的高级特性。

### `parallel_reduce`:跨`Range`计算单个结果

在应用程序中发现的另一个非常常见的模式是归约，通常被称为“归约模式”或“映射归约”，因为它往往与*映射*模式一起使用(参见第 [8](08.html#b978-1-4842-4398-5_8) 章中关于模式术语的更多信息)。

归约从值的集合中计算出单个值。示例应用包括计算总和、最小值或最大值。

让我们考虑一个寻找数组中最大值的循环:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figh_HTML.png](Image00057.jpg)

从一组值中计算最大值是一种关联操作；也就是说，对值组执行此操作，然后按顺序组合这些部分结果是合法的。计算最大值也是可交换的，所以我们甚至不需要以任何特定的顺序组合部分结果。

对于执行关联运算的循环，TBB 提供了函数`parallel_reduce`:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figi_HTML.png](Image00058.jpg)

附录 b 中提供了对`parallel_reduce`接口的完整描述。

许多常见的数学运算是相关的，例如加法、乘法、计算最大值和计算最小值。一些操作在理论上是关联的，但是在实际系统中由于数值表示的限制而不是关联的。我们应该意识到依赖结合性对于并行性的影响(参见 ***结合性和浮点类型*** )。

### 结合性和浮点类型

在计算机算术中，精确地表示实数并不总是可行的。相反，浮点类型如`float, double,`和`long double`用作近似值。这些近似的结果是，适用于实数运算的数学属性不一定适用于浮点运算。例如，虽然加法在实数上是结合的和可交换的，但在浮点数上却不是这样。

例如，如果我们计算`N`个真实值的总和，每个值都等于 1.0，我们会期望结果是`N`。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figj_HTML.png](Image00059.jpg)

但是在`float`表示中有有限数量的有效数字，因此并不是所有的整数值都能被精确地表示。例如，如果我们用`N == 10e6`(1000 万)运行这个循环，我们将得到`10000000`的输出。但是如果我们用`N == 20e` 6 执行这个循环，我们会得到`16777216`的输出。变量 r 根本不能表示`16777217`，因为标准的`float`表示法有 24 位尾数(有效数)，而`16777217`需要 25 位。当我们添加`1.0`时，结果向下舍入到`16777216`，并且`1.0`的每个后续加法也向下舍入到`16777216`。平心而论，在每一步，`16777216`的结果都是对`16777217`的很好的近似。正是这些舍入误差的累积，使得最终的结果如此糟糕。

如果我们将这个和分成两个循环，并组合部分结果，我们在两种情况下都会得到正确的答案:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figk_HTML.png](Image00060.jpg)

为什么呢？因为`r`可以表示更大的数字，只是不总是精确的。`tmp1`和`tmp2`中的值具有相似的数量级，因此相加影响表示中可用的有效数字，我们得到的结果是 2000 万的良好近似值。这个例子是结合性如何改变使用浮点数的计算结果的一个极端例子。

这个讨论的要点是，当我们使用一个`parallel_reduce`时，它使用结合性来并行计算和组合部分结果。因此，在使用浮点数时，与串行实现相比，我们可能会得到不同的结果。事实上，根据参与线程的数量，`parallel_reduce`的实现可能会选择创建不同数量的部分结果。因此，在并行实现中，即使是相同的输入，我们也可能得到不同的结果。

在我们惊慌失措并得出永远不应该使用`parallel_reduce`的结论之前，我们应该记住，使用浮点数的实现通常会产生一个近似值。相同的输入得到不同的结果并不一定意味着至少有一个结果是错误的。这仅仅意味着对于两次不同的运行，舍入误差不同地累积。作为开发人员，我们有责任决定这些差异对应用程序是否重要。

如果我们想确保我们至少在相同输入数据的每次运行中得到相同的结果，我们可以选择使用第 [16 章](16.html#b978-1-4842-4398-5_16)中描述的`parallel_deterministic_reduce`。这种确定性实现总是创建相同数量的部分结果，并针对相同的输入以相同的顺序组合它们，因此每次运行的近似值都是相同的。

与所有简单的循环算法一样，要使用 TBB `parallel_reduce`，我们需要提供范围(`range)`和主体(`func`)。但是我们还需要提供一个标识值(`identity`)和一个归约体(`reduction`)。

为了给一个`parallel_reduce`创建并行性，TBB 库将`range`分成块，并创建将`func`应用于每个块的任务。在第 [16](16.html#b978-1-4842-4398-5_16) 章中，我们将讨论如何使用分区器来控制创建的块的大小，但是现在，我们可以假设 TBB 创建了适当大小的块来最小化开销和平衡负载。每个执行`func`的任务以一个用`identity`初始化的值`init`开始，然后计算并返回其块的部分结果。TBB 库通过调用`reduction`函数组合这些部分结果，为整个循环创建一个单一的最终结果。

`identity`参数是一个值，当使用正在并行化的操作将其他值与其组合时，该值保持不变。众所周知，关于加法(加法恒等式)的恒等式元素是“`0`”(自`x + 0 = x`)，关于乘法(乘法恒等式)的恒等式元素是“`1`”(自`x * 1 = x`)。`reduction`函数获取两个部分结果并将它们组合起来。

图 [2-9](#Fig9) 显示了如何应用`func`和`reduction`函数从 16 个元素的数组中计算最大值，如果范围被分成四个块。在这个例子中，`func`对数组元素应用的关联运算是 max()，单位元素是`-` ∞，因为`max(x,-` ∞ `)=x`。在 C++中，我们可以用`std::max`作为运算，用`std::numeric_limits<int>::min()`作为`-` ∞的程序化表示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig9_HTML.png](Image00061.jpg)

图 2-9。

如何调用`func`和`reduction`函数来计算最大值

我们可以用图 [2-10](#Fig10) 所示的`parallel_reduce`来表达我们简单的最大值循环。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig10_HTML.png](Image00062.jpg)

图 2-10。

使用`parallel_reduce`计算最大值

您可能会注意到，在图 [2-10](#Fig10) 中，我们为范围使用了一个`blocked_range`对象，而不是像使用`parallel_for`那样只提供范围的开始和结束。`parallel_for`算法提供了一个简化的语法，这是`parallel_reduce`所没有的。对于`parallel_reduce`，我们必须直接传递一个 Range 对象，但幸运的是我们可以使用库提供的预定义范围之一，其中包括`blocked_range`、`blocked_range2d`和`blocked_range3d`等等。这些其他范围对象将在第 [16](16.html#b978-1-4842-4398-5_16) 章中详细描述，它们的完整接口在附录 b 中提供。

图 [2-10](#Fig10) 中使用的`blocked_range`代表一个 1D 迭代空间。为了构造一个，我们提供开始和结束值。在主体中，我们使用它的`begin()`和`end()`函数来获取主体执行所分配的值块的起始值和结束值，然后遍历该子范围。在图 [2-8](#Fig8) 中，范围中的每个单独的值都被发送到`parallel_for`主体，因此不需要`i`循环来迭代范围。在图 [2-10](#Fig10) 中，主体接收到一个代表迭代块的`blocked_range`对象，因此我们仍然有一个`i`循环来迭代分配给它的整个块。

#### 稍微复杂一点的例子:用数值积分计算π

图 [2-11](#Fig11) 显示了通过数值积分计算π的方法。使用勾股定理计算每个矩形的高度。单位圆一个象限的面积在循环中计算，乘以 4 得到圆的总面积，等于π。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig11_HTML.png](Image00063.jpg)

图 2-11。

用矩形积分法进行连续π计算

图 [2-11](#Fig11) 中的代码计算所有矩形的面积之和，这是一个归约操作。要使用 TBB `parallel_reduce`，我们需要识别`range`、`body`、`identity`值和`reduction`函数。本例中，`range`为`[0, num_intervals)`，`body`与图 [2-11](#Fig11) 中的`i`回路相似。因为我们正在执行求和操作，所以`identity`值为`0.0`。而需要组合部分结果的`reduction`主体将返回两个值的和。使用 TBB `parallel_reduce`的并行实现如图 [2-12](#Fig12) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig12_HTML.png](Image00064.jpg)

图 2-12。

使用`tbb:`实现圆周率`:parallel_reduce`

和`parallel_for`一样，有一些高级特性和选项可以和`parallel_reduce`一起使用来调整性能和管理舍入误差(参见**结合性和浮点类型**)。这些高级选项将在第 16 章[中介绍。](16.html#b978-1-4842-4398-5_16)

### `parallel_scan`:具有中间值的缩减

应用程序中一种不太常见但仍然重要的模式是扫描(有时称为前缀)。扫描类似于归约，但它不仅从值的集合中计算单个值，还计算范围内每个元素的中间结果(*前缀*)。一个例子是值`x`<sub>`0`</sub>`, x`<sub>`1`</sub>`, ... x`<sub>`N`</sub>的运行总和。结果包括运行总和中的各个值，`y`<sub>`0`</sub>`, y`<sub>`1`</sub>`... y`<sub>`N`</sub>，以及最终总和`y` <sub>`N`</sub> 。

*   `y`<sub>`0`</sub>`= x`<sub>`0`T7】</sub>

*   `y`<sub>`1`</sub>`= x`<sub>`0`</sub>`+ x`<sub>T5</sub>

*   `. . .`

*   `y`<sub>`N`</sub>`= x`<sub>`0`</sub>`+ x`<sub>`1`</sub>`+ ... + x`<sub>`N`</sub>

根据向量`v`计算累计和的串行循环如下:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figl_HTML.png](Image00065.jpg)

从表面上看，扫描看起来像一个串行算法。每个前缀取决于所有先前迭代中计算的结果。虽然看起来令人惊讶，但是这种看似串行的算法也有高效的并行实现。TBB `parallel_scan`算法实现了高效的并行扫描。它的接口要求我们提供一个`range`、一个`identity value`、一个`scan body`和一个`combine body`:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figm_HTML.png](Image00066.jpg)

`range`、`identity value`、`combine body`类似于`parallel_reduce`的`range`、`identity value`、`reduction body`。和其他简单的循环算法一样，`range`被 TBB 库分成块，TBB 任务被创建来将主体(`scan`)应用到这些块。附录 b 中提供了`parallel_scan`接口的完整描述。

`parallel_scan`的不同之处在于`scan`主体可以在同一个迭代块上执行多次——首先是在*预扫描*模式下，然后是在*最终扫描*模式下。

在*最终扫描*模式中，主体被传递一个精确的前缀结果，该结果是紧接在其子范围之前的迭代的结果。使用这个`value`，主体计算并存储其子范围中每个迭代的前缀，并返回其子范围中最后一个元素的准确前缀。

然而，当在*预扫描*模式下执行扫描主体时，它接收一个起始前缀值，该值不是其给定范围之前的元素的最终值。就像`parallel_reduce`一样，`parallel_scan`依赖于结合性。在预扫描模式下，起始前缀值可能代表它前面的子范围，但不是它前面的完整范围。使用这个值，它返回其子范围中最后一个元素的前缀(还不是最终的)。返回值表示起始前缀及其子范围的部分结果。通过使用这些*预扫描*和*最终扫描*模式，可以在扫描算法中利用有用的并行性。

### 这是如何工作的？

让我们再来看一下运行总和的例子，并考虑用三个模块`A`、`B`和`C`来计算它。在一个连续的实现中，我们计算`A`，然后`B`，然后`C`的所有前缀(按顺序完成三个步骤)。我们可以用平行扫描做得更好，如图 [2-13](#Fig13) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig13_HTML.png](Image00067.jpg)

图 2-13。

并行执行扫描以计算总和

首先，我们在最终扫描模式下计算`A`的扫描，因为它是第一组值，所以如果它被传递一个初始值`identity`，它的前缀值将是准确的。在我们启动`A`的同时，我们以预扫描模式启动`B`。一旦这两次扫描完成，我们现在可以计算出`B`和`C`的准确起始前缀。向`B`提供来自`A` ( `92`)的最终结果，向`C`提供`A`的最终扫描结果与`B` ( `92+136 = 228`)的预扫描结果的组合。

组合操作需要恒定的时间，因此比扫描操作便宜得多。不像顺序实现采用三个大步骤一个接一个地应用，并行实现并行执行`A`的最终扫描和`B`的预扫描，然后执行恒定时间合并步骤，然后最终并行计算`B`和`C`的最终扫描。如果我们至少有两个内核，并且`N`足够大，那么使用三个块的并行前缀和可以在顺序实现的大约三分之二的时间内计算出来。并且`parallel_prefix`当然可以使用三个以上的块来执行，以利用更多的内核。

图 [2-14](#Fig14) 显示了使用 TBB `parallel_scan`的简单部分和示例的实现。`range`是区间`[1, N)`,`identity value`是`0`,`combine`函数返回其两个参数之和。`scan body`返回其子范围内所有值的部分和，加到它接收的初始`sum`上。然而，只有当它的`is_final_scan`参数为`true`时，它才会将前缀结果分配给`running_sum`数组。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig14_HTML.png](Image00068.jpg)

图 2-14。

使用`parallel_scan`实现运行总和

### 稍微复杂一点的例子:视线

图 [2-15](#Fig15) 显示了一个视线问题的串行实现，该问题类似于 Guy E. Blelloch(麻省理工学院出版社)的*数据并行计算矢量模型中描述的问题。给定观察点的高度和距观察点固定间隔的点的高度，视线代码确定从观察点可见的点。如图 [2-15](#Fig15) 所示，如果一个点与视点`altitude[0]`之间的任意一点具有较大的ѳ.角，则该点不可见串行实现执行扫描以计算给定点和观察点之间所有点的最大ѳ值。如果给定点的ѳ值大于这个最大角度，那么它就是一个可见点；否则，它不可见。*

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig15_HTML.png](Image00069.jpg)

图 2-15。

视线示例

图 [2-16](#Fig16) 显示了使用 TBB `parallel_scan`的视线示例的并行实现。当算法完成时，`is_visible`数组将包含每个点的可见性(`true`或`false`)。需要注意的是，图 [2-16](#Fig16) 中的代码需要计算每个点的最大角度，以确定该点的可见性，但最终输出的是每个点的可见性，而不是每个点的最大角度。因为`max_angle`是需要的，但不是最终结果，它在`pre-scan`和`final-scan`模式下都被计算，但`is_visible`值仅在`final-scan`执行期间为每个点存储。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig16_HTML.png](Image00070.jpg)

图 2-16。

使用`parallel_scan`实现视线

## 煮熟为止:parallel_do 和 parallel_pipeline

对于某些应用程序，简单的循环可以让我们全面了解有用的并行性。但是对于其他的，我们需要在循环中表达并行性，在循环开始之前不能完全计算范围。例如，考虑一个 while 循环:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fign_HTML.png](Image00071.jpg)

这个循环一直读取图像，直到没有更多的图像可以读取。每幅图像被读取后，由函数`f`进行处理。我们不能使用`parallel_for`,因为我们不知道将会有多少图像，因此不能提供一个范围。

一个更微妙的情况是，我们有一个不提供随机访问迭代器的容器:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figo_HTML.png](Image00072.jpg)

### 注意

在 C++中，迭代器是一个对象，它指向一个元素范围中的一个元素，并定义提供遍历该范围中的元素的能力的操作符。迭代器有不同的类别，包括*正向*、*双向*和*随机访问*迭代器。随机访问迭代器可以在常量时间内指向范围内的任何元素。

因为一个`std::list`不支持对其元素的随机访问，我们可以获得范围`my_images.begin()`和`my_images.end(),`的定界符，但是如果不依次遍历列表，我们就不能到达这两个点之间的元素。因此，TBB 库不能快速地(在恒定的时间内)创建迭代块来作为任务分发，因为它不能快速地指向这些块的开始和结束点。

为了处理这样的复杂循环，TBB 库提供了两个通用算法:`parallel_do`和`parallel_pipeline`。

### `parallel_do`:应用一个身体，直到没有更多的项目了

TBB `parallel_do`将主体应用于工作项目，直到不再有项目需要处理。一些工作项目可以在循环开始时预先提供，其他的可以在主体执行处理其他项目时添加。

`parallel_do`函数有两个接口，一个接受第一个和最后一个迭代器，另一个接受容器。附录 b 中提供了对`parallel_do`接口的完整描述。在本节中，我们将查看接收容器的版本:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figp_HTML.png](Image00073.jpg)

作为一个简单的例子，让我们从一个`std::pair<int, bool>`元素的`std::list`开始，每个元素包含一个随机整数`value`和`false`。对于每个元素，我们将计算`int value`是否是质数；如果是，我们将`true`存储到`bool value`。我们将假设我们被给定了填充容器并确定一个数是否是质数的函数。串行实现如下:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figq_HTML.png](Image00074.jpg)

我们可以使用 TBB `parallel_do`创建这个循环的并行实现，如图 [2-17](#Fig17) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig17_HTML.png](Image00075.jpg)

图 2-17。

使用`parallel_do`实现质数循环

TBB `parallel_do`算法将安全地顺序遍历容器，同时创建任务将主体应用于每个元素。因为必须顺序遍历容器，所以`parallel_do`不像`parallel_for`那样可伸缩，但是只要主体相对较大(> 100，000 个时钟周期)，遍历开销与主体在元素上的并行执行相比可以忽略不计。

除了处理不提供随机访问的容器之外，`parallel_do`还允许我们从主体执行中添加额外的工作项。如果主体正在并行执行，并且它们添加了新的项目，那么这些项目也可以并行生成，从而避免了`parallel_do`的顺序任务生成限制。

图 [2-18](#Fig18) 提供了一个计算值是否是质数的串行实现，但是这些值存储在一个树中而不是一个列表中。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig18_HTML.png](Image00076.jpg)

图 2-18。

检查元素树中的质数

我们可以使用如图 [2-19](#Fig19) 所示的`parallel_do,`来创建这个树版本的并行实现。为了突出显示提供工作项的不同方式，在这个实现中，我们使用了一个保存单个值树的容器。`parallel_do`只从一个工作项开始，但是在每个主体执行中添加了两个项，一个处理左子树，另一个处理右子树。我们使用`parallel_do_feeder.add`方法向迭代空间添加新的工作项。类`parallel_do_feeder`由 TBB 库定义，并作为第二个参数传递给主体。

随着主体遍历树的各个级别，可用工作项的数量呈指数增长。在图 [2-19](#Fig19) 中，我们甚至在检查当前元素是否为质数之前就通过`feeder`添加了新的项目，以便其他任务尽可能快地产生。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig19_HTML.png](Image00077.jpg)

图 2-19。

使用 TBB 检查元素树中的质数`parallel_do`

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figr_HTML.png](Image00078.jpg)

我们应该注意到，我们考虑的`parallel_do`的两种用法有可能因为不同的原因而伸缩。第一个实现没有图 [2-17](#Fig17) 中的进给器，如果每个主体执行都有足够的工作来减少顺序遍历列表的开销，那么它可以表现出良好的性能。在第二个实现中，使用图 [2-19](#Fig19) 中的 feeder，我们只从一个工作项目开始，但是随着主体执行和添加新项目，可用工作项目的数量会快速增长。

#### 一个稍微复杂一点的例子:正向替换

正向代换是求解一组方程`Ax = b`的方法，其中`A`是一个`nxn`下三角矩阵。作为矩阵来看，这组方程看起来像

![$$ \left[\begin{array}{cccc}{a}_{11}&amp; 0&amp; \cdots &amp; 0\\ {}{a}_{21}&amp; {a}_{22}&amp; \cdots &amp; 0\\ {}\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ {}{a}_{n1}&amp; {a}_{n2}&amp; \cdots &amp; {a}_{nn}\end{array}\right]\left[\begin{array}{c}{x}_1\\ {}{x}_2\\ {}\vdots \\ {}{x}_n\end{array}\right]=\left[\begin{array}{c}{b}_1\\ {}{b}_2\\ {}\vdots \\ {}{b}_n\end{array}\right] $$](Image00079.jpg)

并且可以一次解决一行:

![$$ {x}_1={b}_1/{a}_{11} $$](Image00080.jpg)

![$$ {x}_2=\left({b}_2-{a}_{21}{x}_1\right)/{a}_{22} $$](Image00081.jpg)

![$$ {x}_3=\left({b}_3-{a}_{31}{x}_1-{a}_{32}{x}_2\right)/{a}_{33} $$](Image00082.jpg)

![$$ \vdots $$](Image00083.jpg)

![$$ {x}_m=\left({b}_n-{a}_{n1}{x}_1-{a}_{n2}{x}_2-\dots -{a}_{nn-1}{x}_{n-1}\right)/{a}_{nn} $$](Image00084.jpg)

该算法直接实现的串行代码如图 [2-20](#Fig20) 所示。在串行代码中，b 被破坏性地更新以存储每行的总和。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig20_HTML.png](Image00085.jpg)

图 2-20。

向前替换的直接实现的串行代码。编写该实现是为了使算法清晰明了，而不是为了获得最佳性能。

图 [2-21(a)](#Fig21) 显示了图 [2-20](#Fig20) 中`i,j`循环嵌套体迭代之间的依赖关系。内部`j`循环的每次迭代(如图中的行所示)执行到`b[i]`的归约，并且还依赖于在`i`循环的早期迭代中编写的`x`的所有元素。我们可以使用`parallel_reduce`来并行化内部的`j`循环，但是在`i`循环的早期迭代中可能没有足够的工作来实现这一点。图 [2-21(a)](#Fig21) 中的虚线显示了在这个循环嵌套中还有另外一种寻找并行性的方法，那就是对角穿过迭代空间。我们可以通过使用`parallel_do`来利用这种并行性，仅在满足依赖关系时添加迭代，类似于我们在图 [2-19](#Fig19) 中发现新的树元素时添加它们的方式。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig21_HTML.png](Image00086.gif)

图 2-21。

8 × 8 小矩阵正向代换中的依赖性。在(a)中，显示了迭代之间的依赖性。在(b)中，迭代被分组为块以减少调度开销。在(a)和(b)中，每个块都必须等待它上面的邻居和它左边的邻居完成，然后才能安全执行。

如果我们分别表示每个迭代的并行性，我们将创建太小而不能克服调度开销的任务，因为每个任务将只是一些浮点操作。相反，我们可以修改循环嵌套来创建迭代块，如图 [2-21(b)](#Fig21) 所示。依赖模式保持不变，但是我们将能够把这些更大的迭代块作为任务来调度。串行代码的封锁版本如图 [2-22](#Fig22) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig22_HTML.png](Image00087.jpg)

图 2-22。

向前替换的串行实现的阻塞版本

使用`parallel_do`的并行实现如图 [2-23](#Fig23) 所示。这里，我们使用`parallel_do`的接口，它允许我们指定开始和结束迭代器，而不是整个容器。你可以在附录 b 中看到这个接口的细节。

与图 [2-19](#Fig19) 中的质数树示例不同，我们不想简单地将每个相邻的块发送到馈送器。相反，我们初始化一个计数器数组，`ref_count,`来保存在每个块被允许开始执行之前必须完成的块数。原子变量将在第 5 章中详细讨论。对于我们这里的目的，我们可以把这些看作是我们可以安全地并行修改的变量；特别是，递减是以线程安全的方式完成的。我们初始化计数器，使左上角的元素没有依赖关系，第一列和对角线上的块有一个依赖关系，所有其他的有两个依赖关系。这些计数与图 [2-21](#Fig21) 所示的每个模块的前任数量相匹配。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig23_HTML.png](Image00088.jpg)

图 2-23。

使用`parallel_do`实现正向替换

在图 [2-23](#Fig23) 中对`parallel_do`的调用中，我们最初只提供了左上角的块`[&top_left, &top_left+1)`。但是在每个主体执行中，底部的`if`-语句会递减依赖于刚刚处理的块的块的原子计数器。如果计数器达到零，则该块满足其所有依赖性，并被提供给馈送器。

和前面的质数例子一样，这个例子展示了使用`parallel_do:`的应用程序的特点。并行性受到顺序访问容器的需求或动态查找工作项目并将其提供给算法的需求的限制。

### `parallel_pipeline`:通过一系列过滤器流式传输项目

TBB 用于处理复杂循环的第二个通用并行算法是`parallel_pipeline`。管道是一系列线性的*过滤器*，当*项*通过它们时，它们会对其进行转换。管道通常用于处理流入应用程序的数据，如视频或音频帧或金融数据。在第 [3](03.html#b978-1-4842-4398-5_3) 章中，我们将讨论流图接口，它让我们可以构建更复杂的图形，包括进出滤波器的扇入和扇出。

图 [2-24](#Fig24) 显示了一个小的示例循环，它读入字符数组，通过将所有小写字符转换为大写字符以及将所有大写字符转换为小写字符来转换字符，然后将结果按顺序写入输出文件。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig24_HTML.png](Image00089.jpg)

图 2-24。

一个系列案例变化的例子

操作必须在每个缓冲区上按顺序进行，但是我们可以重叠应用于不同缓冲区的不同过滤器的执行。图 [2-25(a)](#Fig25) 将此示例显示为一个流水线，其中“写缓冲区”在`buffer` <sub>`i`</sub> 上运行，而并行的“处理”过滤器在`buffer` <sub>`i+1`</sub> 上运行，“获取缓冲区”过滤器在`buffer` <sub>`i+2`</sub> 中读取。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig25_HTML.png](Image00090.gif)

图 2-25。

使用管道的案例更改示例

如图 [2-25(b)](#Fig25) 所示，在稳定状态下，每个过滤器都很忙，它们的执行是重叠的。然而，如图 [2-25(c)](#Fig25) 所示，不平衡滤波器会降低加速比。串行滤波器流水线的性能受到最慢串行级的限制。

TBB 库支持串行和并行过滤器。并行过滤器可以并行应用于不同的项目，以增加过滤器的吞吐量。图 [2-26(a)](#Fig26) 显示了“案例变化”的例子，中间/过程过滤器在两个项目上并行执行。图 [2-26(b)](#Fig26) 说明了如果中间的过滤器在任何给定的项目上花费的时间是其他过滤器的两倍，那么给这个过滤器分配两个线程将允许它匹配其他过滤器的吞吐量。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig26_HTML.png](Image00091.gif)

图 2-26。

使用具有并行过滤器的管道的情况变化示例。通过使用并行过滤器的两个副本，流水线最大化了吞吐量。

附录 b 中提供了对`parallel_pipeline`接口的完整描述。我们在本节中使用的`parallel_pipeline`接口如下所示:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figs_HTML.png](Image00092.jpg)

第一个参数`max_number_of_live_tokens`是在任何给定时间允许流经管道的最大项目数。该值对于限制资源消耗是必要的。例如，考虑简单的三个过滤器管道。如果中间的滤波器是一个串行滤波器，并且它比获得新缓冲器的滤波器花费的时间长 1000 倍呢？第一个过滤器可能会分配 1000 个缓冲区，仅用于在第二个过滤器之前对它们进行排队，从而浪费大量内存。

`parallel_pipeline`的第二个参数是`filter_chain`，这是一系列通过串联使用`make_filter`函数创建的过滤器而创建的过滤器:

![../images/466505_1_En_2_Chapter/466505_1_En_2_Figt_HTML.png](Image00093.jpg)

模板参数 T 和 U 指定过滤器的输入和输出类型。模式参数可以是`serial_in_order`、`serial_out_of_order`或 parallel。f 参数是过滤器的主体。图 [2-27](#Fig27) 显示了使用 TBB `parallel_pipeline`实现案例变更示例。附录 b 中提供了对`parallel_pipeline`接口的更完整描述。

我们可以注意到，第一个过滤器，因为它的输入类型是`void`，接收类型为`tbb::flow_control.`的特殊参数。当管道中的第一个过滤器不再生成新项目时，我们使用该参数来发出信号。比如图 [2-27](#Fig27) 中的第一个过滤器，当`getCaseString()`返回的指针为`null`时，我们调用`stop()`。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig27_HTML.png](Image00094.jpg)

图 2-27。

使用具有并行中间过滤器的管道的情况变化示例

在该实现中，使用`serial_in_order`模式创建第一个和最后一个过滤器。这指定了两个过滤器一次只能对一个项目运行，并且最后一个过滤器应该按照第一个过滤器生成项目的顺序执行项目。一个`serial_out_of_order`过滤器被允许以任何顺序执行项目。中间的过滤器通过`parallel`作为它的模式，允许它并行执行不同的项目。`parallel_pipeline`支持的模式在附录 b 中有更详细的描述。

#### 一个稍微复杂一点的例子:创建 3D 立体图像

图 [2-28](#Fig28) 显示了一个更复杂的管道示例。while 循环读入帧数，然后为每一帧读取左右图像，给左图像添加红色，给右图像添加蓝色。然后，它将生成的两幅图像合并成一幅红-青 3D 立体图像。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig28_HTML.jpg](Image00095.jpg)

图 2-28。

红青色 3D 立体样本应用程序

与简单的 case change 示例类似，我们也有一系列通过一组过滤器的输入。我们识别重要的函数，并将它们转换成管道过滤器:`getNextFrameNumber`、`getLeftImage`、`getRightImage`、`increasePNGChannel`(到左图)、`increasePNGChannel`(到右图)、`mergePNGImages`和`right.write()`。图 [2-29](#Fig29) 显示了绘制成管道的示例。`increasePNGChannel`滤镜应用两次，第一次在左图像上，然后在右图像上。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig29_HTML.png](Image00096.jpg)

图 2-29。

作为流水线的 3D 立体采样应用

使用 TBB `parallel_pipeline`的并行实现如图 [2-30](#Fig30) 所示。

![../images/466505_1_En_2_Chapter/466505_1_En_2_Fig30_HTML.png](Image00097.jpg)

图 2-30。

使用`parallel_pipeline`实现的立体 3D 示例

TBB `parallel_pipeline`函数对管道滤波器进行线性化。当来自第一级的输入流过管道时，过滤器被一个接一个地应用。这实际上是对这个例子的限制。在`mergeImageBuffers`滤波器之前，左右图像的处理是独立的，但是由于`parallel_pipeline`的接口，滤波器必须线性化。即便如此，只有读入图像的过滤器是串行过滤器，因此，如果执行时间由后面的并行阶段支配，则该实现仍然是可伸缩的。

在第 [3](03.html#b978-1-4842-4398-5_3) 章中，我们介绍了 TBB 流图，它将允许我们更直接地表达受益于滤波器非线性执行的应用。

## 摘要

本章提供了 TBB 库提供的通用并行算法的基本概述，包括捕获功能并行、简单和复杂循环以及流水线并行的模式。这些预先打包的算法(模式)提供了经过充分测试和调整的实现，可以逐步应用到应用程序中以提高性能。

本章显示的代码提供了一些小例子，展示了如何使用这些算法。在本书的第 2 部分(从第 [9](pt2.html#b978-1-4842-4398-5_9) 章开始)，我们将讨论如何以可组合的方式组合这些算法，并使用可用于优化局部性、最小化开销和添加优先级的库特性来调优应用程序，从而充分利用 TBB。本书的第 2 部分还讨论了在使用 TBB 通用并行算法时如何处理异常处理和取消。

我们将在下一章继续，看看 TBB 的另一个高级特征，流程图。

## 更多信息

这里有一些我们推荐的与本章相关的额外阅读材料。

*   我们讨论了并行编程的设计模式，以及它们与 TBB 通用并行算法的关系。设计模式的集合可以在

    Timothy Mattson，Beverly Sanders 和 Berna Massingill，*并行编程的模式*(第一版。)，2004 年，艾迪森-卫斯理专业。

*   在讨论 quicksort 的并行实现时，我们注意到分区仍然是一个串行瓶颈。讨论并行分区实现的文章包括

    页（page 的缩写）Heidelberger，A. Norton 和 J. T. Robinson，“使用取加的并行快速排序”，1990 年 1 月，IEEE 计算机汇刊第 39 卷第 1 期第 133-138 页。

    页（page 的缩写）齐加斯和张艺谋。快速排序的简单快速并行实现及其在 SUN enterprise 10000 上的性能评估。在第 11 届欧洲并行、分布式和基于网络的处理研讨会上(PDP 2003)，第 372–381 页，2003 年。

*   您可以在许多编译器或并行编程书籍中了解更多关于数据依赖分析的知识，包括

    Michael Joseph Wolfe，*面向并行计算的高性能编译器，* 1995，Addison-Wesley Longman 出版公司，波士顿，MA，美国。

    肯尼迪和约翰·R·艾伦，*现代体系结构的优化编译器，* 2001，摩根考夫曼出版公司，旧金山，加利福尼亚州，美国。

*   当我们讨论矩阵乘法时，我们注意到除非我们是优化专家，否则我们通常更喜欢使用线性代数内核的预打包实现。

    这种包包括

    [`www.netlib.org/blas/`](http://www.netlib.org/blas/) 中的基本线性代数子程序(BLAS)

    英特尔数学内核库(英特尔 MKL)位于 [`https://software.intel.com/mkl`](https://software.intel.com/mkl)

    自动调谐线性代数软件(图集)发现 [`http://math-atlas.sourceforge.net/`](http://math-atlas.sourceforge.net/)

    FLAME 项目研究和开发密集线性代数库。他们的 BLIS 软件框架可以用来创建高性能的 BLAS 库。火焰项目可以在 [`www.cs.utexas.edu/~flame`](https://www.cs.utexas.edu/~flame) 找到。

*   本章中的视线示例是根据中提供的说明使用并行扫描实现的

    *数据并行计算的向量模型，Guy E. Blelloch(麻省理工学院出版社)*。

图 [2-28a](#Fig28) 、 [2-29](#Fig29) 和 [3-7](https://doi.org/10.1007/978-1-4842-4398-5_3Fig#7) 中使用的照片由 Elena Adams 拍摄，经 Halide 项目教程 [`http://halide-lang.org`](http://halide-lang.org) 许可使用。

[![Creative Commons](Image00001.jpg)](https://creativecommons.org/licenses/by-nc-nd/4.0) 

**开放存取**本章根据知识共享署名-非商业-非专用 4.0 国际许可协议(http://Creative Commons . org/licenses/by-NC-nd/4.0/)的条款进行许可，该协议允许以任何媒体或格式进行任何非商业使用、共享、分发和复制，只要您适当注明原作者和来源，提供知识共享许可协议的链接，并指出您是否修改了许可材料。根据本许可证，您无权共享从本章或其部分内容派生的改编材料。

本章中的图像或其他第三方材料包含在本章的知识共享许可中，除非在材料的信用额度中另有说明。如果材料不包括在本章的知识共享许可中，并且您的预期使用不被法律法规允许或超出了允许的使用范围，您将需要直接从版权所有者处获得许可。**