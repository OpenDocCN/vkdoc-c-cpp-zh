第十八章

![image](img/frontdot.jpg)

深度字符串

用字符数组处理字符串是 c 语言中最浪费时间的事情之一。字符数组要求程序员跟踪静态引用字符串和在堆栈和堆上创建的数组之间的区别，以及有时你传递一个 char*而有时你必须复制整个数组的事实。

尤其是因为字符串操作如此普遍，字符数组是误解和错误的主要来源。尽管如此，创建字符串类仍然是初学 C++ 程序员多年来的常见练习。标准的 C++ 库`string`一劳永逸地解决了字符数组操作的问题，即使在赋值和复制构造期间也能跟踪内存。你根本不需要考虑它。

本章考察了标准的 C++ `string`类，首先看看 C++ 字符串是由什么组成的，以及 C++ 版本与传统的 C 字符数组有何不同。您将学习使用`string`对象的操作和操纵，您将看到 C++ `string`如何适应字符集和字符串数据转换的变化。

处理文本是最古老的编程应用之一，所以 C++ `string`大量借鉴了 C 和其他语言中长期使用的思想和术语也就不足为奇了。当你开始熟悉 C++ `string` s 时，这个事实应该是令人放心的。无论您选择哪种编程习惯，您可能想用`string`做三件常见的事情:

*   创建或修改存储在`string`中的字符序列。
*   检测`string`中是否存在元素。
*   在表示`string`字符的各种方案之间进行翻译。

您将看到这些工作是如何使用 C++ `string`对象来完成的。

字符串中有什么？

在 C 语言中，字符串只是一个字符数组，它总是包含一个二进制零(通常称为*零终止符*)作为它的最终数组元素。C++ `string` s 与其 C 祖先之间存在显著差异。首先，也是最重要的，C++ `string`隐藏了它们包含的字符序列的物理表示。您不需要关心数组维数或空终止符。一个`string`还包含一些关于其数据大小和存储位置的“内务”信息。具体来说，一个 C++ `string`对象知道它在内存中的起始位置、它的内容、它的字符长度，以及在它必须调整其内部数据缓冲区之前它可以增长到的字符长度。因此，C++ 字符串大大降低了犯三种最常见和最具破坏性的 C 编程错误的可能性:覆盖数组边界、试图通过未初始化或值不正确的指针访问数组，以及在数组不再占用曾经分配给它的存储空间后让指针“悬空”。

C++ 标准没有定义 string 类的内存布局的确切实现。这“意在足够灵活*以允许编译器供应商的不同实现，而*保证用户的可预测行为*。特别是，没有定义分配存储来保存字符串对象的数据的确切条件。字符串分配规则被公式化为*允许但不要求*引用计数实现，但是无论实现是否使用引用计数，语义必须是相同的。换句话说，在 C 语言中，每个`char`数组都占据一个唯一的物理内存区域。在 C++ 中，单个的`string`对象可能会也可能不会占用内存中唯一的物理区域，但是如果引用计数避免存储数据的重复副本，那么单个对象必须看起来和表现得好像它们独占了唯一的存储区域。例如，见[清单 18-1](#list1) 。*

 ****[清单 18-1](#_list1)*** 。说明字符串存储

```cpp
//: C18:StringStorage.cpp
#include <string>
#include <iostream>
using namespace std;

int main() {

  string s1("12345");

  // Set the iterator indicate the first element
  string::iterator it = s1.begin();

  // This may copy the first to the second or
  // use reference counting to simulate a copy
  string s2 = s1;

  // Either way, this statement may ONLY modify first
  *it = '0';
  cout << "s1 = " << s1 << endl;
  cout << "s2 = " << s2 << endl;

} ///:∼
```

引用计数可能有助于提高实现的内存效率，但它对`string`类的用户是透明的。

创建和初始化 C++ 字符串

创建和初始化字符串是一件简单的事情，而且相当灵活。在[清单 18-2](#list2) 的`SmallString.cpp`中，声明了第一个`string`、`imBlank`，但不包含初始值。与 C `char`数组不同，`imBlank`数组包含有意义的信息，C`char`数组在初始化之前包含随机且无意义的位模式。这个`string`对象被初始化为保存“no characters ”,并且可以使用类成员函数正确地报告它的零长度和数据元素的缺失。

下一个字符串`heyMom`，由文字参数“我的袜子在哪里？”这种形式的初始化使用带引号的字符数组作为`string`构造器的参数。相比之下，`standardReply`只是通过赋值来初始化。使用现有的 C++ `string`对象初始化该组的最后一个字符串`useThisOneAgain`。换句话说，[清单 18-2](#list2) 说明了`string`对象让你做以下事情:

*   创建一个空的`string`，并推迟用字符数据初始化它。
*   通过将一个带引号的字符数组作为参数传递给构造器来初始化一个`string`。
*   使用等号(`=`)初始化 a `string`。
*   使用一个`string`初始化另一个。

***[清单 18-2](#_list2)*** 。说明字符串特征

```cpp
//: C18:SmallString.cpp
#include <string>
using namespace std;

int main() {
  string imBlank;
  string heyMom("Where are my socks?");
  string standardReply = "Beamed into deep "
    "space on wide angle dispersion?";
  string useThisOneAgain(standardReply);
} ///:∼
```

这些是最简单的初始化形式，但是变化提供了更多的灵活性和控制。您可以执行以下操作:

*   使用 C `char`数组或 C++ `string`的一部分。
*   使用`operator+`组合不同来源的初始化数据。
*   使用`string`对象的`substr()`成员函数创建一个子串。

清单 18-3 展示了这些特征。

***[清单 18-3](#_list3)*** 。说明更多字符串功能

```cpp
//: C18:SmallString2.cpp
#include<string>
#include<iostream>
using namespace std;

int main() {
  string s1("What is the sound of one clam napping?");
  string s2("Anything worth doing is worth overdoing.");
  string s3("I saw Elvis in a UFO");
  // Copy the first 8 chars:
  string s4(s1, 0, 8);
  cout << s4 << endl;
  // Copy 6 chars from the middle of the source:
  string s5(s2, 15, 6);
  cout << s5 << endl;
  // Copy from middle to end:
  string s6(s3, 6, 15);
  cout << s6 << endl;
  // Copy many different things:
  string quoteMe = s4 + "that" +
  // substr() copies 10 chars at element 20
  s1.substr(20, 10) + s5 +
  // substr() copies up to either 100 char
  // or eos starting at element 5
  "with" + s3.substr(5, 100) +
  // OK to copy a single char this way
  s1.substr(37, 1);
  cout << quoteMe << endl;
} ///:∼
```

`string`成员函数`substr()`将起始位置作为第一个参数，将选择的字符数作为第二个参数。两个参数都有默认值。如果你用一个空的参数列表说`substr()`，你产生了一个整个`string`的副本，所以这是一个复制`string`的方便方法。

下面是程序的输出:

```cpp
What is
doing
Elvis in a UFO
What is that one clam doing with Elvis in a UFO?
```

注意清单 18-3 中[的最后一行。C++ 允许在一条语句中混合使用初始化技术，这是一个灵活方便的特性*。*还要注意，最后一个初始化器只从源`string`复制了一个字符。](#list3)

另一个稍微微妙的初始化技术涉及到使用`string`迭代器`string::begin()`和`string::end()`。这种技术将`string`视为一个*容器*对象(您主要以`vector`的形式看到它)，它使用*迭代器*来指示一个字符序列的开始和结束。这样你可以给一个`string`构造器传递两个迭代器，它从一个迭代器复制到另一个迭代器到新的`string`，如[清单 18-4](#list4) 所示。

***[清单 18-4](#_list4)*** 。说明字符串迭代器

```cpp
//: C18:StringIterators.cpp
#include <string>
#include <iostream>
#include <cassert>
using namespace std;

int main() {
  string source("xxx");
  string s(source.begin(), source.end());
  assert(s == source);
} ///:∼
```

迭代器不限于`begin()`和`end()`；您可以增加、减少和添加整数偏移量，允许您从源`string`中提取字符的子集。

C++ 字符串可能*而不是*用单个字符或 ASCII 或其他整数值初始化。但是，您可以用单个字符的多个副本来初始化一个字符串；参见[清单 18-5](#list5) 。

***[清单 18-5](#_list5)*** 。说明字符串的初始化

```cpp
//: C18:UhOh.cpp
#include <string>
#include <cassert>
using namespace std;

int main() {
  // Error: no single char inits
  //! string nothingDoing1('a');
  // Error: no integer inits
  //! string nothingDoing2(0x37);
  // The following is legal:
  string okay(5, 'a');
  assert(okay == string("aaaaa"));
} ///:∼
```

第一个参数指示第二个参数在字符串中的副本数。第二个参数只能是单个`char`，不能是`char`数组。

在字符串上操作

如果你用 C 语言编程，你会习惯于编写、搜索、修改和复制`char`数组的函数。处理`char`数组的标准 C 库函数有两个不幸的方面。首先，它们有两个组织松散的家族:“普通”组，以及要求您提供手头操作中要考虑的字符数的组。C `char`数组库中的函数列表中有一长串神秘的、大多难以发音的名字，让不知情的用户大吃一惊。尽管函数的参数类型和数量有些一致，但要正确使用它们，您必须注意函数命名和参数传递的细节。

标准 C `char`数组工具的第二个固有陷阱是，它们都明确依赖于字符数组包含一个空终止符的假设。如果由于疏忽或错误，空值被忽略或覆盖，C `char`数组函数很难控制内存超出分配空间的限制，有时会导致灾难性的结果。

C++ 极大地提高了`string`对象的便利性和安全性。对于实际的字符串处理操作来说，`string`类中的不同成员函数名称的数量与 C 库中的函数数量大致相同，但是由于重载，功能要多得多。再加上合理的命名实践和对默认参数的明智使用，这些特性结合起来使得`string`类比 C 库`char`数组函数更容易使用。

追加、插入和连接字符串

C++ 字符串最有价值和最方便的方面之一是它们可以根据需要增长，而不需要程序员的干预。这不仅使字符串处理代码本身更值得信赖，而且几乎完全消除了繁琐的日常工作——跟踪字符串所在的存储范围。例如，如果创建一个 string 对象，用一个包含 50 个副本的字符串*X*对其进行初始化，然后在其中存储 50 个副本的“Zowie”，那么该对象本身将重新分配足够的存储空间来容纳数据的增长。也许没有什么地方比在代码中操作的字符串改变大小时更能体现这种特性，而您不知道这种改变有多大。字符串成员函数`append()`和`insert()`在字符串增长时透明地重新分配存储，如清单 18-6 中的[所示。](#list6)T9】**

 *****[清单 18-6](#_list6)*** 。示出了根据字符串大小的存储再分配

```cpp
//: C18:StrSize.cpp
#include <string>
#include <iostream>
using namespace std;

int main() {
  string bigNews("I saw Elvis in a UFO. ");
  cout << bigNews << endl;
  // How much data have we actually got?
  cout << "Size = " << bigNews.size() << endl;
  // How much can we store without reallocating?
  cout << "Capacity = " << bigNews.capacity() << endl;
  // Insert this string in bigNews immediately
  // before bigNews[1]:
  bigNews.insert(1, " thought I");
  cout << bigNews << endl;
  cout << "Size = " << bigNews.size() << endl;
  cout << "Capacity = " << bigNews.capacity() << endl;
  // Make sure that there will be this much space
  bigNews.reserve(500);
  // Add this to the end of the string:
  bigNews.append("I've been working too hard.");
  cout << bigNews << endl;
  cout<< "Size = " << bigNews.size() << endl;
  cout << "Capacity = " << bigNews.capacity() << endl;
} ///:∼
```

下面是一个特定编译器的输出:

```cpp
I saw Elvis in a UFO.
Size = 22
Capacity = 31
I thought I saw Elvis in a UFO.
Size = 32
Capacity = 47
I thought I saw Elvis in a UFO. I've been
working too hard.
Size = 59
Capacity = 511
```

[清单 18-6](#list6) 展示了即使你可以安全地放弃分配和管理你的`string`所占用的内存的大部分责任，C++ `string`为你提供了几个工具来监控和管理它们的大小。请注意，更改分配给字符串的存储大小是多么容易。`size()`函数返回当前存储在字符串中的字符数，与`length()`成员函数相同。`capacity()`函数返回当前底层分配的大小，即字符串在不请求更多存储空间的情况下可以容纳的字符数。`reserve()`功能是一种优化机制，表明您打算指定一定量的存储空间以备将来使用；`capacity()`总是返回一个至少与最近一次调用`reserve()`一样大的值。如果新的大小大于当前的字符串大小，则`resize()`函数会添加空格，否则会截断字符串。(`resize()`的重载可以指定附加不同的字符。)

`string`成员函数为数据分配空间的确切方式取决于库的实现。当测试来自[清单 18-6](#list6) 的代码的一个实现时，似乎在偶数字(即全整数)边界上发生了重新分配，保留了 1 个字节。`string`类的设计者已经努力使混合使用 C `char`数组和 C++ 字符串对象成为可能，因此`StrSize.cpp`报告的容量数据很可能反映出，在这个特定的实现中，留出了一个字节以方便插入空终止符。

替换字符串字符

`insert()`函数的 特别好，因为它免除了您确保在字符串中插入字符不会溢出存储空间或覆盖紧跟在插入点之后的字符的责任。空间变大了，现有的角色礼貌地移动以适应新的元素。有时候这可能不是你想要的。如果您希望字符串的大小保持不变，请使用`replace()`函数来覆盖字符。有许多重载版本的`replace()`，但是最简单的一个有三个参数:一个整数表示在字符串中从哪里开始，一个整数表示从原始字符串中删除多少个字符，以及替换字符串(可以是与删除数量不同的字符数)。一个简单的例子见[清单 18-7](#list7) 。

***[清单 18-7](#_list7)*** 。说明字符串字符的替换

```cpp
//: C18:StringReplace.cpp
// Simple find-and-replace in strings.
#include <cassert>
#include <string>
using namespace std;

int main() {
  string s("A piece of text");
  string tag("$tag$");
  s.insert(8, tag + ' ');
  assert(s == "A piece $tag$ of text");
  int start = s.find(tag);
  assert(start == 8);
  assert(tag.size() == 5);
  s.replace(start, tag.size(), "hello there");
  assert(s == "A piece hello there of text");
} ///:∼
```

首先将`tag`插入到`s`(注意插入发生在表示插入点的值之前的*，并且在`tag`之后增加了一个额外的空格)，然后找到并替换它。*

在执行`replace()`之前，你应该检查一下是否有所发现。前面的例子用一个`char*`替换，但是有一个重载版本用一个`string`替换。[清单 18-8](#list8) 提供了对`replace()` 更完整的演示。

***[清单 18-8](#_list8)*** 。展示了更完整的 replace()演示

```cpp
//: C18:Replace.cpp
#include <cassert>
#include <cstddef>  // For size_t
#include <string>
using namespace std;

void replaceChars(string& modifyMe,
  const string& findMe, const string& newChars) {
  // Look in modifyMe for the "find string"
  // starting at position 0:
  size_t i = modifyMe.find(findMe, 0);
  // Did we find the string to replace?
  if(i != string::npos)
    // Replace the find string with newChars:
    modifyMe.replace(i, findMe.size(), newChars);
}
int main() {
  string bigNews = "I thought I saw Elvis in a UFO. "
                   "I have been working too hard.";
  string replacement("wig");
  string findMe("UFO");
  // Find "UFO" in bigNews and overwrite it:
  replaceChars(bigNews, findMe, replacement);
  assert(bigNews == "I thought I saw Elvis in a "
         "wig. I have been working too hard.");
} ///:∼
```

如果`replace`没有找到搜索字符串，它返回`string::npos`。`npos`数据成员是`string`类的静态常量成员，表示不存在的字符位置。

与`insert()`不同，`replace()`不会增加`string`的存储空间，如果你将新的字符复制到一个已存在的数组元素序列的中间。然而，如果需要的话，它*会*增加存储空间，例如，当你进行一次“替换”,将原来的字符串扩展到当前分配的末尾之外，如清单 18-9 中的[所示。](#list9)

***[清单 18-9](#_list9)*** 。说明字符串替换和增长

```cpp
//: C18:ReplaceAndGrow.cpp
#include<cassert>
#include<string>
using namespace std;

int main() {
  string bigNews("I have been working the grave.");
  string replacement("yard shift.");
  // The first argument says "replace chars
  // beyond the end of the existing string":
  bigNews.replace(bigNews.size() - 1,
    replacement.size(), replacement);
  assert(bigNews == "I have been working the "
         "graveyard shift.");
} ///:∼
```

对`replace()`的调用开始“替换”超出现有数组的末尾，这相当于一个追加操作。注意在[清单 18-9](#list9) `replace()`中相应地扩展了数组。

你可能已经在本章中尝试做一些相对简单的事情，比如用一个不同的字符替换一个字符的所有实例。在找到之前关于替换的材料时，您认为您找到了答案，但是随后您开始看到字符组、计数和其他看起来有点太复杂的东西。难道`string`没有办法在任何地方用一个字符替换另一个字符吗？您可以使用`find()`和`replace()`成员函数轻松编写这样一个函数，如清单 18-10 中的[所示。](#list10)

***[清单 18-10](#_list10)*** 。说明 ReplaceAll

```cpp
//: C18:ReplaceAll.h
#ifndef REPLACEALL_H
#define REPLACEALL_H
#include <string>
std::string& replaceAll(std::string& context,
  const std::string& from, const std::string& to);
#endif // REPLACEALL_H ///:∼

//: C18:ReplaceAll.cpp {O}
#include <cstddef>
#include "ReplaceAll.h"// To be INCLUDED from Header FILE above
using namespace std;

string& replaceAll(string& context, const string& from,
  const string& to) {
  size_t lookHere = 0;
  size_t foundHere;
  while((foundHere = context.find(from, lookHere))
    != string::npos) {
    context.replace(foundHere, from.size(), to);
    lookHere = foundHere + to.size();
  }
  return context;
} ///:∼
```

这里使用的版本`find()`将开始查找的位置作为第二个参数，如果没有找到，则返回`string::npos`。将变量`lookHere`中的位置提升到替换字符串之后是很重要的，在本例中`from`是`to`的子字符串。[清单 18-11](#list11) 测试`replaceAll`功能。

***[清单 18-11](#_list11)*** 。在[清单 18-10](#list10) 中展示了 ReplaceAll 的测试

```cpp
//: C18:ReplaceAllTest.cpp
//{L} ../C18/ReplaceAll
#include <cassert>
#include <iostream>
#include <string>
#include "ReplaceAll.h"
using namespace std;

int main() {
  string text = "a man, a plan, a canal, Panama";
  replaceAll(text, "an", "XXX");
  assert(text == "a mXXX, a plXXX, a cXXXal, PXXXama");
} ///:∼
```

如您所见，`string`类本身并不能解决所有可能的问题。许多解决方案都留给了标准 C++ 库中的算法，因为`string`类看起来就像一个 STL 序列(*依靠前面讨论的迭代器*)。所有的通用算法都处理容器中“一系列”的元素。通常这个范围只是“从容器的开始到结束”一个`string`对象看起来像一个字符容器:要获得范围的开始，使用`string::begin()`，要获得范围的结束，使用`string::end()`。

使用 STL replace()算法进行简单的字符替换

有没有更简单的方法，把一个字符到处换成另一个字符？是的，`string`有它；[清单 18-12](#list12) 显示了使用`replace()`算法将单个字符‘X’的所有实例替换为‘Y’。

***[清单 18-12](#_list12)*** 。说明字符串替换

```cpp
//: C18:StringCharReplace.cpp
#include <algorithm>
#include <cassert>
#include <string>
using namespace std;

int main() {
  string s("aaaXaaaXXaaXXXaXXXXaaa");
  replace(s.begin(), s.end(), 'X', 'Y');
  assert(s == "aaaYaaaYYaaYYYaYYYYaaa");

} ///:∼
```

注意这个`replace()`是作为`string`的成员函数调用的*而不是*。此外，与只执行一次替换的`string::replace()`函数不同，`replace()`算法将一个字符的所有实例替换为另一个字符。

`replace()`算法仅适用于单个对象(在本例中为`char`对象)，不会替换引用的`char`数组或`string`对象。由于`string`的行为类似于 STL 序列，许多其他算法可以应用于它，这可能会解决`string`成员函数没有直接解决的其他问题。

使用非成员重载运算符的串联

等待 C 程序员学习 C++ `string`处理的最令人愉快的发现之一是使用`operator+`和`operator+=`可以多么简单地组合和追加`string` s。这些操作符使得组合`string`在语法上类似于添加数字数据，如清单 18-13 所示。

***[清单 18-13](#_list13)*** 。说明字符串的添加

```cpp
//: C18:AddStrings.cpp
#include <string>
#include <cassert>
using namespace std;

int main() {
  string s1("This ");
  string s2("That ");
  string s3("The other ");
  // operator+ concatenates strings
  s1 = s1 + s2;
  assert(s1 == "This That ");
  // Another way to concatenates strings
  s1 += s3;
  assert(s1 == "This That The other ");
  // You can index the string on the right
  s1 += s3 + s3[4] + "ooh lama";
  assert(s1 == "This That The other The other oooh lala");
} ///:∼
```

使用`operator+`和`operator+=`操作符是组合`string`数据的一种灵活方便的方式。在语句的右侧，几乎可以使用任何计算结果为一个或多个字符组的类型。

在字符串中搜索

`string`成员函数的`find`系列定位给定字符串中的一个字符或一组字符。[表 18-1](#Tab1) 显示了`find`家族的成员及其一般用法。

[表 18-1](#_Tab1) 。通过查找字符串成员函数族进行搜索

| 字符串查找成员函数 | 它发现了什么/如何发现的 |
| --- | --- |
| `find()` | 在字符串中搜索指定的字符或一组字符，并返回找到的第一个匹配项的起始位置，如果没有找到匹配项，则返回`npos`。 |
| `find_first_of()` | 搜索目标字符串并返回指定组中第一个匹配的*任意*字符的位置。如果没有找到匹配，它返回`npos`。 |
| `find_last_of()` | 搜索目标字符串并返回指定组中任何字符的*的最后一个匹配的位置。如果没有找到匹配，它返回`npos`。* |
| `find_first_not_of()` | 搜索目标字符串并返回指定组中第一个*不匹配*任何*字符的元素的位置。如果没有找到这样的元素，它返回`npos`。* |
| `find_last_not_of()` | 搜索目标字符串，并返回指定组中*与*中的任何*字符都不匹配的最大下标元素的位置。如果没有找到这样的元素，它返回`npos`。* |
| `rfind()` | 在字符串中从头到尾搜索指定的字符或字符组，如果找到匹配项，则返回匹配项的起始位置。如果没有找到匹配，它返回`npos`。 |

`find()`最简单的用法是在`string`中搜索一个或多个字符。这个重载版本的`find()`接受一个指定要搜索的字符的参数和一个告诉它从字符串中的什么地方开始搜索子字符串的可选参数。(开始搜索的默认位置是 0。)通过在一个循环中设置对`find`的调用，您可以轻松地遍历一个字符串，重复搜索以查找字符串中给定字符或字符组的所有出现。

[清单 18-14](#list14) 使用*厄拉多塞*的筛子的方法寻找小于 50 的质数*。该方法从数字 2 开始，将所有后续的 2 的倍数标记为非素数，并对下一个素数候选重复该过程。设置字符数组`sieveChars`的初始大小，并将值‘P’写入其每个成员。*

 ****[清单 18-14](#_list14)*** 。图解厄拉多塞的筛子(求质数< 50)

```cpp
//: C18:Sieve.cpp
#include <string>
#include <iostream>

using namespace std;

int main() {
// Create a 50 char string and set each
// element to 'P' for Prime
string sieveChars(50, 'P');

// By definition neither 0 nor 1 is prime.
// Change these elements to "N" for Not Prime
sieveChars.replace(0, 2, "NN");

// Walk through the array:
for(int i = 2;
i <= (sieveChars.size() / 2) - 1; i++)
// Find all the factors:
for(int factor = 2;
factor * i < sieveChars.size();factor++)
sieveChars[factor * i] = 'N';
cout << "Prime:" << endl;

// Return the index of the first 'P' element:
int j = sieveChars.find('P');

// While not at the end of the string:
while(j != sieveChars.npos) {

// If the element is P, the index is a prime
cout << j << " ";

// Move past the last prime
j++;

// Find the next prime
j = sieveChars.find('P', j);
}
cout << "\n Not prime:" << endl;

// Find the first element value not equal P:
j = sieveChars.find_first_not_of('P');
while(j != sieveChars.npos) {
cout << j << " ";
j++;
j = sieveChars.find_first_not_of('P', j);
}
} ///:∼
```

来自`Sieve.cpp`的输出如下所示:

```cpp
Prime:
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47

Not prime:
0 1 4 6 8 9 10 12 14 15 16 18 20 21 22
24 25 26 27 28 30 32 33 34 35 36 38 39
40 42 44 45 46 48 49
```

`find()`允许您在`string`中前进，检测一个字符或一组字符的多次出现，而`find_first_not_of()`允许您测试一个字符或一组字符的缺失。

`find()`成员对于检测一个`string`中一个字符序列的出现也很有用，如[清单 18-15](#list15) 所示。

***[清单 18-15](#_list15)*** 。使用 find()检测字符序列

```cpp
//: C18:Find.cpp
// Find a group of characters in a string

#include <string>
#include <iostream>

using namespace std;

int main() {
string chooseOne("Eenie, meenie, miney, mo");
int i = chooseOne.find("een");
while(i != string::npos) {
cout << i << endl;
i++;
i = chooseOne.find("een", i);
}
} ///:∼
```

`Find.cpp`产生单行输出:

```cpp
8
```

这告诉我们，搜索组“een”的第一个“e”是在单词“meenie”中找到的，并且

这是字符串中的第八个元素。注意`find`忽略了单词“Eenie”中的“Een”字符组。成员函数`find`执行一个*区分大小写的*搜索。

在`string`类中没有改变字符串大小写的函数，但是这些函数可以使用标准的 C 库函数`toupper()`和`tolower()`很容易地创建，它们一次改变一个字符的大小写。一些小的改变将使`Find.cpp`执行不区分大小写的搜索，如[清单 18-16](#list16) 所示。

***[清单 18-16](#_list16)*** 。使用 find()进行不区分大小写的搜索

```cpp
//: C18:NewFind.cpp
#include <string>
#include <iostream>
using namespace std;
// Make an uppercase copy of s:
string upperCase(string& s) {
char* buf = new char[s.length()];
s.copy(buf, s.length());

for(int i = 0; i < s.length(); i++)
buf[i] = toupper(buf[i]);

string r(buf, s.length());
delete buf;
return r;
}

// Make a lowercase copy of s:
string lowerCase(string& s) {
char* buf = new char[s.length()];

s.copy(buf, s.length());

for(int i = 0; i < s.length(); i++)
buf[i] = tolower(buf[i]);

string r(buf, s.length());
delete buf;
return r;
}

int main() {
string chooseOne("Eenie, meenie, miney, mo");
cout << chooseOne << endl;
cout << upperCase(chooseOne) << endl;
cout << lowerCase(chooseOne) << endl;

// Case sensitive search
int i = chooseOne.find("een");

while(i != string::npos) {
cout << i << endl;

i++;
i = chooseOne.find("een", i);
}

// Search lowercase:
string lcase = lowerCase(chooseOne);

cout << lcase << endl;
i = lcase.find("een");

while(i != lcase.npos) {
cout << i << endl;
i++;
i = lcase.find("een", i);
}

// Search uppercase:
string ucase = upperCase(chooseOne);
cout << ucase << endl;

i = ucase.find("EEN");

while(i != ucase.npos) {
cout << i << endl;

i++;
i = ucase.find("EEN", i);
}
} ///:∼
```

`upperCase()`和`lowerCase()`函数遵循相同的形式:它们分配存储来保存参数`string`中的数据，复制数据，并改变大小写。然后他们用新数据创建一个新的`string`，释放缓冲区，并返回结果`string`。

因为`c_str()`返回一个指向`const`的指针，所以`c_str()`函数不能用来产生一个指针来直接操作`string`中的数据。也就是说，你不能用指针操作`string`数据，只能用成员函数。如果你需要使用更原始的`char`数组操作，你应该使用上面显示的技术(参见[清单 18-16](#list16) )。

输出如下所示:

```cpp
Eenie, meenie, miney, mo
EENIE, MEENIE, MINEY, MO
eenie, meenie, miney, mo
8
eenie, meenie, miney, mo
0
8
EENIE, MEENIE, MINEY, MO
0
8
```

不区分大小写的搜索在“een”组中找到了这两个事件。

`Find.cpp`和`NewFind.cpp`不是区分大小写问题的最佳解决方案，所以我们将在“*字符串和字符特征”一节中再次讨论这个问题。*

反向查找

如果你需要从头到尾搜索一个`string`(以后进先出(LIFO)的顺序查找数据)，你可以使用字符串成员函数`rfind()`，如[清单 18-17](#list17) 所示。

***[清单 18-17](#_list17)*** 。使用 rfind()反向查找

```cpp
//: C18:Rparse.cpp
// Reverse the order of words in a string
#include <string>
#include <iostream>
#include <vector>
using namespace std;

int main() {
// The ';' characters will be delimiters
string s("now.;sense;make;to;going;is;This");
cout << s << endl;

// To store the words:
vector<string> strings;

// The last element of the string:
int last = s.size();

// The beginning of the current word:
int current = s.rfind(';');

// Walk backward through the string:
while(current != string::npos){

// Push each word into the vector.
// Current is incremented before copying to
// avoid copying the delimiter.
strings.push_back(
s.substr(++current,last - current));

// Back over the delimiter we just found,
// and set last to the end of the next word
current -= 2;
last = current;

// Find the next delimiter
current = s.rfind(';', current);
}

// Pick up the first word - it's not
// preceded by a delimiter
strings.push_back(s.substr(0, last - current));

// Print them in the new order:
for(int j = 0; j < strings.size(); j++)
cout << strings[j] << " ";
} ///:∼
```

下面是清单 18-17 中[的输出:](#list17)

```cpp
now.;sense;make;to;going;is;This
This is going to make sense now.
```

`rfind()`返回字符串寻找记号，报告匹配字符的数组索引，如果不成功则返回`string::npos`。

查找一组字符的第一个/最后一个

可以方便地将`find_first_of()` 和`find_last_of()`成员函数 用于*创建一个小实用程序，去除字符串两端的空白字符。*注意，它并不接触原始字符串，而是返回一个新字符串，如[清单 18-18](#list18) 所示。

***[清单 18-18](#_list18)*** 。去除空白，也就是修剪字符串

```cpp
//: C18:trim.h
#ifndef TRIM_H
#define TRIM_H
#include <string>

// General tool to strip spaces from both ends:
inline std::string trim(const std::string& s) {
if(s.length() == 0)
return s;

int b = s.find_first_not_of(" \t");
int e = s.find_last_not_of(" \t");

if(b == -1) // No non-spaces
return "";

return std::string(s, b, e - b + 1);
}
#endif // TRIM_H ///:∼
```

第一个测试检查空的`string`；在这种情况下，不进行测试，并返回一个副本。

注意，一旦找到了端点，`string`构造器用于从旧的构建新的`string`，给出起始计数和长度。返回值也是“优化的”

测试这样一个通用工具需要彻底，正如你在清单 18-19 中看到的。

***[清单 18-19](#_list19)*** 。测试清单 18-18 中的“trim.h”

```cpp
//: C18:TrimTest.cpp
#include "trim.h" // To be INCLUDED from Header FILE above
#include <iostream>
using namespace std;

string s[] = {
" \t abcdefghijklmnop \t ",

"abcdefghijklmnop \t ",

" \t abcdefghijklmnop",

"a", "ab", "abc", "a b c",

" \t a b c \t ", " \t a \t b \t c \t ",

"", // Must also test the empty string
};

void test(string s) {
cout << "[" << trim(s) << "]" << endl;
}

int main() {
for(int i = 0; i < sizeof s / sizeof *s; i++)
test(s[i]);
} ///:∼
```

在`string s`的数组中，可以看到字符数组被自动转换为`string`对象。这个数组提供了检查从两端删除空格和制表符的情况，以及确保空格和制表符不会从`string`的中间删除。

从字符串中删除字符

使用`erase()`成员函数删除字符简单而高效，该函数有两个参数:从哪里开始删除字符(默认为`0`)以及删除多少字符(默认为`string::npos`)。如果您指定的字符多于字符串中剩余的字符，剩余的字符将被删除(因此不带任何参数调用`erase()`将删除字符串中的所有字符)。有时，获取一个 HTML 文件并去掉其标签和特殊字符是很有用的，这样您就可以得到一些类似于 web 浏览器中显示的文本的内容，只是作为一个纯文本文件。清单 18-20 使用`erase()`来完成这项工作。

***[清单 18-20](#_list20)*** 。使用 erase()演示 HTML 剥离器

```cpp
//: C18:HTMLStripper.cpp {RunByHand}
//{L} ../C18/ReplaceAll
// Filter to remove html tags and markers.
#include <cassert>
#include <cmath>
#include <cstddef>
#include <fstream>
#include <iostream>
#include <string>
#include "ReplaceAll.h" // SEE Above
#include "../require.h" // To be INCLUDED from *[Chapter 9](09.html)*
using namespace std;

string& stripHTMLTags(string& s) {
  static bool inTag = false;
  bool done = false;
  while(!done) {
    if(inTag) {
      // The previous line started an HTML tag
      // but didn't finish. Must search for '>'.
      size_t rightPos = s.find('>');
      if(rightPos != string::npos) {
        inTag = false;
        s.erase(0, rightPos + 1);
      }
      else {
        done = true;
        s.erase();
      }
    }
    else {
      // Look for start of tag:
      size_t leftPos = s.find('<');
      if(leftPos != string::npos) {
        // See if tag close is in this line:
        size_t rightPos = s.find('>');
        if(rightPos == string::npos) {
          inTag = done = true;
          s.erase(leftPos);
        }
        else
          s.erase(leftPos, rightPos - leftPos + 1);
      }
      else
        done = true;
    }
  }
  // Remove all special HTML characters
  replaceAll(s, "&lt;", "<");
  replaceAll(s, "&gt;", ">");
  replaceAll(s, "&amp;", "&");
  replaceAll(s, "&nbsp;", " ");
  // Etc...
  return s;
}
int main(int argc, char* argv[]) {
  requireArgs(argc, 1,
    "usage: HTMLStripper InputFile");
  ifstream in(argv[1]);
  assure(in, argv[1]);
  string s;
  while(getline(in, s))
    if(!stripHTMLTags(s).empty())
      cout << s << endl;
} ///:∼
```

这段代码甚至会去掉跨多行的 HTML 标签。这是通过静态标志`inTag`来实现的，每当找到一个标签的开始，但是在同一行中没有找到伴随的标签结束时，该标志为`true`。`erase()`的所有形式都出现在`stripHTMLTags()`函数中。这里使用的`getline()`版本是一个在`<string>`头文件中声明的(全局)函数，因为它在其`string`参数中存储了一个任意长的行，所以非常方便。你不需要像使用`istream::getline()`那样担心字符数组的维数。注意清单 18-20 中的[使用了本章前面的`replaceAll()`函数。在下一章中，您将使用字符串流创建一个更优雅的解决方案。](#list20)

比较字符串

比较字符串本质上不同于比较数字。数字有恒定的、普遍有意义的值。要评估两个字符串的大小之间的关系，必须进行一个*词法比较*。词法比较意味着当您测试一个字符以查看它是“大于”还是“小于”另一个字符时，您实际上是在比较那些字符的数字表示，正如所使用的字符集的排序序列中所指定的那样。最常见的是 ASCII 排序序列，它为 32 到 127 十进制范围内的英语数字分配可打印字符。在 ASCII 排序序列中，列表中的第一个“字符”是空格，后面是几个常见的标点符号，然后是大写和小写字母。就字母表而言，这意味着靠近前面的字母比靠近末尾的字母具有更低的 ASCII 值。记住这些细节，就更容易记住当一个词汇比较报告`s1`大于`s2`时，它仅仅意味着当两者被比较时，`s1`中第一个不同的字符在字母表中比`s2`中相同位置的字符更晚。

C++ 提供了几种比较字符串的方法，每种方法都有优点。最容易使用的是非成员、重载的操作符函数:`operator ==`、`operator != operator >`、`operator <`、`operator >=`和`operator <=`。参见[清单 18-21](#list21) 中的示例。

***[清单 18-21](#_list21)*** 。说明字符串的比较

```cpp
//: C18:CompStr.cpp
#include <string>
#include <iostream>

using namespace std;
int main() {

// Strings to compare
string s1("This ");
string s2("That ");
for(int i = 0; i < s1.size() &&
i < s2.size(); i++)

// See if the string elements are the same:
if(s1[i] == s2[i])
cout << s1[i] << " " << i << endl;

// Use the string inequality operators
if(s1 != s2) {
cout << "Strings aren't the same:" << " ";
if(s1 > s2)
cout << "s1 is > s2" << endl;
else
cout << "s2 is > s1" << endl;
}
} ///:∼
```

下面是来自`CompStr.cpp`的输出:

```cpp
T 0
h 1
4
Strings aren't the same: s1 is > s2
```

重载比较运算符对于比较完整字符串和单个字符串字符元素都很有用。

注意在[清单 18-22](#list22) 中，比较运算符左右两边的参数类型都很灵活。为了提高效率，`string`类提供了重载操作符，用于直接比较字符串对象、引用文字和指向 C 风格字符串的指针，而不必创建临时的`string`对象。

***[清单 18-22](#_list22)*** 。说明字符串比较中的等价性

```cpp
//: C18:Equivalence.cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
  string s2("That"), s1("This");
  // The lvalue is a quoted literal
  // and the rvalue is a string:
  if("That" == s2)
    cout << "A match" << endl;
  // The left operand is a string and the right is
  // a pointer to a C-style null terminated string:
  if(s1 != s2.c_str())
    cout << "No match" << endl;
} ///:∼
```

`c_str()`函数返回一个`const char*`，它指向一个 *C 风格的空终止字符串*，等价于`string`对象的内容。当你想把一个字符串传递给一个标准的 C 函数，比如`atoi()`或者任何在`<cstring>`头中定义的函数时，这就很方便了。使用`c_str()`返回的值作为任何函数的非`const`参数都是错误的。

你不会在字符串的运算符中找到逻辑 not ( `!`)或逻辑比较运算符(`&&`和`||`)。(你也找不到重载版本的逐位 C 操作符`&`、`|`、`^`或`∼`。)string 类的重载非成员比较运算符仅限于对单个字符或字符组有明确应用的子集。

与非成员操作符集相比,`compare()`成员函数提供了更加复杂和精确的比较。它提供了重载版本进行比较

*   两个完整的字符串
*   任一字符串的一部分转换为完整的字符串
*   两个字符串的子集

清单 18-23 比较完整的字符串。

***[清单 18-23](#_list23)*** 。比较完整的字符串

```cpp
//: C18:Compare.cpp
// Demonstrates compare() and swap().
#include <cassert>
#include <string>
using namespace std;

int main() {
  string first("This");
  string second("That");
  assert(first.compare(first) == 0);
  assert(second.compare(second) == 0);
  // Which is lexically greater?
  assert(first.compare(second) > 0);
  assert(second.compare(first) < 0);
  first.swap(second);
  assert(first.compare(second) < 0);
  assert(second.compare(first) > 0);
}
///:∼
```

[清单 18-23](#list23) 中的`swap()`函数如其名所示:它交换其对象和参数的内容。要比较一个或两个字符串中的字符子集，可以添加参数来定义从哪里开始比较以及要考虑多少个字符。例如，您可以使用下面的`compare()`重载版本:

```cpp
s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos,s2NumberChars);
```

参见[清单 18-24](#list24) 中的示例。

***[清单 18-24](#_list24)*** 。比较一个或两个字符串中的字符子集

```cpp
//: C18:Compare2.cpp
// Illustrate overloaded compare().
#include <cassert>
#include <string>
using namespace std;

int main() {
  string first("This is a day that will live in infamy");
  string second("I don't believe that this is what "
                "I signed up for");
  // Compare "his is" in both strings:
  assert(first.compare(1, 7, second, 22, 7) == 0);
  // Compare "his is a" to "his is w":
  assert(first.compare(1, 9, second, 22, 9) < 0);
} ///:∼
Indexing with [] vs. at()
```

在迄今为止的例子中，我使用了 *C 风格的数组索引语法*来引用字符串中的单个字符。C++ 字符串为`s[n]`符号提供了另一种选择:成员`at()`。如果一切顺利，这两种索引机制在 C++ 中产生相同的结果；参见[清单 18-25](#list25) 。

***[清单 18-25](#_list25)*** 。演示使用[]和 at()的字符串索引之间的相似性

```cpp
//: C18:StringIndexing.cpp
#include <cassert>
#include <string>
using namespace std;

int main() {
  string s("1234");
  assert(s[1] == '2');
  assert(s.at(1) == '2');
} ///:∼
```

然而，在`[]`和`at()`之间有一个重要的区别。当你试图引用一个越界的数组元素时，`at()`会帮你抛出一个异常，而普通的`[]`下标语法会让你自行处理，如[清单 18-26](#list26) 所示。

***[清单 18-26](#_list26)*** 。演示使用[]和 at()进行字符串索引的区别

```cpp
//: C18:BadStringIndexing.cpp
#include <exception>
#include <iostream>
#include <string>
using namespace std;

int main() {
  string s("1234");
  // at() saves you by throwing an exception:
  try {
    s.at(5);
  } catch(exception& e) {
    cerr << e.what() << endl;
  }
} ///:∼
```

负责任的程序员不会使用错误的索引，但是如果你想要自动索引检查的好处，使用`at()`代替`[]`将会给你一个机会从对不存在的数组元素的引用中优雅地恢复。在我们的一个测试编译器上执行[清单 18-26](#list26) 给出了以下输出:

```cpp
invalid string position
```

成员`at()`抛出了一个类`out_of_range`的对象，这个类(最终)是从`std::exception`派生出来的。通过在异常处理程序中捕获该对象，您可以采取适当的补救措施，如重新计算违规的下标或增大数组。使用`string::operator[]()`无法提供这样的保护，并且与 c #中的`char`数组处理一样危险

字符串和字符特征

本章前面的程序`Find.cpp`和`NewFind.cpp`(分别为[清单 18-15](#list15) 和[清单 18-16](#list16) )引导我提出一个明显的问题:为什么不区分大小写的比较不是标准`string`类的一部分？答案提供了关于 C++ 字符串对象的真实性质的有趣背景。

考虑一下一个角色拥有“格”意味着什么书面希伯来语、波斯语和日本汉字不使用大写和小写的概念，所以对于这些语言来说，这个概念没有任何意义。似乎如果有一种方法可以将一些语言指定为“全大写”或“全小写”，我们就可以设计一个通用的解决方案。然而，一些使用“case”*概念的语言也用变音符号改变特定字符的含义，例如西班牙语中的变音符号、法语中的抑扬符号和德语中的变音符号。由于这个原因，任何试图变得全面的区分大小写的排序方案使用起来都非常复杂。*

虽然我们通常会把 C++ `string`当做一个类来对待，但事实真的不是这样。`string`类型是一个更一般的成分的专门化，即`basic_string< >`模板。观察`string`是如何在标准 C++ 头文件中声明的:

```cpp
typedef basic_string<char> string;
```

要理解 string 类的本质，请看`basic_string< >`模板:

```cpp
template<class charT, class traits = char_traits<charT>,
  class allocator = allocator<charT>> class basic_string;
```

现在，只需注意当用`char`实例化`basic_string`模板时，就创建了`string`类型。在`basic_string< >`模板声明里面，行

```cpp
class traits = char_traits<charT>,
```

告诉你从`basic_string< >`模板生成的类的行为是由基于模板`char_traits< >`的类指定的。因此，`basic_string< >`模板产生面向字符串的类，这些类操纵除了`char`以外的类型(例如宽字符)。为此，`char_traits< >`模板使用字符比较函数`eq()`(等于)、`ne()`(不等于)和`lt()`(小于)来控制各种字符集的内容和排序行为。`basic_string< >`字符串比较函数依赖于这些。

这就是为什么 string 类不包含不区分大小写的成员函数:这不在它的工作描述中。要改变字符串类处理字符比较的方式，您必须提供一个不同的`char_traits< >`模板，因为它定义了单个字符比较成员函数的行为。

您可以使用这些信息创建一个新类型的忽略大小写的`string`类。首先，您将定义一个新的不区分大小写的`char_traits< >`模板，它继承自现有的模板。接下来，您将只覆盖需要更改的成员，以使逐字符比较不区分大小写。(除了前面提到的三个词汇字符比较成员*、*之外，您还将为`char_traits`函数`find()`、*和*、`compare()`提供一个新的实现)。最后，您将`typedef`一个基于`basic_string`的新类，但是使用不区分大小写的`ichar_traits`模板作为它的第二个参数，如[清单 18-27](#list27) 所示。

***[清单 18-27](#_list27)*** 。发展 ichar_traits

```cpp
//: C18:ichar_traits.h
// Creating your own character traits.
#ifndef ICHAR_TRAITS_H
#define ICHAR_TRAITS_H
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstddef>
#include <ostream>
#include <string>
using std::allocator;
using std::basic_string;
using std::char_traits;
using std::ostream;
using std::size_t;
using std::string;
using std::toupper;
using std::tolower;

struct ichar_traits : char_traits<char> {
  // We'll only change character-by-
  // character comparison functions
  static bool eq(char c1st, char c2nd) {
    return toupper(c1st) == toupper(c2nd);
  }
  static bool ne(char c1st, char c2nd) {
    return !eq(c1st, c2nd);
  }
  static bool lt(char c1st, char c2nd) {
    return toupper(c1st) < toupper(c2nd);
  }
  static int
  compare(const char* str1, const char* str2, size_t n) {
    for(size_t i = 0; i < n; ++i) {
      if(str1 == 0)
        return -1;
      else if(str2 == 0)
        return 1;
      else if(tolower(*str1) < tolower(*str2))
        return -1;
      else if(tolower(*str1) > tolower(*str2))
        return 1;
      assert(tolower(*str1) == tolower(*str2));
      ++str1; ++str2; // Compare the other chars
    }
    return 0;
  }
  static const char*
  find(const char* s1, size_t n, char c) {
    while(n-- > 0)
      if(toupper(*s1) == toupper(c))
        return s1;
      else
        ++s1;
    return 0;
  }
};
typedef basic_string<char, ichar_traits> istring;
inline ostream& operator<<(ostream& os, const istring& s) {
  return os << string(s.c_str(), s.length());
}
#endif                // ICHAR_TRAITS_H ///:∼
```

您提供了一个名为`istring`的`typedef`,这样您的类在各方面都像一个普通的`string`,除了它会进行所有不考虑大小写的比较。为了方便起见，你还提供了一个重载的`operator<<()`，这样你就可以打印`istring` s。

***[清单 18-28](#_list28)*** 。实现清单 18-27 中的头文件

```cpp
//: C18:ICompare.cpp
#include <cassert>
#include <iostream>
#include "ichar_traits.h"    // To be INCLUDED from Header FILE
// above
using namespace std;

int main() {
  // The same letters except for case:
  istring first = "tHis";
  istring second = "ThIS";
  cout << first << endl;
  cout << second << endl;
  assert(first.compare(second) == 0);
  assert(first.find('h') == 1);
  assert(first.find('I') == 2);
  assert(first.find('x') == string::npos);
} ///:∼
```

这只是一个玩具的例子。为了使`istring`完全等同于`string`，你必须创建其他必要的函数来支持新的`istring`类型。

`<string>`头通过下面的`typedef`提供了一个宽字符串类:

```cpp
typedef basic_string<wchar_t> wstring;
```

宽字符串支持也在宽流(`wostream`代替`ostream`，也在`<iostream>`中定义)和头`<cwctype>`(T4 的宽字符版本)中显示出来。这与标准 C++ 库中的`char_traits`的`wchar_t`特殊化一起，允许你做`ichar_traits`的宽字符版本，如[清单 18-29](#list29) 所示。

***[清单 18-29](#_list29)*** 。开发 ichar_traits 的宽字符版本

```cpp
//: C18:iwchar_traits.h {-g++}
// Creating your own wide-character traits.
#ifndef IWCHAR_TRAITS_H
#define IWCHAR_TRAITS_H
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cwctype>
#include <ostream>
#include <string>
using std::allocator;
using std::basic_string;
using std::char_traits;
using std::size_t;
using std::towlower;
using std::towupper;
using std::wostream;
using std::wstring;

struct iwchar_traits : char_traits<wchar_t> {
  // We'll only change character-by-
  // character comparison functions
  static bool eq(wchar_t c1st, wchar_t c2nd) {
    return towupper(c1st) == towupper(c2nd);
  }
  static bool ne(wchar_t c1st, wchar_t c2nd) {
    return towupper(c1st) != towupper(c2nd);
  }
  static bool lt(wchar_t c1st, wchar_t c2nd) {
    return towupper(c1st) < towupper(c2nd);
  }
  static int compare(
    const wchar_t* str1, const wchar_t* str2, size_t n) {
    for(size_t i = 0; i < n; i++) {
      if(str1 == 0)
        return -1;
      else if(str2 == 0)
        return 1;
      else if(towlower(*str1) < towlower(*str2))
        return -1;
      else if(towlower(*str1) > towlower(*str2))
        return 1;
      assert(towlower(*str1) == towlower(*str2));
      ++str1; ++str2; // Compare the other wchar_ts
    }
    return 0;
  }
  static const wchar_t*
  find(const wchar_t* s1, size_t n, wchar_t c) {
    while(n-- > 0)
      if(towupper(*s1) == towupper(c))
        return s1;
      else
        ++s1;
    return 0;
  }
};
typedef basic_string<wchar_t, iwchar_traits> iwstring;
inline wostream& operator<<(wostream& os,
  const iwstring& s) {
  return os << wstring(s.c_str(), s.length());
}
#endif                // IWCHAR_TRAITS_H  ///:∼
```

如您所见，这主要是在源代码的适当位置放置一个“w”的练习。清单 18-30 包含了测试程序。

***[清单 18-30](#_list30)*** 。测试清单 18-29 中[开发的头文件](#list29)

```cpp
//: C18:IWCompare.cpp {-g++}
#include <cassert>
#include <iostream>
#include "iwchar_traits.h"   // To be INCLUDED from Header FILE
                             // above
using namespace std;

int main() {
  // The same letters except for case:
  iwstring wfirst = L"tHis";
  iwstring wsecond = L"ThIS";
  wcout << wfirst << endl;
  wcout << wsecond << endl;
  assert(wfirst.compare(wsecond) == 0);
  assert(wfirst.find('h') == 1);
  assert(wfirst.find('I') == 2);
  assert(wfirst.find('x') == wstring::npos);
} ///:∼
```

不幸的是，一些编译器仍然不提供对宽字符的强大支持。

字符串应用程序

如果您仔细阅读了本书中的示例代码，您会注意到注释中的某些标记围绕着代码。Python 程序使用它们将代码提取到文件中，并为构建代码建立 makefiles。例如，行首的双斜杠后跟冒号表示源文件的第一行。该行的其余部分包含描述文件的名称和位置的信息，以及是否应该只编译而不是完全构建到可执行文件中。例如，清单 18-30 中[的第一行包含字符串`C18:IWCompare.cpp`，表示文件`IWCompare.cpp`应该被提取到目录`C18`中。](#list30)

源文件的最后一行包含一个三重斜杠，后跟一个冒号和一个波浪号。如果第一行在冒号后有一个感叹号，则源代码的第一行和最后一行不会输出到文件中(这是针对纯数据文件的)。

![image](img/sq.jpg) **注意**如果你想知道为什么我避免向你展示这些标记，那是因为我不想破坏应用于书的文本的代码提取器

Python 程序不仅仅是提取代码。如果标记`{O}`跟在文件名后面，那么它的 makefile 条目将只用于编译文件，而不用于链接到可执行文件。为了将这样的文件与另一个源示例链接起来，目标可执行文件的源文件将包含一个`{L}`指令，如

```cpp
//{L} ../TestSuite/Test
```

本节将展示清单 18-31 中的一个程序，提取所有代码，以便你可以手动编译和检查。您可以使用该程序通过将文档文件保存为文本文件(姑且称之为`MFCTC++.txt`)并在 shell 命令行上执行如下内容来提取本书中的所有代码:

```cpp
C:> extractCode MFCTC++.txt /TheCode
```

该命令读取文本文件`MFCTC2.txt`，并将所有源代码文件写入顶层目录`/TheCode`下的子目录中。目录树将如下所示:

```cpp
TheCode/
   C0B/
   C01/
   C02/
   C18/
   C04/
   C05/
   C06/
   C07/
   C08/
   C09/
   C10/
   C11/
   TestSuite/
```

包含每章示例的源文件将位于相应的目录中。

***[清单 18-31](#_list31)*** 。说明书中所有源代码的提取

```cpp
//: C18:ExtractCode.cpp {-edg} {RunByHand}
// Extracts code from text.
#include <cassert>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

// Legacy non-standard C header for mkdir()
#if defined(__GNUC__) || defined(__MWERKS__)
#include <sys/stat.h>
#elif defined(__BORLANDC__) || defined(_MSC_VER) \
  || defined(__DMC__)
#include <direct.h>
#else
#error Compiler not supported
#endif
// Check to see if directory exists
// by attempting to open a new file
// for output within it.
bool exists(string fname) {
  size_t len = fname.length();
  if(fname[len-1] != '/' && fname[len-1] != '\\')
    fname.append("/");
  fname.append("000.tmp");
  ofstream outf(fname.c_str());
  bool existFlag = outf;
  if(outf) {
    outf.close();
    remove(fname.c_str());
  }
  return existFlag;
}

int main(int argc, char* argv[]) {
  // See if input file name provided
  if(argc == 1) {
    cerr << "usage: extractCode file [dir]" << endl;
    exit(EXIT_FAILURE);
  }
  // See if input file exists
  ifstream inf(argv[1]);
  if(!inf) {
    cerr << "error opening file: " << argv[1] << endl;
    exit(EXIT_FAILURE);
  }
  // Check for optional output directory
  string root("./");  // current is default
  if(argc == 3) {
    // See if output directory exists
    root = argv[2];
    if(!exists(root)) {
      cerr << "no such directory: " << root << endl;
      exit(EXIT_FAILURE);
    }
    size_t rootLen = root.length();
    if(root[rootLen-1] != '/' && root[rootLen-1] != '\\')
      root.append("/");
  }
  // Read input file line by line
  // checking for code delimiters
  string line;
  bool inCode = false;
  bool printDelims = true;
  ofstream outf;
  while(getline(inf, line)) {
    size_t findDelim = line.find("//" "/:∼");
    if(findDelim != string::npos) {
      // Output last line and close file
      if(!inCode) {
        cerr << "Lines out of order" << endl;
        exit(EXIT_FAILURE);
      }
      assert(outf);
      if(printDelims)
        outf << line << endl;
      outf.close();
      inCode = false;
      printDelims = true;
    } else {
      findDelim = line.find("//" ":");
      if(findDelim == 0) {
        // Check for '!' directive
        if(line[3] == '!') {
          printDelims = false;
          ++findDelim;                 // To skip '!' for next search
        }
        // Extract subdirectory name, if any
        size_t startOfSubdir =
          line.find_first_not_of(" \t", findDelim+3);
        findDelim = line.find(':', startOfSubdir);
        if(findDelim == string::npos) {
          cerr << "missing filename information\n" << endl;
          exit(EXIT_FAILURE);
        }
        string subdir;
        if(findDelim > startOfSubdir)
          subdir = line.substr(startOfSubdir,
                               findDelim - startOfSubdir);
        // Extract file name (better be one!)
        size_t startOfFile = findDelim + 1;
        size_t endOfFile =
          line.find_first_of(" \t", startOfFile);
        if(endOfFile == startOfFile) {
          cerr << "missing filename" << endl;
          exit(EXIT_FAILURE);
        }
        // We have all the pieces; build fullPath name
        string fullPath(root);
        if(subdir.length() > 0)
          fullPath.append(subdir).append("/");
        assert(fullPath[fullPath.length()-1] == '/');
        if(!exists(fullPath))
#if defined(__GNUC__) || defined(__MWERKS__)
          mkdir(fullPath.c_str(), 0);  // Create subdir
#else
          mkdir(fullPath.c_str());     // Create subdir
#endif
        fullPath.append(line.substr(startOfFile,
                        endOfFile - startOfFile));
        outf.open(fullPath.c_str());
        if(!outf) {
          cerr << "error opening " << fullPath
               << " for output" << endl;
          exit(EXIT_FAILURE);
        }
        inCode = true;
        cout << "Processing " << fullPath << endl;
        if(printDelims)
          outf << line << endl;
      }
      else if(inCode) {
        assert(outf);
        outf << line << endl;  // Output middle code line
      }
    }
  }
  exit(EXIT_SUCCESS);
} ///:∼
```

首先，您会注意到一些条件编译指令。在文件系统中创建目录的`mkdir()`函数是由 POSIX 标准在头文件`<sys/stat.h>`中定义的。不幸的是，许多编译器仍然使用不同的头，`<direct.h>`。`mkdir()`各自的签名也不同:POSIX 指定了两个参数，旧版本只有一个。由于这个原因，在程序的后面有更多的条件编译来选择对`mkdir()`的正确调用。在本书的例子中，我通常不使用条件编译，但是这个特殊的程序非常有用，不能不做一些额外的工作，因为你可以用它来提取所有的代码。

[清单 18-31](#list31) 中`ExtractCode.cpp`的`exists()`函数通过打开一个临时文件来测试一个目录是否存在。如果打开失败，则该目录不存在。你可以通过将文件名作为`char*`发送给`std::remove()`来删除一个文件。

主程序验证命令行参数，然后一次读取输入文件的一行，寻找特殊的源代码分隔符。布尔标志`inCode`表示程序在源文件的中间，所以应该输出几行。如果开始标记后面没有感叹号，`printDelims`标志将为真；否则不写第一行和最后一行。首先检查结束分隔符是很重要的，因为开始标记是一个子集，首先搜索开始标记在两种情况下都会返回成功的查找结果。如果您遇到结束标记，您将验证您正在处理一个源文件；否则，文本文件中分隔符的布局方式就有问题。如果`inCode`为真，则一切正常，您(可选)写下最后一行并关闭文件。找到开始标记后，解析目录和文件名部分并打开文件。本例中使用了以下与`string`相关的函数:`length()`、`append()`、`getline()`、`find()` ( *两个版本*)、`find_first_not_of()`、`substr()`、`find_first_of()`、`c_str()`，当然还有`operator<<()`。

审查会议

1.  C++ 字符串对象为开发人员提供了比他们的 *C* 同行更多的优势。在很大程度上，字符串类使得用字符指针引用字符串的*变得没有必要*。这个*消除了一整类软件缺陷*，这些缺陷是由于使用未初始化的和不正确赋值的指针而产生的。
2.  *C++ 字符串*动态透明地增加其内部数据存储空间，以适应字符串数据大小的增加。当字符串中的数据增长超过最初分配给它的内存限制时，字符串对象将进行内存管理调用，从*堆*中获取空间并返回空间。
3.  一致的分配方案可以防止内存泄漏，并且有可能比*“滚动自己的”内存管理*更加高效。
4.  string 类成员函数为创建、修改和搜索字符串提供了一套相当全面的工具。
5.  字符串比较*总是区分大小写的*，但是您可以通过将字符串数据复制到 *C 风格的空终止字符串并使用不区分大小写的字符串比较函数*，将字符串对象中保存的数据临时转换为单个大小写，或者通过创建不区分大小写的字符串类来覆盖用于创建`basic_string object`的字符特征，从而解决这个问题。****