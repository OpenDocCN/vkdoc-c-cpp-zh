# 九、指针和不安全代码

为了你的工作可以增加人类的幸福，你应该了解应用科学是不够的。对人类自身及其命运的关注必须始终构成所有技术努力的主要兴趣；关心劳动组织和商品分配等尚未解决的重大问题，以使我们头脑中的创造成为人类的幸福而不是诅咒。在你的图表和方程式中，永远不要忘记这一点。—阿尔伯特·爱因斯坦

从一开始，指针的使用就是 C 和最终 C++ 中最好和最差的(尽管许多人会认为 C++ 模板的深奥使用给了指针一个机会)。没有任何其他特性能够让您剥去编程语言的外衣，直达核心，也没有任何其他特性容易产生隐藏的错误，而这些错误可能会在几年内不被发现。

## C# 视图:是福是祸

C# 和。NET Framework 已经做了大量工作，使得在日常编程中不必使用指针。大多数常见的任务现在可以写成安全、可验证的代码。整个垃圾收集系统的设计考虑到了指针的废弃。引用类型，实现为分配的数据和指向。NET 中，在 C# 中显示为单个实体。句柄上的类型安全也被强制以避免指针问题。

可验证的代码更可取，因为它允许执行系统随时知道所有分配项的类型；它保证了所有类型的通用异常处理系统；它还提供了一个无泄漏、公共内存、托管内存分配系统。

尽管如此，C# 的设计者还是克制了自己，没有完全省略 C# 中的指针。

在使用`unsafe`关键字并使用`/unsafe`编译器选项编译的代码中，支持在 C# 中使用指针。另一方面，C++ 支持指针作为其主要编程模型的一部分。一个有趣的事实是，C# 默认情况下是可验证的，否则需要关键字或编译器选项来编译，而 C++ 默认情况下是不可验证的，使用编译器选项来编译可验证的。

### 指针:定义和警告

那么，到底什么是指针呢？指针是一种包含另一种数据类型地址的数据类型。这似乎没有什么害处，但是有一个问题:假设你设置一个指针指向一个类型的实例。这个想法是，你可以单独使用指针来引用实例。您可以将这个指针传递给其他方法，每个方法都在处理它认为是指向数据类型实例的指针；这通常很好。当数据超出范围，或者某个指针持有者以其他人意想不到的方式更改了它所指向的数据时，事情就开始出错了，因此，它不是指向堆栈上的数据实例，而是从一个完全不同的方法指向堆栈数据。那么，使用指针的方法实际上并没有写入数据实例；是写垃圾。

指针错误最常见的发生方式是指针和数据不同步；然后，指针和数据之间的契约，也就是指针指向有效数据的契约就被打破了。也许指针是旧的，或者数据不再存在，指针不指向任何地方。或者，指针可以作为访问数据的唯一方式开始，这在使用`new`时很常见，后来指针超出范围，对数据的访问就丢失了。如果没有垃圾收集机制，这将导致不可引用或孤立的数据对象以及内存泄漏。

我分享一个朋友的战争故事作为例子。

HOW TO BRING A 5,000,000-FAULT–TOLERANT SERVER TO ITS KNEES BY PAUL CAYLEY

我假设所有阅读这本书的人都知道什么是内存泄漏，并且可能实际上已经造成了一些。尽管聪明人尽了最大努力，内存泄漏仍然司空见惯。当我听说 Java 将终结内存泄漏时，我不知道是应该欣喜若狂，还是应该持怀疑态度。“怀疑”似乎是正确的答案，因为贸易出版物充斥着消除 Java 内存泄漏工具的广告。

为什么内存泄漏如此难以消除？有很多原因。我认为最大的一个问题是设计时的决策对下游是不透明的。内存分配和释放发生在不同的时间和不同的地方。架构师和设计师没有充分地预见到他们的代码将如何被使用。更糟糕的是，有些人甚至认为其他人会阅读他们的文档和行内注释，并正确理解其中隐含的智慧和警告。(当然，这假设程序员记录了他们的代码，这可能是也可能不是。)

当然，愚蠢和草率也可能是原因之一。程序员可能会忘记他们正在做什么或已经做了什么。因为有些人写的代码很差——最终可能会链接到您的代码，调用您的位，甚至成为您的位——内存可能会一字节一字节地泄漏！我们来看一些例子。

还记得微软 Outlook 吗？Outlook 的早期版本每小时会泄漏大约 100KB 的内存，就在那里。因此，如果你习惯于连续几周打开电脑，你必须每隔几天退出并重新启动 Outlook。如果你不这样做，大约一周后，你的系统会变得缓慢和不可预测。

不幸的是，大多数程序员都希望事情能够正常运行，错误检查有时是不完整的或者完全被忽略了。在`malloc()`空手返回后，一些程序可能继续前进，丢弃位并产生错误。该场景中的步骤如下:

Outlook leaks memory to the point that other programs and/or the OS become starved.   Calls to `malloc()` start failing in new and unusual places.   Even though memory is freed by exiting Outlook, things are no longer stable.   You bring up the Task Manager to kill the lingering Outlook Messaging Application Programming Interface (MAPI) pump, but things are iffy still.   You rename `outlook.exe` to `lookout.exe` as a reminder and reboot.  

没什么大不了的，您必须重新启动您的工作站——当然，除非您处于一个终端服务器环境中，在这个环境中，一个单独的机器托管许多用户会话。然后，您还可以享受 Outlook 的多个实例和谐地一起工作来泄漏大量内存的乐趣。当你重新启动时，每个人都必须重新开始——快乐，快乐，快乐，快乐！

让我们看看长时间运行流程的另一个场景——系统状态监视器。在这个场景中，您有一个支持关键任务应用程序的大型容错服务器。你不仅要为一个装有多个电源、RAID 驱动器、冗余网络等的盒子支付 50 万美元，还要为一些系统监控工具支付 5 万美元。这个系统将在未来十年全天候运行。然后，发布了操作系统的服务包，并公开了新的代码路径。监控应用程序运行良好，不会泄漏任何内存。不幸的是，检索 OS 状态更新的 OS API 确实会泄漏内存，所以每次通过这个 API 调用时，都会返回一个记录集，并且会丢失 50 字节或更多的内存。大约 3 个月后，监控软件将完成它的工作，重新启动防弹镀金服务器。

简而言之，内存泄漏是邪恶的。电脑不错。但是没有恶就没有善吗？

### 有效的目标和语法

在 C# 中，指针可以设置为值类型的地址或另一个指针。此外，指针可以自由地转换为其他指针。

由于托管堆中的对象被垃圾收集器以看似任意的时间间隔移动。NET 语言必须限制指向托管堆上对象的指针。C# 指针主要设计用于指针或值类型，它们驻留在堆栈上。C++/CLI 和 C# 都允许您临时固定对象在托管堆上的位置，尽管它们使用不同的语法。阻塞垃圾收集机制，即使是短暂的阻塞，看起来也很危险，但是对于调用本机 API(称为 InterOp)来说，这是非常有用的。我们将在第 19 章和第 20 章中再次讨论这些话题。

### 常见指针运算符

表 [9-1](#Tab1) 中列出了 C# 指针操作符。所有这些运算符都存在，并且在 C++ 中具有相同的定义和用法。

表 9-1。

Common Pointer Operators in C++ and C#

<colgroup><col> <col></colgroup> 
| 操作员 | 意义 |
| --- | --- |
| `&` | 取一个值的地址。这是 C++ 命名法中运算符的地址。 |
| `*` | 获取指针或引用指向的值。这是 C++ 中的解引用运算符。当你使用它的时候，你正在解引用一个指针。 |
| `->` | `ptr->`是`(*ptr)`的别名。`ptr->`是会员接入运营商。当`ptr`指向一个 C# `struct`或者值类型的实例，并且你想要访问该结构的一个成员时，这是一个方便的快捷方式。 |

### 指针用法示例

下面是一些在 C# 和 C++/CLI 中使用指针的简短例子。

声明一个指向整数的指针:

`int *ptr;`

将整数的地址分配给整数指针:

`int i;`

`ptr = &i`

通过取消对指针的引用，为原始整数赋值:

`*ptr = 3;`

此时，整数`i`被赋予`3`的值。现在让我们将这个功能包装在一个程序中并尝试一下。

### C# 中可验证的代码和指针用法

由于指针的使用是不可验证的，C# 将指针操作符的使用限制在标有`unsafe`关键字的块中。此外，编译时必须指定`/unsafe`命令行选项。这可以直接从命令行完成，也可以通过在 Visual Studio IDE 的“项目属性”对话框的“生成”选项卡中选中相应的框来完成。例如，看看下面这个程序，叫做`test.cs`:

`class R`

`{`

`static void Main()`

`{`

`int i;`

`unsafe`

`{`

`int *ptr = &i;`

`*ptr = 3;`

`}`

`System.Console.WriteLine(i);`

`}`

`}`

要编译和运行该程序，请执行以下操作:`/nologo`选项取消版权信息:

`csc /unsafe /nologo test.cs`

`test`

您应该会收到以下输出:

`3`

如您所见，`/unsafe`命令选项用于指示编译器接受`unsafe`关键字的用法。如果您忽略了使用`/unsafe`选项进行编译，您会看到下面的诊断，如果编译器正在工作的话:

`test.cs(12,9): error CS0227: Unsafe code may only appear if compiling with /unsafe`

### 编写不安全代码的副作用

编写不安全的代码有一些有趣的副作用。因为可以使用指针间接初始化变量，所以使用不安全代码会影响编译器检测未初始化变量的能力。例如，考虑下面的 C# 片段:

`int i;`

`System.Console.WriteLine(i);`

如果您在程序的上下文中编译它，您会看到以下诊断信息:

`test.cs(9,29): error CS0165: Use of unassigned local variable 'i'`

如果您将此代码包装在一个不安全的块中，并添加了一个指针引用，如下所示:

`unsafe`

`{`

`int i;`

`int *p = &i;`

`System.Console.WriteLine(i);`

`}`

即使变量`i`仍未初始化，编译器也不会进行诊断。

如果您随后执行这个块，您会看到一个未初始化变量的默认值:

`C:\>test`

`0`

在这种情况下，这没什么大不了的，但是您可以看到使用不安全的块和指针是如何限制编译器帮助您编写可靠代码的能力的。

### C++ 中的指针用法

C++ 指针类似于 C# 指针，有许多相同的限制。基本语法是相同的，考虑到语言的历史和发展，这并不奇怪。有一些重要的区别，所有这些都证明了 C++ 的强大:

*   C++ 不要求在源代码中使用`unsafe`关键字。
*   C++ 有四个编译选项；C# 有安全和不安全之分。
*   C++ 允许指针指向数组。
*   C++ 允许指向本地函数的指针。
*   C++ 允许指针指向独立于实例的成员。
*   C++ 允许在同一个声明中混合和组合指向数组的指针、指向指针的指针、指向成员的指针和指向本机函数的指针。

因为本章的目标是介绍指针和相关概念，所以我们将高级方面的讨论推迟到第 18 章和第 19 章进行。毕竟，在你准备好之前，你不想花太多时间去尝试解码一个像下面这样的有效 C++ 声明！

`void (**(*(*p)(int, char))[])(int);`

### C++ 中的可验证代码

`/clr`开关决定了如何编译 C++ 代码以适应 CLR。它规定了编译器在禁止指针和非托管类型等构造时需要有多严格，以及确定您的代码是否被编译为在中的 CLR 下运行。或者作为独立的本机可执行文件。

以下是用 C++ 编译代码的几种方法:

*   产生一个仅可验证的 IL 输出文件，并且只能用于托管类型和托管代码。
*   `/clr:pure`生成一个仅包含 IL 的输出文件(没有本机可执行代码),并且只能用于托管和本机类型以及托管代码。
*   产生本地和 IL 文件的混合。允许托管和本机类型以及托管代码和本机代码。
*   `<default>`表示没有指定选项。该程序为本机执行而编译。

此外，为了与 Visual C++ 2002 和 2003 兼容，还提供了另外两个选项:

*   `/clr:oldSyntax`接受 Visual C++ 2002 和 2003 中的托管扩展语法。
*   `/clr:initialAppDomain`表示使用 Visual C++ 2002 的初始`AppDomain` [<sup>1</sup>](#Fn1) 行为。

一般来说，C# 默认生成可验证的代码，但是可以使用指针和使用`unsafe`关键字或命令行选项的不可验证的代码。C++ 希望您在命令行上定义目标可执行文件，因为 C# 和 C++ 倾向于反映不同的范例，而不是像 C# 那样，通过可选的优化或调整来反映可验证的代码。在 C++ 中，与 C# 编译直接对应的是`/clr:safe`，但是这种模型不允许您利用 C++ 的大部分真正功能。出于这个原因，我一般更喜欢使用`/clr:pure`，并根据需要切换到`/clr:safe`或`/clr`。

现在，让我们采用与 C# 示例完全相同的指针用法，并将其转换为 C++/CLI:

`ref struct R`

`{`

`static void Main()`

`{`

`int i;`

`int *ptr = &i;`

`*ptr = 3;`

`System::Console::WriteLine(i);`

`}`

`};`

`void main() {R::Main();}`

如您所见，程序中 C++ 指针的用法与 C# 版本相同。因为指针是不可验证的，或者是不安全的，我们应该把它编译成`pure`。输入以下行:

`cl /clr:pure test.cpp`

这编译成一个 CLR 可执行文件，将`3`写入控制台，就像 C# 版本一样。

另一方面，如果您试图将其编译为`safe`，您会看到以下内容(`/nologo`选项隐藏了版权信息):

`cl /clr:safe /nologo test.cpp`

`test.cpp`

`test.cpp(6) : error C4956: 'int *' : this type is not verifiable`

如果您试图在没有任何形式的`clr`标志的情况下编译这段代码，您会收到一条更加深奥的消息:

`cl /nologo test.cpp`

`test.cpp`

`test.cpp(2) : error C2143: syntax error : missing ';' before '<class-head>'`

`test.cpp(2) : error C4430: missing type specifier - int assumed. Note: C++ does not`

`support default-int`

`test.cpp(8) : error C2653: 'System' : is not a class or namespace name`

`test.cpp(8) : error C3861: 'WriteLine': identifier not found`

如果不指定`/clr`选项，编译器会将这段代码编译为本机 C++。在原生 C++ 中，`ref`不是一个关键字，所以编译器不知道它指示了什么特殊的东西，你得到的东西遵循旧的计算机科学规则，即编译器垃圾进，垃圾出。当编译器似乎抛出看似无意义的诊断时，在 IDE 或 makefile 中仔细检查`clr`标志的设置总是一个好主意。

BEHIND THE SCENES

在前面的例子中，理解解析器在做什么是很有启发性的。当它看到关键字`class`时，它意识到，因为类只能在某些地方声明，所以之前的类应该已经完成了，所以它输出下面的诊断:

`test.cpp(2) : error C2143: syntax error : missing ';' before '<class-head>'`

注意，这发生在第 2 行，因为解析器在对表达式作出判断之前继续到左花括号。

`error C4430: missing type specifier - int assumed. Note: C++ does not`

`support default-int`

下一个错误消息是传统 C 语言的遗留问题，它允许您在不指定类型的情况下声明变量或函数。默认情况下，该类型将被标识为`int`。毫不奇怪，这种行为被称为“T1”。

因此，在传统的 C # 中，以下声明是有效的:

`ref;`

这一行声明`ref`是一个`int`类型的全局变量。

### C++ 句柄

在 CLR 中，引用类型分为两个实体:托管堆上的对象和这些对象的句柄。C# 模糊了这种划分，并提供了允许您像处理对象本身一样处理句柄的语法。另一方面，C++/CLI 将句柄视为指向托管堆上的对象的指针。这样做时，它使用了本章中概述的指针语法。

让我们在这里回顾一下语法。首先让我们声明一个引用类型和一个值类型:

`//declare a reference type`

`ref struct R { int i; };`

`//declare a value type`

`value struct V { int j; };`

现在让我们实例化它们(在方法的上下文中):

`V v;`

`R ^ r = gcnew R();`

变量`v`已经被分配到堆栈上。变量`r`也被分配在堆栈上，它是一个句柄，或者托管指针，指向一个分配在托管堆上的`R`对象。

假设现在我们想要访问`V`中的字段变量`j`。我们将使用`.`字段访问操作符并编写如下代码:

`v.j = 3;`

在第 3 章的[中，我展示了对于引用类型，你需要使用`->`成员访问操作符来代替。之前我也提到过`ptr->`是`(*ptr)`的别名。让我们看看这些是如何组合在一起的。](03.html)

使用指针语法将字段`i`设置为`3`:

`r->i = 3;`

常规语法中的等效语法如下:

`(*r).i = 3;`

在这种情况下，变量`r`位于堆栈上，是托管堆上的`R`对象的句柄或指针:

`(*r)`

这个表达式表明指针应该被解引用，这意味着“转到由变量`r`指向的对象。”换句话说，这个表达式返回托管堆上的实际对象。添加`.i`访问字段本身，这与 C# 或 C++ 中的堆栈分配值类型相同。

当然，使用`->`操作符更简单，但是了解语法很重要。

### C++/CLI 地址运算符

我们已经知道了`&`操作符用于获取值类型或指针类型的地址。具体来说，在 C# 中，这意味着它可以获取堆栈上变量的地址。如果在 C++ 中使用这个操作符获取一个不在堆栈上的变量的地址，就会得到一个诊断。为了测试这一点，我们需要使用表达式`(*r)`来获取托管堆上的一个对象。让我们用 operator 的地址来确定它的地址，看看会发生什么:

`&(*r);`

如果您尝试编译它，您会看到以下诊断信息:

`C:\>cl /clr:pure /nologo test.cpp`

`test.cpp`

`test.cpp(12) : error C3072: operator '&' cannot be applied to an instance of a`

`ref class`

`use the unary '%' operator to convert an instance of a ref class to a`

`handle type`

错误 3072 是这里的重要诊断，因为它指出操作符的地址不能用于托管堆中的对象。

为了允许您获取托管堆上对象的地址，C++/CLI 引入了`%`操作符。这个操作符相当于托管堆上对象的`&`操作符。

总之，表 [9-2](#Tab2) 显示了 C++/CLI 中本机指针和托管指针之间的对应关系。

表 9-2。

Native to Managed-Pointer Operator Correspondence in C++/CLI

<colgroup><col> <col> <col></colgroup> 
| 操作员 | 堆栈/本机堆 | 托管堆 |
| --- | --- | --- |
| 地址 | `&` | `%` |
| 指针声明 | `*` | `^` |
| 解除…的关联 | `*` | `*` |
| 例子 | `value struct V{ int i; };` | `ref struct R{ int i; };` |
|   | `V v;` | `R ^r1 = gcnew R();` |
|   | `V * pV = &v;` | `R ^r2 = %(*r1);` |
|   | `v.i;` | `R r;` |
|   | `pV->i;` | `R ^r3 = %r;` |
|   |   | `r1->i;` |
|   |   | `(*r2).i;` |

如您所见，根据目标是在托管堆、本机堆还是堆栈上，有不同的地址和指针声明操作符语法。另一方面，只有一个解引用操作符，因为解引用指针是明确的。在任何情况下，您最终都会得到一个表示堆栈或托管堆上的对象的表达式。

### 复杂的例子

下面是一个更复杂的例子，展示了如何获取指针的地址。注意，由于指针和句柄是在堆栈上分配的，我们在两种情况下都使用了`&`地址操作符:

`static void Main()`

`{`

`V v;`

`V *pV = &v;`

`R ^ r;`

`R ^ * phR = &r;`

`}`

这个例子为`phR`提供了以下有趣且更高级的声明:

`R ^ * phR`

在这种情况下，`phR`是一个指针，指向一个`R`对象的句柄。这一开始可能有点奇怪，但是你会慢慢习惯的。请注意以下详细信息:

*   `*phR`是一个`R^`指针。
*   `**phR`是一个`R`对象。

这是另一个有趣的构想:

`V ^hV = %v;`

这是正确的吗？它说，“给我一个驻留在托管堆上的值类型的句柄。”但是值类型不是活在栈上吗？这应该不会编译吧？事实证明，这可以很好地编译。为什么呢？原来，值类型`V`的装箱版本是在托管堆上自动创建的。然后，表达式用该对象的句柄设置变量`hV`。

### 噩梦

由于在 C++ 中类型是递归定义的，所以除了 CLR 的限制之外，对您可以创建的噩梦般的表达式的类型没有什么限制。

例如，下面的有效表达式将变量`p`声明为一个指针，该指针指向一个采用`int`和`char`的函数，并返回一个指针数组，该数组指向采用`int`并将句柄返回给`R`的函数的指针:

`R ^ (**(*(*p)(int, char))[])(int);`

一般来说，这是你阅读复杂声明的方式:从中间的变量名开始。在这种情况下，变量名是`p`。从那里，向右看。如果你看到一个左括号，它就是一个函数。如果你看到一个方括号，它就是一个数组。如果您看到分号、右括号或什么都没有，请向左看。如果你看到一个`^`，那就是手柄。如果你看到一个`*`，那就是一个指针。从这里开始，继续向外扩展，注意圆括号，跳过已经使用过的标记。显然，这是一个说起来容易做起来难的算法。

复杂声明的好处是唯一的限制是你的想象力。

## 摘要

在这一章中，我向你介绍了指针和不安全代码，希望不会吓到你，让你放弃编程，搬到南极洲去。如果我失败了，一定要给我寄张明信片——最好是有企鹅或狗的明信片。

你现在可能不是指针方面的专家，但是考虑到本章中的贯穿和例子，你至少会知道如何识别它们以及在简单的情况下应用它们。在下一章，我们将看看 C++/CLI 中的属性和事件。

Footnotes [1](#Fn1_source)

有关`clr:initialAppDomain`的详细信息，请参考 Visual C++ 文档。