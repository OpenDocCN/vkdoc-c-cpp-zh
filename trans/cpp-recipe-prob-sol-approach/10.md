第十章

![image](images/frontdot.jpg)

记忆

在现代计算机中，内存是一种非常重要的资源。你的程序所操作的所有数据都会在某个时候存储到 ram 中，供处理器在以后需要完成你的部分算法时检索。

因此，对于 C++程序员来说，理解程序如何以及何时使用不同类型的内存是至关重要的。本章介绍了三种不同的内存空间，如何利用它们，以及每种空间对程序性能的潜在影响。

10-1.使用静态内存

问题

您有一个希望能够在代码中的任何地方访问的对象。

解决办法

静态内存可以被认为是全局变量。程序的任何部分都可以随时访问这些变量及其值。

它是如何工作的

您使用的编译器会自动为您创建的任何全局变量在静态内存空间中添加内存。静态变量的地址通常可以在可执行文件的地址空间中找到，因此可以被程序的任何部分随时访问。清单 10-1 显示了一个无符号整数全局变量的例子。

[***清单 10-1***](#_list1) 。一个全局变量

```
#include <iostream>
using namespace std;

unsigned int counter{ 0 };

void IncreaseCounter()
{
    counter += 10;
    cout << "counter is " << counter << endl;
}

int main(int argc, char* argv[])
{
    counter += 5;
    cout << "counter is " << counter << endl;

    IncreaseCounter();

    return 0;
}
```

[清单 10-1](#list1) 中的变量`counter`是用全局范围声明的。结果是可以在程序中全局访问该变量。您可以在`main`函数和`IncreaseCounter`函数中看到这一点。这两个函数都增加了同一个全局`counter`变量的值。图 10-1 所示的结果证实了这一点。

![9781484201589_Fig10-01.jpg](images/9781484201589_Fig10-01.jpg)

[图 10-1](#_Fig1) 。显示更改全局变量的结果的输出

全局变量在某些情况下可能是有用的，但在其他情况下可能会导致许多问题。配方 9-4 展示了使用静态类成员变量来创建一个`Singleton`对象。静态成员也是一种全局变量，因此可以从程序中的任何地方访问。静态变量的一个普遍问题是它们的创建顺序。C++标准不保证静态变量会以给定的顺序初始化。这可能导致使用许多依赖全局变量的程序遇到问题，并由于意外的初始化顺序而崩溃。全局变量还会导致多线程编程中的许多问题，因为多个线程可以同时访问静态地址空间，并产生意想不到的结果。通常建议您将全局变量的使用保持在最低限度。

10-2.使用堆栈内存

问题

您需要内存来存储临时变量，以便在函数中工作。

解决办法

C++程序可以使用一个增长和收缩的堆栈来为局部变量提供临时空间。

它是如何工作的

因为 C++程序中的所有变量都需要内存支持，所以会为函数中定义的变量动态创建临时空间。这是使用堆栈实现的。当调用一个函数时，编译器会添加机器码，分配足够的堆栈空间来存储函数所需的所有变量。

使用两个名为`esp`的寄存器(在基于 x86 的 CPU 上)来操作堆栈，`ebp. esp`是堆栈指针，`ebp`是基址指针。基址指针用于存储前一个堆栈帧的地址。这允许当前函数在执行结束时返回到正确的堆栈。`esp`寄存器用于存储堆栈的当前顶部；这允许在当前函数调用另一个函数时更新`ebp`。

在程序栈上为局部变量创建足够空间的过程如[清单 10-2](#list2) 所示。

[***清单 10-2***](#_list2) 。显示创建 20 字节堆栈帧的 x86 程序集

```
push ebp
mov ebp, esp
sub esp 20
```

清单 10-2 中的三行 x86 汇编语言展示了在 x86 中创建堆栈框架的基础。首先，`push`指令用于将当前基址指针移动到堆栈上。`push`指令将`esp`向下移动足够远，以存储`ebp`的值，然后将该值移动到堆栈上。然后将`esp`的当前值移入`ebp`，将基址指针向上移动到当前堆栈帧的开头。最后一条指令从`esp`中减去堆栈帧的大小。由此可以清楚地看出，基于 x86 的计算机中的堆栈向下增长到 0。

然后，程序使用从基指针的偏移量来访问堆栈中的每个变量。在[图 10-2](#Fig2) 所示的 Visual Studio 反汇编中可以看到这三行。

![9781484201589_Fig10-02.jpg](images/9781484201589_Fig10-02.jpg)

[图 10-2](#_Fig2) 。从 x86 程序反汇编，显示堆栈框架的创建

清单 10-3 显示了图 10-2 中[的拆卸](#Fig2)的代码。

[***清单 10-3***](#_list3) 。用于查看反汇编的简单程序

```
#include <iostream>

using namespace std;

void Function()
{
    int a{ 0 };

    cout << a;
}

int main(int argc, char* argv[])
{
    Function();

    return 0;
}
```

您创建的所有局部变量都分配在堆栈上。类变量的构造函数在它们被创建时被调用，它们的析构函数在栈被销毁时被调用。清单 10-4 展示了一个简单的程序，它由一个`class` 和一个构造函数和一个析构函数组成。

***[清单 10-4](#_list4) 。**堆栈上的*类变量

```
#include <iostream>

using namespace std;

class MyClass
{
public:
    MyClass()
    {
        cout << "Constructor called!" << endl;
    }

    ~MyClass()
    {
        cout << "Destructor called!" << endl;
    }
};

int main(int argc, char* argv[])
{
    MyClass myClass;

    cout << "Function body!" << endl;

    return 0;
}
```

清单 10-4 中[变量`myClass`的构造函数在初始化时被调用。执行函数体的其余部分，当变量超出范围时，调用`class`析构函数。`myClass`变量在`return`语句后超出范围。发生这种情况是因为可能需要函数中的局部变量来计算函数返回值。你可以在](#list4)[图 10-3](#Fig3) 中看到[清单 10-4](#list4) 的输出。

![9781484201589_Fig10-03.jpg](images/9781484201589_Fig10-03.jpg)

[图 10-3](#_Fig3) 。运行清单 10-4 中代码的输出

清单 10-4 中的代码展示了函数中`class`变量的创建和销毁。在 C++中也可以控制堆栈框架的创建。您可以使用花括号在现有范围内创建一个新的范围。清单 10-5 创建了几个不同的作用域，每个作用域都有自己的局部变量。

[***清单 10-5***](#_list5) 。创建多个范围

```
#include <iostream>

using namespace std;

class MyClass
{
private:
    static int m_Count;
    int m_Instance{ -1 };

public:
    MyClass()
        : m_Instance{m_Count++}
    {
        cout << "Constructor called on " << m_Instance << endl;
    }

    ~MyClass()
    {
        cout << "Destructor called on " << m_Instance << endl;
    }
};

int MyClass::m_Count{ 0 };

int main(int argc, char* argv[])
{
    MyClass myClass1;

    {
        MyClass myClass2;

        {
            MyClass myClass3;
        }
    }

    return 0;
}
```

[清单 10-5](#list5) 中的代码展示了在一个函数中使用花括号创建多个堆栈框架。类`MyClass`包含一个`static`变量`m_Count`，用于跟踪不同的实例。每次创建一个新实例时，这个变量都会后递增，前递增的值存储在`m_Instance`中。每次关闭作用域时，都会对局部变量调用析构函数。结果如[图 10-4](#Fig4) 所示。

![9781484201589_Fig10-04.jpg](images/9781484201589_Fig10-04.jpg)

[图 10-4](#_Fig4) 。显示具有多个范围的对象的销毁顺序的输出

10-3.使用堆内存

问题

您需要创建一个比单个本地作用域更长的大型内存池。

解决办法

C++提供了`new`和`delete`操作符，允许您管理大型动态分配内存池。

它是如何工作的

动态分配内存对于许多长时间运行的程序来说非常重要。对于允许用户生成自己的内容或从文件中加载资源的程序来说，这是必不可少的。如果不使用动态分配的内存，通常很难(如果不是不可能的话)为用于流式视频或社交媒体内容的程序(如 web 浏览器)提供足够的内存，因为您无法在创建程序时确定内存需求。

您可以使用 C++ `new`和`delete`操作符在一个通常称为*堆*的地址空间中分配动态内存。`new`操作符返回一个指针，指向动态分配的内存，该内存足够大，可以存储正在创建的变量类型。清单 10-6 展示了如何使用`new`和`delete`操作符。

[***清单 10-6***](#_list6) 。使用`new`和`delete`

```
#include <iostream>

using namespace std;

int main(int argc, char* argv[])
{
    int* pInt{ new int };
    *pInt = 100;

    cout << hex << "The address at pInt is " << pInt << endl;
    cout << dec << "The value at pInt is " << *pInt << endl;

    delete pInt;
    pInt = nullptr;

    return 0;
}
```

这段代码使用`new`操作符分配足够的内存来存储单个`int`变量。指针从`new`返回并存储在变量`pInt`中。返回的内存是未初始化的，通常在创建时初始化内存是个好主意。你可以在`main`中看到这一点，这里使用指针解引用操作符将`pInt`指向的内存初始化为 100。

一旦从堆中分配了内存，您就有责任确保它被正确地返回给操作系统。否则会导致内存泄漏。内存泄漏会给用户带来问题，通常会导致计算机性能下降、内存碎片，在严重的情况下，还会导致计算机因内存不足而崩溃。

使用`delete`操作符将堆内存返回给操作系统。这个操作符告诉系统，您不再需要从最初调用`new`返回的所有内存。在调用了`delete`之后，你的程序不应该再试图使用`new`返回的内存。这样做会导致未定义的行为，这通常会导致程序崩溃。由于访问被释放的内存而导致的崩溃通常很难发现，因为它们出现在你无法以任何方式链接到违规代码的地方。通过将任何指向内存的指针设置为`nullptr`，可以确保你的程序不会访问被删除的内存。

清单 10-6 的[输出如图](#list6)[图 10-5](#Fig5) 所示。

![9781484201589_Fig10-05.jpg](images/9781484201589_Fig10-05.jpg)

[图 10-5](#_Fig5) 。来自[清单 10-6](#list6) 的输出显示了动态分配内存中存储的地址和值

清单 10-6 中的`new`和`delete`操作符用于分配单个对象。还有`new`和`delete`数组操作符，用于分配同一个对象的倍数。清单 10-7 显示了数组`new`和`delete`操作符的作用。

[***清单 10-7***](#_list7) 。数组`new`和`delete`运算符

```
#include <iostream>

using namespace std;

class MyClass
{
private:
    int m_Number{ 0 };

public:
    MyClass() = default;
    ~MyClass()
    {
        cout << "Destroying " << m_Number << endl;
    }

    void operator=(const int value)
    {
        m_Number = value;
    }
};

int main(int argc, char* argv[])
{
    const unsigned int NUM_ELEMENTS{ 5 };
    MyClass* pObjects{ new MyClass[NUM_ELEMENTS] };
    pObjects[0] = 100;
    pObjects[1] = 45;
    pObjects[2] = 31;
    pObjects[3] = 90;
    pObjects[4] = 58;

    delete[] pObjects;
    pObjects = nullptr;

    return 0;
}
```

清单 10-7 中的代码创建了一个对象数组。`MyClass`类由一个重载的赋值操作符和一个析构函数组成，前者初始化创建的对象，后者显示数组中元素的销毁顺序。在对象数组上使用标准的`delete`操作符会给你的程序带来各种问题，因为标准的`delete`操作符只在数组的第一个元素上调用类析构函数。如果您的类分配了自己的内存，那么数组中的每个后续对象都会泄漏它们的内存。使用`delete`数组操作符可以确保数组中的每个析构函数都被调用。你可以看到数组中元素的每个析构函数都在图 10-6 中被调用。

![9781484201589_Fig10-06.jpg](images/9781484201589_Fig10-06.jpg)

[图 10-6](#_Fig6) 。使用数组运算符`delete`时，输出显示每个析构函数都已被调用

10-4.使用自动共享内存

问题

您有一个可以由多个具有不同生命周期的系统共享的对象。

解决办法

C++提供了`shared_ptr`模板，可以在不再需要内存时自动删除它。

它是如何工作的

C++中动态分配的内存必须由程序员删除。这意味着你有责任确保你的程序在任何时候都像用户期望的那样运行。C++提供了`shared_ptr`模板，它跟踪你的程序中有多少地方共享对同一个内存的访问，并且可以在不再需要这个内存时删除它。清单 10-8 展示了如何创建一个共享指针。

[***清单 10-8***](#_list8) 。创建共享指针

```
#include <iostream>
#include <memory>

using namespace std;

class MyClass
{
private:
    int m_Number{ 0 };

public:
    MyClass(int value)
        : m_Number{ value }
    {

    }

    ~MyClass()
    {
        cout << "Destroying " << m_Number << endl;
    }

    void operator=(const int value)
    {
        m_Number = value;
    }

    int GetNumber() const
    {
        return m_Number;
    }
};

using SharedMyClass = shared_ptr< MyClass >;

int main(int argc, char* argv[])
{
    SharedMyClass sharedMyClass{ new MyClass(10) };

    return 0;
}
```

这段代码包含一个类`MyClass`，它有一个私有的整数成员变量。还有一个类型别名用来表示一个`shared_ptr`到一个`MyClass`对象。从长远来看，这种类型别名用于使编写代码变得更容易和更易维护。`shared_ptr`模板本身接受一个对象类型的参数，您希望在您的程序中共享这个对象。在这种情况下，您想要共享类型为`MyClass`的动态对象。

在`main`函数的第一行创建了一个`SharedMyClass`的实例。这个实例用一个动态分配的`MyClass`对象初始化。`MyClass`对象本身用值 10 初始化。在`main`的主体中唯一的其他代码是`return`语句。尽管如此，[图 10-7](#Fig7) 显示`MyClass`的析构函数已经在`sharedMyClass`T10 中存储的对象上被调用。

![9781484201589_Fig10-07.jpg](images/9781484201589_Fig10-07.jpg)

[图 10-7](#_Fig7) 。输出显示`MyClass`析构函数已经在[清单 10-8](#list8) 中被调用

一旦`shared_ptr`的最后一个实例超出范围，`shared_ptr`模板会自动调用它所包装的内存中的`delete`。在这种情况下，`main`函数中只有一个`shared_ptr`；因此`MyClass`对象被删除，它的析构函数在函数返回语句执行后被调用。

[清单 10-9](#list9) 展示了如何使用`shared_ptr`将共享内存的所有权从一个函数转移到另一个函数，并且仍然保持这个自动清理代码。

[***清单 10-9***](#_list9) 。在函数间转移动态内存

```
#include <iostream>
#include <memory>

using namespace std;

class MyClass
{
private:
    int m_Number{ 0 };

public:
    MyClass(int value)
        : m_Number{ value }
    {

    }

    ~MyClass()
    {
        cout << "Destroying " << m_Number << endl;
    }

    void operator=(const int value)
    {
        m_Number = value;
    }

    int GetNumber() const
    {
        return m_Number;
    }
};

using SharedMyClass = shared_ptr< MyClass >;

void ChangeSharedValue(SharedMyClass sharedMyClass)
{
    if (sharedMyClass != nullptr)
    {
        *sharedMyClass = 100;
    }
}

int main(int argc, char* argv[])
{
    SharedMyClass sharedMyClass{ new MyClass(10) };

    ChangeSharedValue(sharedMyClass);

    return 0;
}
```

[清单 10-9](#list9) 创建一个`SharedMyClass`实例，指向一个用值 10 初始化的`MyClass`对象。然后，`sharedMyClass`实例通过值传递给`ChangeSharedValue`函数。通过值传递一个`shared_ptr`来复制指针。现在您有了两个`SharedMyClass`模板的实例，它们都指向同一个`MyClass`实例。直到的两个`shared_ptr`实例都超出范围，才会调用`MyClass`的析构函数。[图 10-8](#Fig8) 显示了`MyClass`实例的初始值被改变了，并且析构函数只被调用了一次。

![9781484201589_Fig10-08.jpg](images/9781484201589_Fig10-08.jpg)

[图 10-8](#_Fig8) 。显示共享对象的存储值被更改和销毁一次的输出

10-5.创建单实例动态对象

问题

您有一个想要传递的对象，但是您只希望有该对象的一个实例。

解决办法

C++提供了`unique_ptr`模板，允许一个指针实例被转移但不能共享。

它是如何工作的

`unique_ptr`是一个模板，可以用来存储动态分配内存的指针。它与`shared_ptr`的不同之处在于，一次只能有一个对动态内存的引用。清单 10-10 展示了如何创建一个`unique_ptr`。

[***清单 10-10***](#_list10) 。创建一个`unique_ptr`

```
#include <iostream>
#include <memory>

using namespace std;

class MyClass
{
private:
    int m_Number{ 0 };

public:
    MyClass(int value)
        : m_Number{ value }
    {

    }

    ~MyClass()
    {
        cout << "Destroying " << m_Number << endl;
    }

    void operator=(const int value)
    {
        m_Number = value;
    }

    int GetNumber() const
    {
        return m_Number;
    }
};

using UniqueMyClass = unique_ptr< MyClass >;

void CreateUniqueObject()
{
    UniqueMyClass uniqueMyClass{ make_unique<MyClass>(10) };
}

int main(int argc, char* argv[])
{
    cout << "Begin Main!" << endl;

    CreateUniqueObject();

    cout << "Back in Main!" << endl;

    return 0;
}
```

[清单 10-10](#list10) 中的`unique_ptr`是在一个函数中创建的，用来演示当`unique_ptr`超出作用域时，动态创建的对象的实例被销毁。你可以在[图 10-9](#Fig9) 的输出中看到这一点。

![9781484201589_Fig10-09.jpg](images/9781484201589_Fig10-09.jpg)

[图 10-9](#_Fig9) 。显示存储在`unique_ptr`中的动态分配对象的销毁的输出

[清单 10-10](#list10) 展示了`unique_ptr`可以用来在不再需要时自动删除动态分配的内存。它没有显示出`unique_ptr`可以用来在不同的作用域之间转移单个对象的所有权。这显示在[清单 10-11](#list11) 中。

[***清单 10-11***](#_list11) 。在`unique_ptr`实例之间转移动态分配的内存

```
#include <iostream>
#include <memory>

using namespace std;

class MyClass
{
private:
    int m_Number{ 0 };

public:
    MyClass(int value)
        : m_Number{ value }
    {

    }

    ~MyClass()
    {
        cout << "Destroying " << m_Number << endl;
    }

    void operator=(const int value)
    {
        m_Number = value;
    }

    int GetNumber() const
    {
        return m_Number;
    }
};

using UniqueMyClass = unique_ptr< MyClass >;

void CreateUniqueObject(UniqueMyClass& referenceToUniquePtr)
{
    UniqueMyClass uniqueMyClass{ make_unique<MyClass>(10) };

    cout << hex << showbase;
    cout << "Address in uniqueMyClass " << uniqueMyClass.get() << endl;

    referenceToUniquePtr.swap(uniqueMyClass);

    cout << "Address in uniqueMyClass " << uniqueMyClass.get() << endl;
}

int main(int argc, char* argv[])
{
    cout << "Begin Main!" << endl;

    UniqueMyClass uniqueMyClass;
    CreateUniqueObject(uniqueMyClass);

    cout << "Address in main's uniqueMyClass " << uniqueMyClass.get() << endl;

    cout << dec << noshowbase << "Back in Main!" << endl;

    return 0;
}
```

清单 10-11 中的代码在`CreateUniqueObject`函数中创建了一个`MyClass`的实例。这个函数还引用了另一个 un `qiue_ptr<MyClass>`，这个 un【】用于将动态分配的对象转移到函数之外。使用由联合国`ique_ptr`模板提供的`swap`函数 来实现传输。当所有的`UniqueMyClass`实例都超出范围时，在`main`函数的末尾调用`MyClass`析构函数。你可以在[图 10-10](#Fig10) 中看到`MyClass`实例的内存转移和销毁顺序。

![9781484201589_Fig10-10.jpg](images/9781484201589_Fig10-10.jpg)

[图 10-10](#_Fig10) 。输出显示了一个`unique_ptr`的传输和它的动态分配内存的销毁

10-6.创建智能指针

问题

您希望在不支持`shared_ptr`和`unique_ptr`的系统上使用自动化指针管理。

解决办法

您可以在`class`中使用成员变量来跟踪当前有多少对数据的引用在使用中。

它是如何工作的

在 C++11 中，`unique_ptr`和`shared_ptr`模板被添加到 STL 中。有些程序是在无法访问 C++11 或者无法访问 STL 的情况下编写的。在这种情况下，您可以编写自己的智能指针实现。首先，您需要创建一个可用于引用计数的对象。引用计数的工作原理是，每当您复制一个想要计数的对象时，就增加一个整数。[清单 10-12](#list12) 显示了一个引用计数类的代码。

[***清单 10-12***](#_list12) 。引用计数类的代码

```
class ReferenceCount
{
private:
    int m_Count{ 0 };

public:
    void Increment()
    {
        ++m_Count;
    }

    int Decrement()
    {
        return --m_Count;
    }

    int GetCount() const
    {
        return m_Count;
    }
};
```

这个类非常基础。它只包含一个跟踪计数的成员变量以及增加和减少计数的方法。`GetCount`方法提供对计数的访问，允许在调试期间打印。

然后在名为`SmartPointer`的模板类中使用`ReferenceCount`类。该类提供了一个模板参数，您可以使用该参数将模板专门化为您希望自动跟踪的对象类型。该类有一个成员变量，一个指向被跟踪对象的指针，另一个指向`ReferenceCount`对象。通过一个指针来访问`ReferenceCount`对象，这样它就可以在访问同一个动态分配对象的多个`SmartPointer`对象之间共享。你可以在[清单 10-13](#list13) 中看到`SmartPointer`和的代码。

[***清单 10-13***](#_list13) 。`SmartPointer`类

```
template <typename T>
class SmartPointer
{
private:
    T* m_Object{ nullptr };
    ReferenceCount* m_ReferenceCount{ nullptr };

public:
    SmartPointer()
    {

    }

    SmartPointer(T* object)
        : m_Object{ object }
        , m_ReferenceCount{ new ReferenceCount }
    {
        m_ReferenceCount->Increment();

        cout << "Created smart pointer! Reference count is "
            << m_ReferenceCount->GetCount() << endl;
    }

    virtual ~SmartPointer()
    {
        if (m_ReferenceCount)
        {
            int decrementedCount = m_ReferenceCount->Decrement();
            cout << "Destroyed smart pointer! Reference count is "
                << decrementedCount << endl;
            if (decrementedCount == 0)
            {
                delete m_ReferenceCount;
                delete m_Object;
            }
            m_ReferenceCount = nullptr;
            m_Object = nullptr;
        }
    }

    SmartPointer(const SmartPointer<T>& other)
        : m_Object{ other.m_Object }
        , m_ReferenceCount{ other.m_ReferenceCount }
    {
        m_ReferenceCount->Increment();

        cout << "Copied smart pointer! Reference count is "
            << m_ReferenceCount->GetCount() << endl;
    }

    SmartPointer<T>& operator=(const SmartPointer<T>& other)
    {
        if (this != &other)
        {
            if (m_ReferenceCount && m_ReferenceCount->Decrement() == 0)
            {
                delete m_ReferenceCount;
                delete m_Object;
            }

            m_Object = other.m_Object;
            m_ReferenceCount = other.m_ReferenceCount;
            m_ReferenceCount->Increment();
        }

        cout << "Assigning smart pointer! Reference count is "
            << m_ReferenceCount->GetCount() << endl;

        return *this;
    }

    SmartPointer(SmartPointer<T>&& other)
        : m_Object{ other.m_Object }
        , m_ReferenceCount{ other.m_ReferenceCount }
    {
        other.m_Object = nullptr;
        other.m_ReferenceCount = nullptr;
    }

    SmartPointer<T>& operator=(SmartPointer<T>&& other)
    {
        if (this != &other)
        {
            m_Object = other.m_Object;
            m_ReferenceCount = other.m_ReferenceCount;

            other.m_Object = nullptr;
            other.m_ReferenceCount = nullptr;
        }
    }

    T& operator*()
    {
        return *m_Object;
    }
};
```

您可以在清单 10-13 的[中看到用于存储动态分配对象和`SmartPointer`类](#list13)中的`ReferenceCount`对象的成员变量。对象指针是一个指向抽象模板类型的指针；这允许任何类型的使用被`SmartPointer`模板跟踪。

`SmartPointer`中的第一个公共方法是构造函数。可以创建一个新的`SmartPointer`作为空指针或者指向一个已经存在的对象。一个空的`SmartPointer`将`m_Object`和`m_ReferenceCount`都设置为`nullptr`。另一个构造函数取一个指向`T`的指针，这个指针导致一个`SmartPointer`被初始化。在这种情况下，创建一个新的`ReferenceCount`对象来跟踪传递给构造函数的对象的使用。这样做的副作用是，新的`SmartPointer`只能在用对象指针初始化时创建；空值`SmartPointer`只能从另一个`SmartPointer`对象分配。

`SmartPointer`析构函数检查一个`ReferenceCount`对象是否被类持有(记住它可能是空`SmartPointer`中的`nullptr`)。如果一个指向`ReferenceCount`对象的指针被保持，它的计数就会减少。如果计数已经达到 0，那么你知道这个`SmartPointer`是最后一个引用这个动态分配的对象。在这种情况下，您可以自由地删除`ReferenceCount`对象和由`SmartPointer`持有的对象。

`SmartPointer`中的下一个方法是`copy`构造器。该方法只是将传递给该方法的参数中的`m_Object`和`m_ReferenceCount`指针复制到被复制构造的对象中。然后，它确保引用计数递增。对`Increment`的调用是必不可少的，因为现在有两个`SmartPointer`对象引用同一个动态分配的对象。在这里错过对`Increment`的调用会导致`delete`在第一个`SmartPointer`的析构函数中被调用而超出范围。

赋值操作符的工作与`copy`构造函数略有不同。在`copy`构造函数中，您可以自由地假设现有对象是新的，因此没有指向现有对象或`ReferenceCount`实例。这在赋值操作符中是不正确的；因此，有必要解释这种情况的发生。您可以看到赋值操作符首先检查以确保操作符没有将对象赋值给它自己；在这种情况下，就没有工作可做了。如果正在分配一个新对象，则检查`ReferenceCount`指针是否有效。如果是，那么就叫`Decrement`；并且在返回 0 的情况下，删除现有的`m_ReferenceCount`和`m_Object`指针。`m_Object`和`m_ReferenceCount`指针总是从赋值操作符方法的参数复制到这个的变量中，并且在新的`ReferenceCount`对象上调用`Increment`。

接下来是一个`move`构造函数和`move`赋值操作符。这些都符合 C++的五原则。这是一个编程指南，建议在重载`copy`构造函数或赋值操作符的任何情况下，都应该重载所有五个析构函数、`copy`构造函数、赋值操作符、`move`构造函数和`move`赋值操作符。移动操作本质上是破坏性的，因此不会调用`Increment`或`Decrement`。这些都是不必要的，因为在这两种情况下，参数上的`m_Object`和`m_ReferenceCount`指针都被设置为`nullptr`，这意味着`delete`永远不会在它们的析构函数中被调用。支持`move`构造函数和`move`赋值操作符提供了一种更有效的方法将`SmartPointer`对象传入和传出函数。

最后一个方法提供了对由`SmartPointer`对象存储的数据的访问。如果在空的`SmartPointer`对象上调用这个方法，这可能会导致崩溃。您应该注意只尝试解引用有效的`SmartPointer`实例。

![Image](images/sq.jpg) **注意** [清单 10-14](#list14) 包含调试代码，允许打印对象状态，以便于说明。该代码可以从工作解决方案中删除。

清单 10-14 展示了一个正在使用的`SmartPointer`类的完整工作示例。

[***清单 10-14***](#_list14) 。使用`SmartPointer`

```
#include <iostream>

using namespace std;

class ReferenceCount
{
private:
    int m_Count{ 0 };

public:
    void Increment()
    {
        ++m_Count;
    }

    int Decrement()
    {
        return --m_Count;
    }

    int GetCount() const
    {
        return m_Count;
    }
};

template <typename T>
class SmartPointer
{
private:
    T* m_Object{ nullptr };
    ReferenceCount* m_ReferenceCount{ nullptr };

public:
    SmartPointer()
    {

    }

    SmartPointer(T* object)
        : m_Object{ object }
        , m_ReferenceCount{ new ReferenceCount }
    {
        m_ReferenceCount->Increment();

        cout << "Created smart pointer! Reference count is " << m_ReferenceCount->GetCount() << endl;
    }

    virtual ~SmartPointer()
    {
        if (m_ReferenceCount)
        {
            int decrementedCount = m_ReferenceCount->Decrement();
            cout << "Destroyed smart pointer! Reference count is " << decrementedCount << endl;
            if (decrementedCount <= 0)
            {
                delete m_ReferenceCount;
                delete m_Object;
            }
            m_ReferenceCount = nullptr;
            m_Object = nullptr;
        }
    }

    SmartPointer(const SmartPointer<T>& other)
        : m_Object{ other.m_Object }
        , m_ReferenceCount{ other.m_ReferenceCount }
    {
        m_ReferenceCount->Increment();

        cout << "Copied smart pointer! Reference count is " << m_ReferenceCount->GetCount() << endl;
    }

    SmartPointer<T>& operator=(const SmartPointer<T>& other)
    {
        if (this != &other)
        {
            if (m_ReferenceCount && m_ReferenceCount->Decrement() == 0)
            {
                delete m_ReferenceCount;
                delete m_Object;
            }

            m_Object = other.m_Object;
            m_ReferenceCount = other.m_ReferenceCount;
            m_ReferenceCount->Increment();
        }

        cout << "Assigning smart pointer! Reference count is " << m_ReferenceCount->GetCount() << endl;

        return *this;
    }

    SmartPointer(SmartPointer<T>&& other)
        : m_Object{ other.m_Object }
        , m_ReferenceCount{ other.m_ReferenceCount }
    {
        other.m_Object = nullptr;
        other.m_ReferenceCount = nullptr;
    }

    SmartPointer<T>& operator=(SmartPointer<T>&& other)
    {
        if (this != &other)
        {
            m_Object = other.m_Object;
            m_ReferenceCount = other.m_ReferenceCount;

            other.m_Object = nullptr;
            other.m_ReferenceCount = nullptr;
        }
    }

    T& operator*()
    {
        return *m_Object;
    }
};

struct MyStruct
{
public:
    int m_Value{ 0 };

    ~MyStruct()
    {
        cout << "Destroying MyStruct object!" << endl;
    }
};

using SmartMyStructPointer = SmartPointer< MyStruct >;

SmartMyStructPointer PassValue(SmartMyStructPointer smartPointer)
{
    SmartMyStructPointer returnValue;
    returnValue = smartPointer;
    return returnValue;
}

int main(int argc, char* argv[])
{
    SmartMyStructPointer smartPointer{ new MyStruct };
    (*smartPointer).m_Value = 10;

    SmartMyStructPointer secondSmartPointer = PassValue(smartPointer);

    return 0;
}
```

[清单 10-14](#list14) 显示了一个使用`SmartPointer`模板在`main`和`PassValue`函数之间传递的`MyStruct`实例。创建类型别名是为了确保`MyStruct`的`SmartPointer`的类型是有效的，并且始终易于维护。代码使用来自`SmartPointer`模板的构造函数、`copy`构造函数和赋值操作符。只有当最后一个`SmartPointer`实例在`main`函数结束时超出范围，才会自动删除`MyStruct`对象。

[图 10-11](#Fig11) 显示了运行[清单 10-14](#list14) 中的代码时生成的输出。

![9781484201589_Fig10-11.jpg](images/9781484201589_Fig10-11.jpg)

[图 10-11](#_Fig11) 。`SmartPointer`行动中的一个工作实例

10-7.通过重载 new 和 delete 调试内存问题

问题

你的程序中有一些内存问题，你想在程序的分配和释放中添加诊断代码。

解决办法

C++允许用定制的版本替换`new`和`delete`操作符。

它是如何工作的

C++ `new`和`delete`操作符归结为函数调用。全局`new`函数的签名是

```
void* operator new(size_t size);
```

全局`delete`函数的签名是

```
void delete(void* ptr);
```

`new`函数将待分配的字节数作为参数，`delete`函数将从`new`返回的内存地址作为指针。这些函数可以被替换以向程序提供额外的调试信息。清单 10-15 展示了一个给内存分配添加一个头的例子，以帮助程序调试。

[***清单 10-15***](#_list15) 。向内存分配添加标头

```
#include <cstdlib>
#include <iostream>

using namespace std;

struct MemoryHeader
{
    const char* m_Filename{ nullptr };
    int m_Line{ -1 };
};

void* operator new(size_t size, const char* filename, int line) noexcept
{
    void* pMemory{ malloc(size + sizeof(MemoryHeader)) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemory) };
    pMemoryHeader->m_Filename = filename;
    pMemoryHeader->m_Line = line;

    return static_cast<void*>(static_cast<char*>(pMemory)+sizeof(MemoryHeader));
}

void operator delete(void* pMemory) noexcept
{
    char* pMemoryHeaderStart{ reinterpret_cast<char*>(pMemory)-sizeof(MemoryHeader) };
    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemoryHeaderStart) };

    cout << "Deleting memory allocated from: "
        << pMemoryHeader->m_Filename << ":" << pMemoryHeader->m_Line << endl;

    free(pMemoryHeader);
}

#define new new(__FILE__, __LINE__)

class MyClass
{
private:
    int m_Value{ 1 };
};

int main(int argc, char* argv[])
{
    int* pInt{ new int };
    *pInt = 1;
    delete pInt;

    MyClass* pClass{ new MyClass };
    delete pClass;

    return 0;
}
```

这段代码用自定义版本替换了`new`和`delete`函数。`new`的自定义版本不符合标准签名，所以用宏替换了标准版本。这样做是为了让编译器告诉定制的`new`函数文件名和调用`new`的行号。这允许您跟踪单个分配到它们在程序源代码中的确切位置。当您处理内存问题时，这是一个非常有用的调试工具。

自定义`new`函数将`MemoryHeader`结构的大小添加到程序请求的字节数中。然后将`MemoryHeader struct`中的`m_Filename`指针设置为提供给`new`的`filename`参数。类似地，`m_Line`成员被设置为传入的`line`参数。从`new`返回的地址是内存用户区开始的地址，不包括`MemoryHeader`结构；这允许在内存子系统级别添加和寻址调试信息，并且对程序的其余部分完全透明。

`delete`功能显示了该调试信息的基本用途。它只是打印出被释放的内存块被分配的那一行。它通过从函数传递的地址中减去头的大小来获得内存头的地址。

`new`宏用于给出一个简单的方法，将`__FILE__`和`__LINE__`宏传递给重载的`new`函数。这些宏被称为*内置宏*，由大多数现代 C++编译器提供。这些宏被替换为指向文件名和使用它们的行号的指针。将它们添加到`new`宏中会导致程序中每次调用`new`的文件名和行号被传递给定制的`new`分配器。

`new`和`delete`函数中使用的`malloc` 和`free`函数是 C 风格的内存分配函数。这些用于防止与许多不同类型的 C++分配函数发生冲突。清单 10-15 中所示的函数适用于分配单个对象。也可以替换 C++数组`new`和`delete`函数。当您试图跟踪诸如内存泄漏之类的问题时，替换这些函数是非常必要的。[清单 10-16](#list16) 展示了这些函数的作用。

[***清单 10-16***](#_list16) 。替换数组`new`和`delete`运算符

```
#include <cstdlib>
#include <iostream>

using namespace std;

struct MemoryHeader
{
    const char* m_Filename{ nullptr };
    int m_Line{ -1 };
};

void* operator new(size_t size, const char* filename, int line) noexcept
{
    void* pMemory{ malloc(size + sizeof(MemoryHeader)) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemory) };
    pMemoryHeader->m_Filename = filename;
    pMemoryHeader->m_Line = line;

    return static_cast<void*>(static_cast<char*>(pMemory)+sizeof(MemoryHeader));
}

void* operator new[](size_t size, const char* filename, int line) noexcept
{
    void* pMemory{ malloc(size + sizeof(MemoryHeader)) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemory) };
    pMemoryHeader->m_Filename = filename;
    pMemoryHeader->m_Line = line;

    return static_cast<void*>(static_cast<char*>(pMemory)+sizeof(MemoryHeader));
}

void operator delete(void* pMemory) noexcept
{
    char* pMemoryHeaderStart{ reinterpret_cast<char*>(pMemory)-sizeof(MemoryHeader) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemoryHeaderStart) };
    cout << "Deleting memory allocated from: "
        << pMemoryHeader->m_Filename << ":" << pMemoryHeader->m_Line << endl;

    free(pMemoryHeader);
}

void operator delete[](void* pMemory) noexcept
{
    char* pMemoryHeaderStart{ reinterpret_cast<char*>(pMemory)-sizeof(MemoryHeader) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemoryHeaderStart) };
    cout << "Deleting memory allocated from: "
        << pMemoryHeader->m_Filename << ":" << pMemoryHeader->m_Line << endl;

    free(pMemoryHeader);
}

#define new new(__FILE__, __LINE__)

class MyClass
{
private:
    int m_Value{ 1 };
};

int main(int argc, char* argv[])
{
    int* pInt{ new int };
    *pInt = 1;
    delete pInt;

    MyClass* pClass{ new MyClass };
    delete pClass;

    const unsigned int NUM_ELEMENTS{ 5 };
    int* pArray{ new int[NUM_ELEMENTS] };
    delete[] pArray;

    return 0;
}
```

数组`new`和`delete`操作符的签名与标准的`new`和`delete`操作符的区别仅在于它们的签名中出现了`[]`操作符，如清单 10-16 中的[所示。](#list16)[图 10-12](#Fig12) 显示了该代码生成的输出。

![9781484201589_Fig10-12.jpg](images/9781484201589_Fig10-12.jpg)

[图 10-12](#_Fig12) 。显示使用替换的`new`和`delete`操作符的输出

到目前为止，你在这个配方中看到的`new`和`delete`函数已经成为了`new`和`delete`操作符的全局替换。也可以替换特定职业的`new`和`delete`。您可以将这些函数直接添加到类定义中，并且这些函数将在创建和销毁该类型对象的动态实例时使用。[清单 10-17](#list17) 显示了替换全局`new`、`new[]`、`delete`和`delete[]`操作符的代码，还将`new`和`delete`操作符添加到了`MyClass class`定义中。

[***清单 10-17***](#_list17) 。将`new`和`delete`运算符添加到`MyClass`

```
#include <cstdlib>
#include <iostream>

using namespace std;

struct MemoryHeader
{
    const char* m_Filename{ nullptr };
    int m_Line{ -1 };
};

void* operator new(size_t size, const char* filename, int line) noexcept
{
    void* pMemory{ malloc(size + sizeof(MemoryHeader)) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemory) };
    pMemoryHeader->m_Filename = filename;
    pMemoryHeader->m_Line = line;

    return static_cast<void*>(static_cast<char*>(pMemory)+sizeof(MemoryHeader));
}

void* operator new[](size_t size, const char* filename, int line) noexcept
{
    void* pMemory{ malloc(size + sizeof(MemoryHeader)) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemory) };
    pMemoryHeader->m_Filename = filename;
    pMemoryHeader->m_Line = line;

    return static_cast<void*>(static_cast<char*>(pMemory)+sizeof(MemoryHeader));
}

void operator delete(void* pMemory) noexcept
{
    char* pMemoryHeaderStart{ reinterpret_cast<char*>(pMemory)-sizeof(MemoryHeader) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemoryHeaderStart) };

    cout << "Deleting memory allocated from: "
        << pMemoryHeader->m_Filename << ":" << pMemoryHeader->m_Line << endl;

    free(pMemoryHeader);
}

void operator delete[](void* pMemory) noexcept
{
    char* pMemoryHeaderStart{ reinterpret_cast<char*>(pMemory)-sizeof(MemoryHeader) };

    MemoryHeader* pMemoryHeader{ reinterpret_cast<MemoryHeader*>(pMemoryHeaderStart) };

    cout << "Deleting memory allocated from: "
        << pMemoryHeader->m_Filename << ":" << pMemoryHeader->m_Line << endl;

    free(pMemoryHeader);
}

class MyClass
{
private:
    int m_Value{ 1 };

public:
    void* operator new(size_t size, const char* filename, int line) noexcept
    {
        cout << "Allocating memory for MyClass!" << endl;
        return malloc(size);
    }

    void operator delete(void* pMemory) noexcept
    {
        cout << "Freeing memory for MyClass!" << endl;
        free(pMemory);
    }
};

#define new new(__FILE__, __LINE__)

int main(int argc, char* argv[])
{
    int* pInt{ new int };
    *pInt = 1;
    delete pInt;

    MyClass* pClass{ new MyClass };
    delete pClass;

    const unsigned int NUM_ELEMENTS{ 5 };
    MyClass* pArray{ new MyClass[NUM_ELEMENTS] };
    delete[] pArray;

    return 0;
}
```

创建`MyClass`的单个实例时，`MyClass`定义中的`new`和`delete`操作符在`main`函数中被调用。在图 10-13 的[输出中可以看到这种情况。](#Fig13)

![9781484201589_Fig10-13.jpg](images/9781484201589_Fig10-13.jpg)

[图 10-13](#_Fig13) 。显示在`MyClass`中使用成员`new`和`delete`操作符的输出

10-8.计算代码更改的性能影响

问题

您希望确定您对代码所做的更改是比现有代码快还是慢。

解决办法

C++提供对计算机系统高性能定时器的访问，以实现高精度计时。

它是如何工作的

C++编程语言提供了对高分辨率定时器的访问，该定时器允许您对代码的不同部分进行计时测量。这可以让你记录你的函数或算法所花费的时间，并在不同的版本之间进行比较，从而找出哪一个是最有效率和性能的。

[清单 10-18](#list18) 显示了用于计时一个循环中三个不同迭代次数的代码。

[***清单 10-18***](#_list18) 。使用`chrono::high_resolution_timer`

```
#include <chrono>
#include <iostream>

using namespace std;

void RunTest(unsigned int numberIterations)
{
    auto start = chrono::high_resolution_clock::now();

    for (unsigned int i{ 0 }; i < numberIterations; ++i)
    {
        unsigned int squared{ i*i*I };
    }

    auto end = chrono::high_resolution_clock::now();
    auto difference = end - start;

    cout << "Time taken: "
        << chrono::duration_cast<chrono::microseconds>(difference).count()
        << " microseconds!" << endl;
}

int main(int argc, char* argv[])
{
    RunTest(10000000);
    RunTest(100000000);
    RunTest(1000000000);

    return 0;
}
```

这个清单显示了 STL 中的`chrono`名称空间提供了一个名为`high_resolution_clock`的`struct`和一个名为`now`的静态函数。这个函数从`chrono::system_clock` `struct` 中返回一个类型为 t `ime_point`的对象。[清单 10-18](#list18) 使用`auto`关键字为`RunTest`函数中的`start`和`end`变量推导出这种类型。使用 hig `h_resolution_timer::now`功能初始化`start`和`end`，在`for`循环之前初始化`start`，在`for`循环之后初始化`end`。从`end`的值中减去`start`的值，得到函数执行循环所经过的时间。然后使用`chrono::duration_cast` 模板将`time_point`差异变量转换成可以以人类可读形式表达的表示，在本例中为微秒。

`RunTest`函数被调用了三次，不同于`main`函数。每个调用都有不同数量的循环迭代要运行，以显示计时代码可用于判断哪一次运行的时间效率最低。[图 10-14](#Fig14) 显示了在英特尔酷睿 i7-3770 上运行程序时产生的输出。

![9781484201589_Fig10-14.jpg](images/9781484201589_Fig10-14.jpg)

[图 10-14](#_Fig14) 。输出显示对清单 10-18 中[的`RunTest`的每个后续调用需要更长时间来执行](#list18)

`duration_cast` 可用于将系统时间转换为纳秒、毫秒、秒、分、小时以及微秒。当优化许多计算机编程算法时，微秒精度是你正在寻找的。当比较存储器存储类型对程序效率的影响时，这个方法中使用的计时技术将被证明是有用的。

10-9.了解内存选择对性能的影响

问题

你有一个表现很差的程序，但是你不知道为什么。

解决办法

在现代计算机程序中，没有解决性能问题的灵丹妙药。然而，缺乏对现代计算机内存工作原理的理解会导致程序运行不佳。了解高速缓存未命中对程序性能的影响将有助于您编写性能更好的程序。

它是如何工作的

现代处理器的速度比内存访问延迟快得多。这导致了程序中糟糕的内存访问模式会严重影响处理性能的情况。了解如何构建 C++程序以有效利用处理器缓存，对于编写尽可能高性能的程序至关重要。

在现代计算机系统中，从主存储器中读取和写入数据可能需要数百个周期。处理器实现缓存来帮助缓解这个问题。现代 CPU 高速缓存的工作原理是将大量数据同时从主内存读入速度更快的高速缓存。这些块被称为*缓存线* 。英特尔酷睿 i7-3770 处理器上的 L1 高速缓存行大小为 32KB。处理器一次性将整个 32KB 数据块读入 L1 缓存。如果您正在读取或写入的数据不在高速缓存中，结果就是高速缓存未命中，处理器必须从 L2 高速缓存、L3 高速缓存或系统 RAM 中检索数据。缓存未命中的代价可能非常高，代码中看似无害的错误或选择可能会对性能产生重大影响。[清单 10-19](#list19) 包含一个初始化一些数组的循环和三个具有不同内存访问模式的不同循环。

[***清单 10-19***](#_list19) 。探索内存访问模式的性能影响

```
#include <chrono>
#include <iostream>

using namespace std;

const int NUM_ROWS{ 10000 };
const int NUM_COLUMNS{ 1000 };
int elements[NUM_ROWS][NUM_COLUMNS];
int* pElements[NUM_ROWS][NUM_COLUMNS];

int main(int argc, char* argv[])
{
    for (int i{ 0 }; i < NUM_ROWS; ++i)
    {
        for (int j{ 0 }; j < NUM_COLUMNS; ++j)
        {
            elements[i][j] = i*j;
            pElements[i][j] = new int{ elements[i][j] };
        }
    }

    auto start = chrono::high_resolution_clock::now();

    for (int i{ 0 }; i < NUM_ROWS; ++i)
    {
        for (int j{ 0 }; j < NUM_COLUMNS; ++j)
        {
            const int result{ elements[j][i] };
        }
    }

    auto end = chrono::high_resolution_clock::now();
    auto difference = end - start;

    cout << "Time taken for j then i: "
        << chrono::duration_cast<chrono::microseconds>(difference).count()
        << " microseconds!" << endl;

    start = chrono::high_resolution_clock::now();

    for (int i{ 0 }; i < NUM_ROWS; ++i)
    {
        for (int j{ 0 }; j < NUM_COLUMNS; ++j)
        {
            const int result{ elements[i][j] };
        }
    }

    end = chrono::high_resolution_clock::now();
    difference = end - start;

    cout << "Time taken for i then j: "
        << chrono::duration_cast<chrono::microseconds>(difference).count()
        << " microseconds!" << endl;

    start = chrono::high_resolution_clock::now();

    for (int i{ 0 }; i < NUM_ROWS; ++i)
    {
        for (int j{ 0 }; j < NUM_COLUMNS; ++j)
        {
            const int result{ *(pElements[i][j]) };
        }
    }

    end = chrono::high_resolution_clock::now();
    difference = end - start;

    cout << "Time taken for pointers with i then j: "
        << chrono::duration_cast<chrono::microseconds>(difference).count()
        << " microseconds!" << endl;

    return 0;
}
```

清单 10-19 中的第一个循环用于设置两个数组。第一个数组直接存储整数值，第二个数组存储指向整数的指针。每个数组包含 10，000 × 1，000 个唯一元素。

理解多维数组在内存中的布局，理解为什么这个测试会产生与缓存未命中性能问题相关的结果是很重要的。可以认为一个 3 × 2 的阵列的布局如[表 10-1](#Tab1) 所示。

[表 10-1](#_Tab1) 。3 × 2 阵列的布局

![Table10-1](images/Table10-1.jpg)

但是电脑记忆并不是二维的。数组的元素按照[表 10-1](#Tab1) 中显示的数字顺序线性排列在内存中。给定一个 4 字节的整数大小，这意味着第 2 行第 1 列中的值可以在第 1 行第 1 列中的值之后 12 个字节找到。将行大小扩展到 10，000，您可以看到下一行开头的元素不可能与前一行位于同一缓存行。

这个事实允许用一个简单的循环来测试高速缓存未命中的性能含义。你可以在[清单 10-18](#list18) 的第二个循环中看到这一点，其中增加的`j`值用于遍历列而不是行。第三个循环按照正确的顺序遍历数组。也就是说，它在内存中按线性顺序遍历这些行。第四个循环以线性顺序遍历`pElement`数组，但是必须取消对指针的引用才能到达数组中存储的值。结果显示了第一个循环中缓存感知编程的影响，第二个循环中的理想情况，以及第三个循环中不必要的内存间接寻址的结果。[图 10-15](#Fig15) 显示了这些结果。

![9781484201589_Fig10-15.jpg](images/9781484201589_Fig10-15.jpg)

[图 10-15](#_Fig15) 。来自[清单 10-19](#list9) 中循环的结果

你可以看到，在无序遍历数组时，我电脑中的处理器完成一个简单循环所需的时间增加了 10 倍。这样的问题会导致程序的口吃和延迟，让用户和客户对你的软件感到沮丧。指针解引用的情况也比直接访问整数的情况慢大约两倍。在大量使用动态内存之前，您应该考虑这一点。

10-10.减少内存碎片

问题

您有一个程序，它要求您在很长一段时间内创建许多小的内存分配，这就引入了内存碎片问题。

解决办法

您可以创建一个小的块分配器，用于将小的分配打包到更大的页面中。

它是如何工作的

将少量分配捆绑在一起的第一步是创建一个包含更大内存页面的类。这个方法向您展示了一种简单的方法，将一个 32KB 的内存页面包装到一个类中，并管理这个池中的内存分配。使用布尔值数组跟踪内存，该数组知道给定的内存块是空闲的还是在使用中。当所有当前页面都已满时，会添加新的内存页面。

这种方法的缺点是所有分配的最小大小为 32 字节。任何小于 32 字节的内存请求都会从当前活动的内存页面中分配一个完整的块。当页面完全清空时，它们也会被释放，以确保程序不会增长到一个高水位，并且永远不会释放不需要的内存。清单 10-20 显示了`Page`的类定义。

[***清单 10-20***](#_list20) 。`Page`类定义

```
class Page
{
private:
    char m_Memory[1024 * 32];
    bool m_Free[1024];
    Page* m_pNextPage;

public:
    Page();
    ~Page();

    void* Alloc();
    bool Free(void* pMem);

    bool IsEmpty() const;
};
```

`Page`类定义包含两个数组。有一个`char`数组服务于内存分配请求。这个池是一个字节数组，在本例中大小为 32KB。池中有 1，024 个独立的块，每个块的大小为 32 字节。1024 个块被镜像到布尔数组`m_Free`中。这个数组用于跟踪一个给定的块是已经分配了还是可以分配。`m_pNextPage`指针存储下一页的地址。如果当前页完全被使用，则下一页用于分配块。

该类由五个方法组成:构造函数、析构函数、`Alloc`方法、`Free`方法和`IsEmpty`方法，用于确定页面是否不再使用。[清单 10-21](#list21) 展示了`Page`类的构造函数和析构函数的函数体。

[***清单 10-21***](#_list21) 。`Page`构造函数和析构函数

```
Page()
    : m_pNextPage{ nullptr }
{
    memset(m_Free, 1, 1024);
}

~Page()
{
    if (m_pNextPage)
    {
        delete m_pNextPage;
        m_pNextPage = nullptr;
    }
}
```

`Page`构造函数负责初始化指向`nullptr`的`m_pNextPage`指针，并将`m_F` ree 数组中的所有元素设置为`true`。`Page`的析构函数负责删除指向`m_pNextPage`的对象指针，如果它已经被分配。

[清单 10-22](#list22) 显示了`Page::` `Alloc`方法的代码。

[***清单 10-22***](#_list22) 。`Page::Alloc`法

```
void* Alloc()
{
    void* pMem{ nullptr };

    for (unsigned int i = 0; i < 1024; ++i)
    {
        if (m_Free[i] == true)
        {
            m_Free[i] = false;
            pMem = &m_Memory[i * 32];
            break;
        }
    }

    if (pMem == nullptr)
    {
        if (m_pNextPage == nullptr)
        {
            m_pNextPage = new Page();
        }

        pMem = m_pNextPage->Alloc();
        }

    return pMem;
}
```

`Alloc`方法负责在页面链表中寻找第一个未使用的内存块。第一步是遍历`m_Free`数组，检查每个块，看它当前是否在使用中。如果找到一个空闲块，`pMem`返回值被设置为空闲块的地址。该块的布尔值被设置为`false`以指示该块现在正在使用中。如果找到一个空闲块，循环就被中断。

如果没有找到空闲块，就必须从另一个内存页面分配内存。如果已经创建了另一个页面，指针`m_pNextPage`已经保存了它的地址。如果没有，则创建一个新页面。然后在`m_pNextPage`上调用`Alloc`方法。此时，`Alloc`方法是递归的。它会被反复调用，直到找到一个包含空闲内存块的内存页，以将堆栈向上返回到调用代码。从一个页面返回的内存也必须在不再需要时返回到那个页面。清单 10-23 中的`Free`方法负责执行这项任务。

[***清单 10-23***](#_list23) 。`Page::Free`法

```
bool Free(void* pMem)
{
    bool freed{ false };

    bool inPage{ pMem >= m_Memory && pMem <= &m_Memory[(NUM_PAGES * BLOCK_SIZE) - 1] };
    if (inPage)
    {
        unsigned int index{
            (reinterpret_cast<unsigned int>(pMem)-reinterpret_cast<unsigned int>(m_Memory))
            / BLOCK_SIZE };

        m_Free[index] = true;
        freed = true;
    }
    else if (m_pNextPage)
    {
        freed = m_pNextPage->Free(pMem);

        if (freed && m_pNextPage->IsEmpty())
        {
            Page* old = m_pNextPage;
            m_pNextPage = old->m_pNextPage;
            old->m_pNextPage = nullptr;
            delete m_pNextPage;
        }
    }

    return freed;
}
```

`Page::Free`方法首先检查被释放的内存地址是否包含在当前页面中。它通过将该地址与内存页面开始的地址和页面中最后一个块的地址进行比较来实现这一点。如果被释放的内存大于或等于页面地址，并且小于或等于页面中的最后一个块，则内存是从该页面分配的。在这种情况下，该块的`m_Free`布尔值可以被设置回`true`。内存本身不需要清除，因为`new`不保证它返回的内存中包含的值，这是调用者的责任。

如果在当前的`Page`中没有找到内存，那么`Free`方法检查`Page`是否有指向另一个`Page`对象的指针。如果是，那么在那个`Page`上调用`Free`方法。与`Alloc`方法一样，`Free`方法本质上是递归的。如果对`m_pN` extPage 上的`Free`的调用返回了一个`true`值，则检查`Page`以查看它现在是否为空。如果是，则可以释放`Page`。因为`Page`使用一个简单的链接列表来跟踪页面，你必须确保你没有孤立列表的尾部。你需要确保当前页面的`m_pNextPage`指针被设置为指向被释放的`Page`的`m_pNextPage`指针。在`Free`方法中调用`IsEmpty`方法；这个方法的主体如清单 10-24 所示。

[***清单 10-24***](#_list24) 。`Page::IsEmpty`法

```
bool IsEmpty() const
{
    bool isEmpty{ true };

    for (unsigned int i = 0; i < NUM_PAGES; ++i)
    {
        if (m_Free[i] == false)
        {
            isEmpty = false;
            break;
        }
    }

    return isEmpty;
}
```

`IsEmpty`方法检查空闲列表以确定页面当前是否被使用。如果`Page`中的任何一个块不空闲，那么`Page`就不是空的。页面链表是通过另一个名为`SmallBlockAllocator`的类来访问的。这简化了调用代码的页面管理。清单 10-25 显示了`SmallBlockAllocator`类。

***[清单 10-25](#_list25) 。***`SmallBlockAllocator`类

```
class SmallBlockAllocator
{
public:
    static const unsigned int BLOCK_SIZE{ 32 };

private:
    static const unsigned int NUM_ BLOCKS { 1024 };
    static const unsigned int PAGE_SIZE{ NUM_ BLOCKS * BLOCK_SIZE };

    class Page
    {
    private:
        char m_Memory[PAGE_SIZE];
        bool m_Free[NUM_ BLOCKS];
        Page* m_pNextPage;

    public:
        Page()
            : m_pNextPage{ nullptr }
        {
            memset(m_Free, 1, NUM_ BLOCKS);
        }

        ~Page()
        {
            if (m_pNextPage)
            {
                delete m_pNextPage;
                m_pNextPage = nullptr;
            }
        }

        void* Alloc()
        {
            void* pMem{ nullptr };

            for (unsigned int i = 0; i < NUM_ BLOCKS; ++i)
            {
                if (m_Free[i] == true)
                {
                    m_Free[i] = false;
                    pMem = &m_Memory[i * BLOCK_SIZE];
                    break;
                }
            }

            if (pMem == nullptr)
            {
                if (m_pNextPage == nullptr)
                {
                    m_pNextPage = new Page();
                }

                pMem = m_pNextPage->Alloc();
            }

            return pMem;
        }

        bool Free(void* pMem)
        {
            bool freed{ false };

            bool inPage{ pMem >= m_Memory &&
                pMem <= &m_Memory[(NUM_ BLOCKS * BLOCK_SIZE) - 1] };
            if (inPage)
            {
                unsigned int index{
                    (reinterpret_cast<unsigned int>(pMem)-
                     reinterpret_cast<unsigned int>(m_Memory)) / BLOCK_SIZE };
                m_Free[index] = true;
                freed = true;
            }
            else if (m_pNextPage)
            {
                freed = m_pNextPage->Free(pMem);

                if (freed && m_pNextPage->IsEmpty())
                {
                    Page* old = m_pNextPage;
                    m_pNextPage = old->m_pNextPage;
                    old->m_pNextPage = nullptr;
                    delete m_pNextPage;
                }
            }

            return freed;
        }

        bool IsEmpty() const
        {
            bool isEmpty{ true };

            for (unsigned int i = 0; i < NUM_BLOCKS; ++i)
            {
                if (m_Free[i] == false)
                {
                    isEmpty = false;
                    break;
                }
            }

            return isEmpty;
        }
    };

    Page m_FirstPage;

public:
    SmallBlockAllocator() = default;

    void* Alloc()
    {
        return m_FirstPage.Alloc();
    }

    bool Free(void* pMem)
    {
        return m_FirstPage.Free(pMem);
    }
};
```

在清单 10-25 的[中，`Page`类可以被视为`SmallBlockAllocator`的内部类。这有助于确保只有`SmallBlockAllocator`本身可以用作`Page`对象的接口。`SmallBlockAllocator`首先创建静态常量来控制块的大小和每个`Page`包含的块数。从`SmallBlockAllocator`公开的公共方法只有一个`Alloc`方法和一个`Free`方法。这些简单地包装对`Page::Alloc`和`Page::Free`的调用，并在成员`m_FirstPage`上调用。这意味着`SmallBlockAllocator`类总是至少有一页内存分配给小的分配，并且只要`SmallBlockAllocator`处于活动状态，这一页就会驻留在你的程序中。](#list25)

[清单 10-26](#list26) 显示了重载的`new`和`delete`操作符，它们需要将小额分配路由到`SmallBlockAllocator`。

[***清单 10-26***](#_list26) 。将小额分配路由至`SmallBlockAllocator`

```
static SmallBlockAllocator sba;

void* operator new(unsigned int numBytes)
{
    void* pMem{ nullptr };

    if (numBytes <= SmallBlockAllocator::BLOCK_SIZE)
    {
        pMem = sba.Alloc();
    }
    else
    {
        pMem = malloc(numBytes);
    }

    return pMem;
}

void* operator new[](unsigned int numBytes)
{
    void* pMem{ nullptr };

    if (numBytes <= SmallBlockAllocator::BLOCK_SIZE)
    {
        pMem = sba.Alloc();
    }
    else
    {
        pMem = malloc(numBytes);
    }

    return pMem;
}

void operator delete(void* pMemory)
{
    if (!sba.Free(pMemory))
    {
        free(pMemory);
    }
}

void operator delete[](void* pMemory)
{
    if (!sba.Free(pMemory))
    {
        free(pMemory);
    }
}
```

清单 10-26 中的`new`和`new[]`操作符根据`SmallBlockAllocator`类支持的块大小检查分配的字节数。如果被请求的内存大小小于或等于 SBA 的块大小，则在`static sba`对象上调用`Alloc`方法。如果它较大，则使用`malloc`。两个`delete`函数都在`sba`上调用`Free`。如果`Free`返回`false`，那么被释放的内存不存在于任何小块页面中，并且使用`free`函数被释放。

这涵盖了实现一个简单的小块分配器所需的所有代码。清单 10-27 展示了使用这个类的一个工作示例程序的完整清单。

***[清单 10-27](#_list27) 。*** 一个工作的小块分配器例子

```
#include <cstdlib>
#include <iostream>

using namespace std;

class SmallBlockAllocator
{
public:
    static const unsigned int BLOCK_SIZE{ 32 };

private:
    static const unsigned int NUM_BLOCKS{ 1024 };
    static const unsigned int PAGE_SIZE{ NUM_BLOCKS * BLOCK_SIZE };

    class Page
    {
    private:
        char m_Memory[PAGE_SIZE];
        bool m_Free[NUM_BLOCKS];
        Page* m_pNextPage;

    public:
        Page()
            : m_pNextPage{ nullptr }
        {
            memset(m_Free, 1, NUM_BLOCKS);
        }

        ~Page()
        {
            if (m_pNextPage)
            {
                delete m_pNextPage;
                m_pNextPage = nullptr;
            }
        }

        void* Alloc()
        {
            void* pMem{ nullptr };

            for (unsigned int i{ 0 }; i < NUM_BLOCKS; ++i)
            {
                if (m_Free[i] == true)
                {
                    m_Free[i] = false;
                    pMem = &m_Memory[i * BLOCK_SIZE];
                    break;
                }
            }

            if (pMem == nullptr)
            {
                if (m_pNextPage == nullptr)
                {
                    m_pNextPage = new Page();
                }

                pMem = m_pNextPage->Alloc();
            }

            return pMem;
        }

        bool Free(void* pMem)
        {
            bool freed{ false };

            bool inPage{ pMem >= m_Memory &&
                pMem <= &m_Memory[(NUM_BLOCKS * BLOCK_SIZE) - 1] };
            if (inPage)
            {
                unsigned int index{
                    (reinterpret_cast<unsigned int>(pMem)-
                     reinterpret_cast<unsigned int>(m_Memory)) / BLOCK_SIZE };
                m_Free[index] = true;
                freed = true;
            }
            else if (m_pNextPage)
            {
                freed = m_pNextPage->Free(pMem);

                if (freed && m_pNextPage->IsEmpty())
                {
                    Page* old = m_pNextPage;
                    m_pNextPage = old->m_pNextPage;
                    old->m_pNextPage = nullptr;
                    delete m_pNextPage;
                }
            }

            return freed;
        }

        bool IsEmpty() const
        {
            bool isEmpty{ true };

            for (unsigned int i{ 0 }; i < NUM_BLOCKS; ++i)
            {
                if (m_Free[i] == false)
                {
                    isEmpty = false;
                    break;
                }
            }

            return isEmpty;
        }
    };

    Page m_FirstPage;

public:
    SmallBlockAllocator() = default;

    void* Alloc()
    {
        return m_FirstPage.Alloc();
    }

    bool Free(void* pMem)
    {
        return m_FirstPage.Free(pMem);
    }
};

static SmallBlockAllocator sba;

void* operator new(size_t numBytes, const std::nothrow_t& tag) noexcept
{
    void* pMem{ nullptr };

    if (numBytes <= SmallBlockAllocator::BLOCK_SIZE)
    {
        pMem = sba.Alloc();
    }
    else
    {
        pMem = malloc(numBytes);
    }

    return pMem;
}

void* operator new[](size_t numBytes, const std::nothrow_t& tag) noexcept
{
    void* pMem{ nullptr };

    if (numBytes <= SmallBlockAllocator::BLOCK_SIZE)
    {
        pMem = sba.Alloc();
    }
    else
    {
        pMem = malloc(numBytes);
    }

    return pMem;
}

void operator delete(void* pMemory)
{
    if (!sba.Free(pMemory))
    {
        free(pMemory);
    }
}

void operator delete[](void* pMemory)
{
    if (!sba.Free(pMemory))
    {
        free(pMemory);
    }
}

int main(int argc, char* argv[])
{
    const unsigned int NUM_ALLOCS{ 2148 };
    int* pInts[NUM_ALLOCS];

    for (unsigned int i{ 0 }; i < NUM_ALLOCS; ++i)
    {
        pInts[i] = new int;
        *pInts[i] = i;
    }

    for (unsigned int i{ 0 }; i < NUM_ALLOCS; ++i)
    {
        delete pInts[i];
        pInts[i] = nullptr;
    }

    return 0;
}
```