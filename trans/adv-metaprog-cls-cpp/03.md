第三章

![image](../Images/image00564.jpeg)

静态编程

模板非常善于迫使编译器和优化器只在生成可执行程序时执行一些工作。根据定义，这叫做*静态*工作。这与动态工作相反，动态工作指的是程序运行时所做的事情。

有些活动必须在运行时之前完成(计算整数常量)，有些活动对运行时有影响(为函数模板生成机器码，稍后执行)。

TMP 可以产生两种类型的代码——元函数，完全是静态的(例如，元函数 unsigned_integer <n>:::返回至少包含 N 位的整数的类型)和混合算法，部分是静态的，部分是运行时的。(STL 算法依赖于 iterator_category 或者 4.1.2 节解释的 zeroize 函数。</n>

本节讨论编写高效元函数的技巧。

3.1.使用预处理器进行静态编程

编写自己做出决定的程序的经典方式是通过预处理指令。C++预处理器可以执行一些整数计算测试，并删除不合适的代码部分。

考虑下面的例子。您希望将固定长度的无符号整数类型(如 uint32_t)定义为正好 32 位宽，并对任何 2 的幂的位长做同样的事情。

规定

```
template <size_t S>
struct uint_n;

#define mXT_UINT_N(T,N) \
   template <> struct uint_n<N> { typedef T type; }
```

并对当前平台上确实支持的所有大小的 uint_n 进行专门化。

如果用户尝试 uint _ n<16>:::type，但没有合适的类型，她将得到一个适当的、可理解的编译器错误(关于缺少模板专门化)。

所以你得让预处理器通过试错法 [<sup class="calibre7">1</sup>](#Fn1) 算出尺寸:

```
#include <climits>

#define MXT_I32BIT      0xffffffffU
#define MXT_I16BIT      0xffffU
#define MXT_I8BIT       0xffU

#if (UCHAR_MAX == MXT_I8BIT)
mXT_UINT_N(unsigned char,8);
#endif

#if (USHRT_MAX == MXT_I16BIT)
mXT_UINT_N(unsigned short,16);
#elif UINT_MAX == MXT_I16BIT
mXT_UINT_N(unsigned int,16);
#endif

#if (UINT_MAX == MXT_I32BIT)
mXT_UINT_N(unsigned int,32);
#elif (ULONG_MAX == MXT_I32BIT)
mXT_UINT_N(unsigned long,32);
#endif
```

这段代码可以工作，但是它相当脆弱，因为预处理器和编译器之间的交互是有限的。 [<sup class="calibre7">2</sup>](#Fn2)

请注意，这不仅仅是一个通用风格的争论(宏与模板)，而是一个正确性的问题。如果预处理器删除了源文件的某些部分，那么在宏定义改变之前，编译器没有机会诊断所有的错误。另一方面，如果 TMP 决策依赖于编译器看到一整套模板，那么它只实例化其中的一部分。

![Image](../Images/image00563.jpeg) **注**预处理器并不“邪恶”。

像前面的例子一样，基于预处理器的“元编程”通常会编译得更快，并且——如果简单的话——具有很高的可移植性。许多高端服务器仍然附带不支持基于语言(模板)的元编程的旧的或定制的编译器。另一方面，我应该提到的是，虽然编译器倾向于 100%符合标准，但对于预处理程序来说却不是这样。因此，晦涩的预处理器技巧可能无法产生预期的结果，并且由于误用预处理器而导致的错误很难被发现。 [<sup class="calibre7">3</sup>](#Fn3)

第 3.6.10 节展示并解释了不依赖于预处理器的 uint_n 实现。

3.2.编译复杂度

当类模板被实例化时，编译器生成:

*   班级级别的每个成员签名
*   所有静态常数和类型定义
*   只有严格必要的函数体

如果在同一个编译单元中再次需要同一个实例，可以通过查找找到它(这不需要特别高效，但仍然比实例化快)。

例如，给定以下代码:

```
template <size_t N>
struct sum_of_integers_up_to
{
   static const size_t value = N + sum_of_integers_up_to<N-1>::value;
};

template <>
struct sum_of_integers_up_to<0>
{
   static const size_t value = 0;
};

   int n9 = sum_of_integers_up_to<9>::value;            // mov dword ptr [n9],2Dh
   int n8 = sum_of_integers_up_to<8>::value;            // mov dword ptr [n8],24h
```

n9 的初始化有 10 个模板实例化的开销，但是 n8 的后续初始化有*一个*查找的开销(不是 9)。正如汇编代码所示，这两条指令对运行时没有任何影响。

通常，大多数元函数都是使用递归实现的。编译复杂度是元函数本身递归需要的模板实例的数量。

这个例子有线性复杂度，因为 X < N >的实例化需要 X < N-1 >...X < 0 >。虽然您通常希望寻找复杂度最低的实现(以减少编译时间，而不是执行时间)，但是如果有大量的代码重用，您可以跳过这种优化。因为查找的原因，X < N >的第一次实例化会很昂贵，但是它允许 X < M >在同一个翻译单元中免费实例化，如果 M < N。

考虑这个优化的低复杂度实施的例子:

```
template <size_t N, size_t K>
struct static_raise
{
   static const size_t value = /* N raised to K */;
};
```

平凡的实现具有线性复杂度:

```
template <size_t N, size_t K>
struct static_raise
{
   static const size_t value = N * static_raise<N, K-1>::value;
};

template <size_t N>
struct static_raise<N, 0>
{
   static const size_t value = 1;
};
```

为了获得 static_raise <n>:::值，编译器需要产生 K 个实例:static_raise <n>，static_raise <n>，...</n></n></n>

最终 static_raise <n>需要 static_raise <n>，这是已知的(因为有一个显式的专门化)。这停止了递归。</n></n>

然而，有一个公式只需要大约 log(K)个中间类型:

![Image](../Images/image00563.jpeg) **注意**如果指数是 2 的幂，通过重复平方可以节省大量乘法运算。要计算 X <sup class="calibre7">8</sup> ，如果可以只存储中间结果，只需要三次乘法。由于 X<sup class="calibre7">8</sup>=((X<sup class="calibre7">2</sup>)<sup class="calibre7">2</sup>)<sup class="calibre7">2</sup>，需要执行

```
t = x*x; t = t*t; t = t*t; return t;
```

通常，您可以递归地使用标识:

![Image](../Images/image00568.jpeg)

```
#define MXT_M_SQ(a)         ((a)*(a))

template <size_t N, size_t K>
struct static_raise;

template <size_t N>
struct static_raise<N, 0>
{
   static const size_t value = 1;
};

template <size_t N, size_t K>
struct static_raise
{
private:
   static const size_t v0 = static_raise<N, K/2>::value;

public:
   static const size_t value = MXT_M_SQ(v0)*(K % 2 ? N : 1);
};
```

注意 MXT_M_SQ 的使用(参见第 1.3.2 节)。

最后一句话:仅仅因为元函数的自然实现包含递归，并不意味着任何递归实现都是最优的。 [<sup class="calibre7">4</sup>](#Fn4)

假设 N 是一个以 10 为基数的整数，你想提取第 I 个数字(姑且认为数字 0 是最右边的)作为数字*:::*

```
template <int I, int N>
struct digit;
```

很明显，你有两个选择。一个是主类本身的“完全”递归

```
template <int I, int N>
struct digit
{
   static const int value = digit<i-1, N/10>::value;
};

template <int N>
struct digit<0, N>
{
   static const int value = (N % 10);
};
```

或者可以引入一个辅助类主类:

```
template <int I>
struct power_of_10
{
   static const int value = 10 * power_of_10<I-1>::value;
};

template <>
struct power_of_10<0>
{
   static const int value = 1;
};

template <int I, int N>
struct digit
{
   static const int value = (N / power_of_10<I>::value) % 10;
};
```

虽然第一种实现显然更简单，但第二种实现的伸缩性更好。如果你需要从 100 个不同的随机数中抽取第 8 个<sup class="calibre7">位</sup>，前者将产生 800 个不同的特化，因为重用的机会非常低。从数字<812345678>开始，编译器必须产生序列数字<71234567>，数字<6123456>...，并且这些类中的每一个很可能在整个程序中只出现一次。

另一方面，后一个版本产生 8 个不同的 10 的特殊幂，每次都可以重用，所以编译器的工作负载只是 100+10 个类型。

3.3.经典元编程习惯用法

元函数可以被看作是接受一个或多个类型并返回类型或常量的函数。在这一节中，您将看到如何实现一些基本操作。

二元运算符由两个变量的元函数代替。概念 T1==T2 成为 typeequal < T1，T2 > ::value:

```
template <typename T1, typename T2>
struct typeequal
{
   static const bool value = false;
};

template <typename T>
struct typeequal<T, T>
{
   static const bool value = true;
};
```

只要有可能，您应该从保存结果的基本类派生，而不是引入新的类型/常数。请记住，公共继承是由 struct 隐含的

```
template <typename T1, typename T2>
struct typeequal : public selector<false>      // redundant
{
};

template <typename T>
struct typeequal<T, T> : selector<true>        // public
{
};
```

三元运算符测试？T1 : T2 成为 type if<test t1="" t2="">:::type:</test>

```
template <bool STATEMENT, typename T1, typename T2>
struct typeif
{
   typedef T1 type;
};

template <typename T1, typename T2>
struct typeif<false, T1, T2>
{
   typedef T2 type;
};
```

或者，根据前面的准则:

```
template <bool STATEMENT, typename T1, typename T2>
struct typeif : instance_of<T1>
{
};

template <typename T1, typename T2>
struct typeif<false, T1, T2> : instance_of<T2>
{
};
```

派生的强烈动机是更容易使用标记技术。因为您经常将元函数结果“嵌入”在选择器中，所以将元函数本身用作选择器会更容易。假设您有两个用随机元素填充一个范围的函数:

```
template <typename iterator_t>
void random_fill(iterator_t begin, iterator_t end, selector<false>)
{
   for (; begin != end; ++begin)
      *begin = rand();
}

template <typename iterator_t>
void random_fill(iterator_t begin, iterator_t end, selector<true>)
{
   for (; begin != end; ++begin)
      *begin = 'A' + (rand() % 26);
}
```

比较调用:

```
random_fill(begin, end, selector<typeequal<T, char*>::value>());
```

用更简单的 [<sup class="calibre7">5</sup>](#Fn5) :

```
random_fill(begin, end, typeequal<T, char*>());
```

![Image](../Images/image00563.jpeg) **注意**好奇的注意到，在它们的保护宏中存储版本号的头文件可以在类型 if 中使用。比较以下片段

```
#include "myheader.hpp"

typedef
typename typeif<MXT_MYHEADER_==0x1000, double, float>::type float_t;

#if MXT_MYHEADER_ == 0x1000
typedef double float_t;
#else
typedef float float_t;
#endif
```

如果 MXT_MYHEADER_ 未定义，第一个代码段将不会编译。预处理器会表现得好像变量为 0 一样。

3.3.1.静态短路

作为模板递归的案例研究，让我们比较静态和动态操作符的伪代码:

```
template <typename T>
struct F : typeif<[[CONDITION]], T, typename G<T>::type>
{
};

int F(int x)
{
   return [[CONDITION]] ? x : G(x);
}
```

这些陈述*不*类似:

*   运行时语句被短路。除非必要，否则它不会*执行*代码，所以 G(x)可能永远不会运行。
*   静态操作符将总是*编译*所有提到的实体，只要提到它们的一个成员。所以第一个 F 会触发 G<T>:::type 的编译，不考虑结果被使用的事实(也就是说，即使条件为真)。

不存在自动静态短路。如果被低估了，这可能会增加构建时间而没有额外的好处，而且可能不会被注意到，因为结果无论如何都是正确的。

可以使用额外的“间接方式”重写该表达式:

```
template <typename T>
struct F
{
   typedef
      typename typeif<[[CONDITION]], instance_of<T>, G<T> >::type
      aux_t;
   typedef typename aux_t::type type;
};
```

这里只提 G <t>，不提 G<t>:::type。当编译器处理 typeif 时，它只需要知道第二个和第三个参数是有效类型；也就是说，它们已经被声明。如果条件为假，aux_t 被设置为 G <t>。否则，设置为<t>的 instance_of。因为还没有请求成员，所以没有编译任何其他内容。最后，最后一行触发编译<t>的 instance _ 或 G <t>。</t></t></t></t></t></t>

所以，如果条件为真，G<t>:::type 永远不会被使用。G <t>甚至可能缺少定义，或者可能不包含名为 type 的成员。</t></t>

总结一下:

*   尽可能延迟访问成员
*   包装物品以利用界面

相同的优化适用于常数:

```
static const size_t value = [[CONDITION]] ? 4 : alignment_of<T>::value;

typedef typename
  typeif<[[CONDITION]], static_value<size_t, 4>, alignment_of<T>>::type
  aux_t;

static const size_t value = aux_t::value;
```

起初，看起来似乎不需要一些特殊的逻辑运算符，因为模板 [<sup class="calibre7">6</sup>](#Fn6) 中允许整数上的所有默认运算符:

```
template <typename T1, typename T2>
struct naive_OR
{
   static const bool value = (T1::value || T2::value);   // ok, valid
};
```

C++里经典的逻辑运算符都短路了；也就是说，如果第一个操作符足以返回一个结果，他们就不会对第二个操作符求值。类似地，你可以写一个静态 OR，它不需要*编译*它的第二个参数。如果 T1::value 为 true，则 T2::value 永远不会被访问，甚至可能不存在(以类似方式获得)。

```
// if (T1::value is true)
//   return true;
// else
//   return T2::value;

template <bool B, typename T2>
struct static_OR_helper;

template <typename T2>
struct static_OR_helper<false, T2> : selector<T2::value>
{
};

template <typename T2>
struct static_OR_helper<true, T2> : selector<true>
{
};

template <typename T1, typename T2>
struct static_OR : static_OR_helper<T1::value, T2>
{
};
```

3.4.隐藏模板参数

一些类模板可能有未记录的模板参数，通常是自动推导出来的，它们默默地选择正确的专门化。这是标签分发的配套技术，下面是一个例子:

```
template <typename T, bool IS_SMALL_OBJ = (sizeof(T)<sizeof(void*))>
class A;

template <typename T>
class A<T, true>
{
   // implementation follows
};

template <typename T>
class A<T, false>
{
   // implementation follows
};
```

通常，的用户将接受默认设置:

```
A<char> c1;
A<char, true> c2;   // exceptional case. do at own risk
```

下面是出现在[3]中的一个例子的变体。

```
template <size_t N>
struct fibonacci
{
   static const size_t value =
      fibonacci<N-1>::value + fibonacci<N-2>::value;
};

template <>
struct fibonacci<0>
{
   static const size_t value = 0;
};

template <>
struct fibonacci<1>
{
   static const size_t value = 1;
};
```

可以使用隐藏的模板参数重写它:

```
template <size_t N, bool TINY_NUMBER = (N<2)>
struct fibonacci
{
   static const size_t value =
      fibonacci<N-1>::value + fibonacci<N-2>::value;
};

template <size_t N>
struct fibonacci<N, true>
{
   static const size_t value = N;
};
```

为了防止默认值被更改，您可以通过添加后缀 _helper 来重命名原始类，从而在中间引入一个层:

```
template <size_t N, bool TINY_NUMBER>
struct fibonacci_helper
{
   // all as above
};

template <size_t N>
class fibonacci : fibonacci_helper<N, (N<2)>
{
};
```

3.4.1.隐藏参数上的静态递归

让我们计算一个无符号整数 x 的最高位。假设 x 的类型为 size_t，如果 x==0，它通常会返回-1。

非递归算法将是:set N = size _ t 的比特数；测试第 N-1 位，然后第 N-2 位...等等，直到找到一个非零位。

首先，像往常一样，一个天真的实现:

```
template <size_t X, size_t K>
struct highest_bit_helper
{
   static const int value =
      ((X >> K) % 2) ? K : highest_bit_helper<X, K-1>::value;
};

template <size_t X>
struct highest_bit_helper<X, 0>
{
   static const int value = (X % 2) ? 0 : -1;
};

template <size_t X>
struct static_highest_bit
: highest_bit_helper<X, CHAR_BIT*sizeof(size_t)-1>
{
};
```

正如所写的那样，它是可行的，但是编译器可能需要为每个静态计算生成大量不同的类(也就是说，对于任何 X，您传递给 static_highest_bit)。

首先，您可以使用二分法重做算法。假设 X 有 N 位，将其分成上半部分和下半部分(U 和 L ),分别有(N-N/2)和(N/2)位。如果 U 是 0，用 L 代替 X；否则，将 X 替换为 U，并记住将结果递增(N/2) [<sup class="calibre7">7</sup>](#Fn7) :

在伪代码中:

```
size_t hibit(size_t x, size_t N = CHAR_BIT*sizeof(size_t))
{
   size_t u = (x>>(N/2));
   if (u>0)
      return hibit(u, N-N/2) + (N/2);
   else
      return hibit(x, N/2);
}
```

这意味着:

```
template <size_t X, int N>
struct helper
{
   static const size_t U = (X >> (N/2));

   static const int value =
      U ? (N/2)+helper<U, N-N/2>::value : helper<X, N/2>::value;
};
```

正如所写的，每个助手<x n="">诱导编译器再次实例化模板*两次*——即助手< U，N-N/2 >和助手< X，N/2>——即使只使用一个。</x>

静态短路可以减少编译时间，如果将所有算法都移到类型内部，效果会更好。 [<sup class="calibre7">8</sup>](#Fn8)

```
template <size_t X, int N>
struct helper
{
   static const size_t U = (X >> (N/2));

   static const int value = (U ? N/2 : 0) +
            helper<(U ? U : X), (U ? N-N/2 : N/2)>::value;
};
```

这肯定不太清楚，但对编译器来说更方便。

因为 N 是 X 的位数，所以最初 N>0。

当 N==1 时，可以终止静态递归:

```
template <size_t X>
struct helper<X, 1>
{
   static const int value = X ? 0 : -1;
};
```

最后，您可以使用 static_value 的派生来存储结果:

```
template <size_t X>
struct static_highest_bit
: static_value<int, helper<X, CHAR_BIT*sizeof(size_t)>::value>
{
};
```

递归深度是固定的和对数的。static_highest_bit <x>对 x 的每个值最多实例化五六个类。</x>

3.4.2.访问主模板

伪参数可以允许专门化回调主模板。

假设您有两个算法，一个用于计算 cos(x ),另一个用于计算 sin(x ),其中 x 是任意浮点类型。最初，代码组织如下:

```
template <typename float_t>
struct trigonometry
{
   static float_t cos(const float_t x)
   {
      // ...
   }

   static float_t sin(const float_t x)
   {
      // ...
   }
};

template <typename float_t>
inline float_t fast_cos(const float_t x)
{
   return trigonometry<float_t>::cos(x);
}

template <typename float_t>
inline float_t fast_sin(const float_t x)
{
   return trigonometry<float_t>::sin(x);
}
```

后来有人为 cos <float>写另一个算法，而不是为 sin <float>写。</float></float>

您可以为 float 专门化/重载 fast_cos，或者使用隐藏模板参数，如下所示:

```
template <typename float_t, bool = false>
struct trigonometry
{
   static float_t cos(const float_t x)
   {
      // ...
   }

   static float_t sin(const float_t x)
   {
      // ...
   }
};

template <>
struct trigonometry<float, false>
{
   static float_t cos(const float_t x)
   {
      // specialized algorithm here
   }

   static float_t sin(const float_t x)
   {
      // calls the general template
      return trigonometry<float, true>::sin(x);
   }
};
```

请注意，在专门化该类时，并不要求您编写<float false="">。您只需输入:</float>

```
template <>
struct trigonometry<float>
{
```

因为第二个参数的默认值可以从声明中得知。

任何专门化都可以通过显式地将 Boolean 设置为 true 来访问相应的通用函数。

这项技术将在 7.1 节再次出现。

一个类似的技巧可以方便地使局部专门化变得明确。

C++不允许专门化一个模板两次，即使专门化是相同的。特别是，如果您混合使用标准类型定义和整数的大小写，代码会变得不可移植:

```
template <typename T>
struct is_integer
{
   static const bool value = false;
};

template < > struct is_integer<short>
{ static const bool value = true; };

template < > struct is_integer<int>
{ static const bool value = true; };

template < > struct is_integer<long>
{ static const bool value = true; };

template < > struct is_integer<ptrdiff_t>    // problem:
{ static const bool value = true; };         // may or may not compile
```

如果 ptrdiff_t 是第四种类型，比如 long long，那么所有的专门化都是不同的。或者，如果 ptrdiff_t 只是一个 long 类型定义，那么代码是不正确的。相反，这是可行的:

```
template <typename T, int = 0>
struct is_integer
{
   static const bool value = false;
};

template <int N> struct is_integer<short, N>
{ static const bool value = true; };
template <int N> struct is_integer<int  , N>
{ static const bool value = true; };
template <int N> struct is_integer<long , N>
{ static const bool value = true; };

template <>
struct is_integer<ptrdiff_t>
{
   static const bool value = true;
};
```

因为 is_integer <ptrdiff_t>比 is_integer <long n="">更加专门化，所以它将被明确地使用。 [<sup class="calibre7">9</sup>](#Fn9)</long></ptrdiff_t>

这种技术的伸缩性不好，但是可以通过添加更多未命名的参数来扩展到少量的类型定义。这个例子使用了 int，但是任何东西都可以，比如 bool = false 或者 typename = void。

```
template <typename T, int = 0, int = 0>
struct is_integer
{
   static const bool value = false;
};

template <int N1, int N2>
struct is_integer<long, N1, N2>
{ static const bool value = true; };

template <int N1>
struct is_integer<ptrdiff_t, N1>
{ static const bool value = true; };

template < >
struct is_integer<time_t>
{ static const bool value = true; };
```

3.4.3.歧义消除

在 TMP 中，生成从同一个基(间接)派生几次的类是很常见的。现在还不是列举完整例子的时候，所以这里有一个简单的例子:

```
template <int N>
struct A {};

template <int N>
struct B : A<N % 2>, B<N / 2> {};

template <>
struct B<0> {};
```

例如，B <9>的继承链如图 3-1 中的[所示。](#Fig1)

![9781484210116_Fig03-01.jpg](../Images/image00569.jpeg)

[图 3-1](#_Fig1) 。B 的继承链< 9 >

注意，A <0>和 A <1>出现了几次。这是允许的，除了你不能显式或隐式地将 B <9>转换为 A <0>或<1>:

```
template <int N>
struct A
{
   int getN() { return N; }
};

template <int N>
struct B : A<N % 2>, B<N / 2>
{
   int doIt() { return A<N % 2>::getN(); }    // error: ambiguous
};
```

您可以做的是添加一个隐藏的模板参数，以便不同级别的继承对应于物理上不同的类型。

最流行的歧义消除参数是计数器:

```
template <int N, int FAKE = 0>
struct A {};

template <int N, int FAKE = 0>
struct B : A<N % 2, FAKE<sup class="calibre7">11</sup>>, B<N / 2, FAKE+1> {};

template <int FAKE>
struct B<0, FAKE> {};
```

![9781484210116_Fig03-02.jpg](../Images/image00570.jpeg)

图 3-2。使用计数器修改 B <9>的继承链

另一个常用的消歧标记是 this 类型:

```
template <int N, typename T>
struct A {};

template <int N>
struct B : A<N % 2, B<N> >, B<N/2> {};

template <>
struct B<0> {};
```

![9781484210116_Fig03-03.jpg](../Images/image00571.jpeg)

图 3-3。使用标签类型修改 B <9>的继承链

这个观点在 5.2 节中被广泛使用

3.5.特质

Traits 类(或简称 traits)是一个静态函数、类型和常量的集合，抽象了一个类型 T 的公共接口，更准确地说，对于所有代表相同概念的 T，traits < T >是一个类模板，允许你统一操作 T。特别是，所有特征< T >都有相同的公共接口。 [<sup class="calibre7">12</sup>](#Fn12)

使用 traits，可以通过部分或完全忽略 T 类型的公共接口来处理它。这使得 traits 成为算法的最佳构建层。

为什么忽略 T 的公共接口？主要原因是因为它可能没有或可能不合适。

假设 T 表示一个“字符串”，你想得到 T 的一个实例的长度，T 可能是 const char*或者 std::string，但是你想让同一个调用对两者都有效。否则，将无法编写模板字符串函数。此外，0 作为“字符”可能对某些 T 有特殊的意义，但不是对所有 T。

第一个关于特质的严格定义是内森·迈尔斯在 1995 年写的一篇文章。

这种技术的动机是，当编写类模板或函数时，您会意识到一些类型、常量或原子操作是“main”模板参数的参数。

所以你可以放入额外的模板参数，但这通常是不切实际的。您还可以将参数分组到一个 traits 类中。下一个例子和下面的句子都引自迈尔斯的文章 [<sup class="calibre7">14</sup>](#Fn14) :

*因为用户从未提及,【traits class】名称可以很长，并且是描述性的。*

```
template <typename char_t>
struct ios_char_traits
{
};

template <>
struct ios_char_traits<char>
{
    typedef char char_type;
    typedef int  int_type;
    static inline int_type eof() { return EOF; }
};

template <>
struct ios_char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t  int_type;
    static inline int_type eof() { return WEOF; }
};
```

*默认特征类模板为空。对于一个未知的字符类型，任何人都可以说些什么？然而，对于真实的字符类型，您可以专门化模板并提供有用的语义。*

要在流中加入一个新的字符类型，你只需要为新的类型指定 ios_char_traits 。

*注意 ios_char_traits 没有数据成员；它只提供公共定义。现在你可以定义 streambuf 模板 :*

```
template <typename char_t>
class basic_streambuf
```

*注意它只有一个模板参数，用户感兴趣的那个。*

事实上，Myers 用一个正式的定义和一个有趣的观察总结了他的文章:

*特质类:*

*一个用来代替模板参数的类。作为一个类，它集合了有用的类型和常量。作为一个模板，它为解决所有软件问题的“额外间接层”提供了一个途径。*

这种技术在模板必须应用于本机类型，或者不能根据模板操作的需要为其添加成员的任何类型的情况下非常有用。

特征类可以是“全局的”或“局部的”。全局特征在系统中是简单可用的，它们可以在任何地方自由使用。特别是，一个全局 traits 类的所有专门化都有系统范围(所以专门化在任何地方都会自动使用)。事实上，当特征表达平台的属性时，这种方法是首选的。

```
template <typename char_t>
class basic_streambuf
{
   typedef typename ios_char_traits<char_t>::int_type int_type;
   ...
};
```

![Image](../Images/image00563.jpeg) **注意**例如，你可以访问浮点型的最大无符号整数。考虑以下伪代码:

```
template <typename T>
struct largest;

template <>
struct largest<int>
{
   typedef long long type;
};

template <>
struct largest<float>
{
   typedef long double type;
};

template <>
struct largest<unsigned>
{
   typedef unsigned long long type;
};
```

显然，像 maximum<unsigned>:::type 这样的调用应该返回一个在平台中不变的结果，所以所有的定制(如果有的话)应该是全局的，以保持客户端代码的一致性。</unsigned>

更灵活的方法是使用局部特征，将适当的类型作为附加参数传递给每个模板实例(默认为全局值)。

```
template <typename char_t, typename traits_t = ios_char_traits<char_t> >
class basic_streambuf
{
   typedef typename traits_t::int_type int_type;
   ...
};
```

接下来的部分关注一种特殊的特征——纯静态特征，它不包含函数，只包含类型和常量。你会在 4.2 节回到这个论点。

3.5.1.类型特征

有些 traits 类只提供 typedefs，所以它们确实是多值元函数。作为一个例子，再次考虑 std::iterator_traits。

*类型特征* [<sup class="calibre7">15</sup>](#Fn15) 是元函数的集合，提供关于给定类型的限定符的信息和/或改变这样的限定符。信息可以通过 traits 内部的静态机制推导出来，可以通过 traits 类的完全/部分专门化显式提供，也可以由编译器本身提供。 [<sup class="calibre7">16</sup>](#Fn16)

```
template <typename T>
struct is_const : selector<false>
{
};

template <typename T>
struct is_const<const T> : selector<true>
{
};
```

![Image](../Images/image00563.jpeg) **注意**今天，类型特征被拆分以减少编译时间，但历史上它们是具有许多静态常数的大型整体类。

```
template <typename T>
struct all_info_together
{
   static const bool is_class = true;

   static const bool is_pointer = false;
   static const bool is_integer = false;
   static const bool is_floating = false;
   static const bool is_unsigned = false;

   static const bool is_const = false;
   static const bool is_reference = false;
   static const bool is_volatile = false;
};
```

通常，traits 有一个保守默认的通用实现,包括对类型类有意义的值的部分专门化和对单个类型定制的完全专门化。

```
template <typename T>
struct add_reference
{
   typedef T& type;
};

template <typename T>
struct add_reference<T&>
{
   typedef T& type;
};

template < >
struct add_reference<void>
{
   // reference to void is illegal. don't put anything here<sup class="calibre7">17</sup>
};
```

特征通常是递归的:

```
template <typename T>
struct is_unsigned_integer : selector<false>
{
};

template <typename T>
struct is_unsigned_integer<const T> : is_unsigned_integer<T>
{
};

template <typename T>
struct is_unsigned_integer<volatile T> : is_unsigned_integer<T>
{
};

template < >
struct is_unsigned_integer<unsigned int> : selector<true>
{
};

template < >
struct is_unsigned_integer<unsigned long> : selector<true>
{
};

// add more specializations...
```

Traits 可以使用继承然后有选择地隐藏一些成员:

```
template <typename T>
struct integer_traits;

template <>
struct integer_traits<int>
{
   typedef long long largest_type;
   typedef unsigned int unsigned_type;
};

template <>
struct integer_traits<long> : integer_traits<int>
{
   // keeps integer_traits<int>::largest_type
   typedef unsigned long unsigned_type;
};
```

![Image](../Images/image00563.jpeg) **注意**在 C++中，模板基类不在名称解析范围内:

```
template <typename T>
struct BASE
{
   typedef T type;
};

template <typename T>
struct DER : public BASE<T>
{
   type t;   // error: 'type' is not in scope
};
```

然而，从静态的角度来看，DER*是否包含类型成员:*

 *```
template <typename T>
struct typeof
{
   typedef typename T::type type;
};

typeof< DER<int> >::type i = 0;      // ok: int i = 0
```

如果没有仔细设计，类型特征很容易受到困难的概念问题的影响，因为 C++类型系统比它看起来要复杂得多:

```
template <typename T>
struct is_const : selector<false>
{
};

template <typename T>
struct is_const<const T> : selector<true>
{
};

template <typename T>
struct add_const : instance_of<const T>
{
};

template <typename T>
struct add_const<const T> : instance_of<const T>
{
};
```

以下是一些奇怪之处:

*   如果 N 是编译时常数，T 是类型，那么可以形成两种不同的数组类型:T [N]和 T []。 [<sup class="calibre7">18</sup>](#Fn18)
*   像 const 这样应用于数组类型的限定符的行为有点奇怪。如果 T 是一个数组，例如 double [4]，那么 const T 就是“四个 const double 的数组”，而不是“四个 double 的 const 数组”。具体来说，const T 是*而不是* const:

    ```
    typedef double T1;
    typedef add_const<T1>::type T2;
    T2 x = 3.14;                        // x has type const double
    bool b1 = is_const<T2>::value;      // b1 is true

    typedef double T3[4];
    typedef add_const<T3>::type T4;     // T4 is "array of 4 const double"...
    T4 a = { 1,2,3,4 };
    bool b2 = is_const<T4>::value;      // ...which does not match "const T"
                                        // so b2 is false
    ```

因此，您应该添加更多的专门化:

```
template <typename T, size_t N>
struct is_const<const T [N]>
{
   static const bool value = true;
};

template <typename T >
struct is_const<const T []>
{
   static const bool value = true;
};
```

有两种可能的标准可以验证类型:

*   匹配就满足了；例如，const int 匹配 T==int 的 const T。
*   满足逻辑测试；例如，如果 const T 和 T 是同一类型，你可以说 T 是 const。

C++类型的系统非常复杂，在大多数情况下，标准看起来是相同的，但仍然不完全相同。通常，每当出现这样的逻辑问题时，解决方案将来自对您的需求的更精确的推理。对于任何 T，is _ const<t>:::value 为 false，因为 T&不满足与 const 类型的匹配。然而，add_const <t>::type 仍然是 T&(应用于引用的任何限定符都被忽略)。这是否意味着引用是常量？</t></t>

是否应该添加返回 true 的 is_const <t>的专门化？还是真的希望 add_const <t>::type 是 const T&？</t></t>

在 C++中，对象可以有不同程度的常量。更具体地说，它们可以是

*   可分配的
*   不变的
*   常数

被*赋值* 是一个句法属性。可赋值对象可以位于运算符=的左侧。常量引用是不可赋值的。然而实际上，T &在 T 为时是可赋值的。(顺便说一下，赋值会改变被引用的对象，而不是引用，但这无关紧要。)

被*不可变* 是一个逻辑属性。不可变对象在构造后不能被改变，因为它是不可赋值的，或者因为它的赋值不会改变实例的状态。由于不能将引用“指向”另一个对象，所以引用是不可变的。

是一个纯粹的语言属性。如果一个对象的类型与某个 T 的常量 T 匹配，那么这个对象就是常量。常量对象可能有一个简化的接口，operator=可能是受限制的成员函数之一。

引用不是唯一既不可变又可赋值的实体。这种情况可以用自定义操作符= 来重现。

```
template <typename T>
class fake_ref
{
   T* const ptr_;

public:

   // ...

   const fake_ref& operator=(const T& x) const
   {
      *ptr_ = x;       // ok, does not alter the state of this instance
      return *this;
   }
};
```

这也说明了 const 对象可能是可赋值的， [<sup class="calibre7">19</sup>](#Fn19) 但并不意味着引用是 const，只是说可以用 const 对象模拟。

所以标准的方法是提供原子操作的类型特征，用最少的逻辑和一个匹配。is_const <t>:::值应为 false。</t>

然而，类型特征也很容易在用户代码中扩展。如果应用程序需要的话，您可以引入更多的概念，比如“侵入性常数”

```
template <typename T>
struct is_const_intrusive : selector<false>
{
};

template <typename T>
struct is_const_intrusive<const T> : selector<true>
{
};

template <typename T>
struct is_const_intrusive<const volatile T> : selector<true>
{
};

template <typename T>
struct is_const_intrusive<T&> : is_const_intrusive<T>
{
};
```

类型性状有无限的应用；这个例子使用了最简单的。假设 C <t>是一个类模板，它包含一个 T 类型的成员，由构造函数初始化。然而，T 没有限制，特别是它可以是一个参考。</t>

```
template <typename T>
class C
{
   T member_;

public:

   explicit C(argument_type x)
   : member_(x)
   {
   }
};
```

你需要定义 argument_type 。如果 T 是一个值类型，最好通过对 const 的引用来传递它。但是如果 T 是引用，那么写 const T &就是非法的。所以你会写:

```
typedef typename add_reference<const T>::type argument_type;
```

这里，add_reference <t>根据需要返回 const T&。</t>

如果 T 是对 const 的引用或引用，则 const T 是 T，add_reference 返回 T，这意味着参数类型也是 T。

3.5.2.拆除类型

通过添加限定符、考虑引用、指针和数组等等，C++中的一个类型可以生成无限多的“变体”。但是可能发生的情况是，您必须递归地删除所有附加属性，一次删除一个。这个递归过程通常被称为*拆解*。 [<sup class="calibre7">20</sup>](#Fn20)

本节展示了一个名为 copy_q 的元函数，它将所有“限定符”从类型 T1 转移到类型 T2，因此 copy _ q<const double="" int="">:::type 将是 const int&。</const>

类型演绎是完全递归的。一次分解一个属性，并将同一个属性移动到结果中。继续前面的例子，const double&匹配 T&其中 T 是 const double，所以结果是“对 copy_q <const double="" int="">的结果的引用”，这又是“copy_q <double int="">的 const 结果”。由于这不匹配任何专门化，所以它给出 int。</double></const>

```
template <typename T1, typename T2>
struct copy_q
{
   typedef T2 type;
};

template <typename T1, typename T2>
struct copy_q<T1&, T2>
{
   typedef typename copy_q<T1, T2>::type& type;
};

template <typename T1, typename T2>
struct copy_q<const T1, T2>
{
   typedef const typename copy_q<T1, T2>::type type;
};

template <typename T1, typename T2>
struct copy_q<volatile T1, T2>
{
   typedef volatile typename copy_q<T1, T2>::type type;
};

template <typename T1, typename T2>
struct copy_q<T1*, T2>
{
   typedef typename copy_q<T1, T2>::type* type;
};

template <typename T1, typename T2, int N>
struct copy_q<T1 [N], T2>
{
   typedef typename copy_q<T1, T2>::type type[N];
};
```

更完整的实现可以解决由于 T2 作为参考而引起的问题:

```
copy_q<double&, int&>::type err1;    // error: reference to reference
copy_q<double [3], int&>::type err2; // error: array of 'int&'
```

然而，这样的类是否应该安静地解决错误或停止编译是值得怀疑的。我们只需注意声明一个 std::vector <int>是非法的，但是编译器错误并没有被“捕获”:</int>

```
/usr/include/gcc/darwin/4.0/c++/ext/new_allocator.h: In instantiation of '__gnu_cxx::new_allocator<int&>':
/usr/include/gcc/darwin/4.0/c++/bits/allocator.h:83:   instantiated from 'std::allocator<int&>'
/usr/include/gcc/darwin/4.0/c++/bits/stl_vector.h:80:   instantiated from 'std::_Vector_base<int&, std::allocator<int&> >::_Vector_impl'
/usr/include/gcc/darwin/4.0/c++/bits/stl_vector.h:113:   instantiated from 'std::_Vector_base<int&, std::allocator<int&> >'
/usr/include/gcc/darwin/4.0/c++/bits/stl_vector.h:149:   instantiated from 'std::vector<int&, std::allocator<int&> >'
main.cpp:94:   instantiated from here
/usr/include/gcc/darwin/4.0/c++/ext/new_allocator.h:55: error: forming pointer to reference type 'int&'
```

3.6.容器类型

那么什么是类型列表呢？肯定是那种奇怪的模板兽，对吧？

——安德烈·亚历山德雷斯库

模板参数的最大数量是由实现定义的，但是它通常大到足以使用一个类模板作为类型的容器*。 [<sup class="calibre7">21</sup>](#Fn21)*

这一节展示了一些基本的静态算法如何工作，因为将来你会多次重用相同的技术。实际上，在 TMP 中实现大多数 STL 概念是可能的，包括容器、算法、迭代器和函子，其中复杂性需求在编译时被翻译。 [<sup class="calibre7">22</sup>](#Fn22)

这一部分展示了基本技术的概念；稍后您将看到一些应用程序。

最简单的类型容器是*对*(链表的静态等价物)和*数组* (类似于固定长度的 C 风格数组)。

```
template <typename T1, typename T2>
struct typepair
{
   typedef T1 head_t;
   typedef T2 tail_t;
};

struct empty
{
};
```

事实上，您可以使用 pairs 对轻松地存储任意(受合理限制)长度的列表。原则上，你可以形成一个完整的二叉树，但是为了简单起见，一个类型列表(T1，T2...Tn)被表示为类型对<t1 typepair="" ...="">>。换句话说，您将允许第二个组件是一对。实际上，它强制第二个组件成为类型对或空的，这是列表终止符。在伪代码中:</t1>

```
P0 = empty
P1 = typepair<T1, empty >
P2 = typepair<T2, typepair<T1, empty> >
// ...
Pn = typepair<Tn, Pn-1>
```

这顺便说明了使用类型对序列最简单的操作是 push_front。

按照 Alexandrescu 的符号(见[1])，我称这样的编码为*类型列表* 。你说第一个可访问的类型 Tn 是列表的*头*，Pn-1 是*尾*。

或者，如果您将最大长度固定为一个合理的数字，则可以将所有类型存储在一行中。由于缺省值(可以是空的或 void )，您可以在同一行上声明任意数量的参数:

```
#define MXT_GENERIC_TL_MAX         32
// the code "publishes" this value for the benefit of clients

template
<
   typename T1  = empty,
   typename T2  = empty,
   // ...
   typename T32 = empty
>
struct typearray
{
};

typedef typearray<int, double, std::string> array_1;  // 3 items
typedef typearray<int, int, char, array_1> array_2;   // 4 items
```

这些容器的属性是不同的。具有 J 个元素的类型列表要求编译器产生 J 个不同的类型。另一方面，数组是直接访问的，所以为类型数组编写算法需要编写许多(比如 32 个)专门化。类型列表更短，更递归，但是编译起来更费时间。

![Image](../Images/image00563.jpeg) **注**在亚伯拉罕[3]所作的理论建立之前，有一些命名上的混乱。类型对的最初想法是由 Alexandrescu(在[1]和随后在 CUJ)充分发展的，他引入了名称 *typelist* 。

显然，Alexandrescu 也是第一个使用类型数组作为包装器以简单的方式声明长类型列表的人:

```
template <typename T1, typename T2, ..., typename Tn>
struct cons
{
   typedef typepair<T1, typepair<T2, ...> > type;
};
```

然而，名称 *typelist* 仍然被广泛用作更通用类型容器的同义词。

3.6.1 .type at〔t0〕

typeat 是一个元函数，从容器中提取第 n 个类型。

```
struct Error_UNDEFINED_TYPE;      // no definition!

template <size_t N, typename CONTAINER, typename ERR = Error_UNDEFINED_TYPE>
struct typeat;
```

如果第 n 个类型不存在，结果是 ERR。

同一个元函数可以处理类型数组和类型列表。正如预期的那样，数组需要所有可能的专门化。泛型模板只是返回一个错误，然后元函数首先在类型数组上专门化，然后在类型列表上专门化。

```
template <size_t N, typename CONTAINER, typename ERR = Error_UNDEFINED_TYPE>
struct typeat
{
   typedef ERR type;
};

template <typename T1, ... typename T32, typename ERR>
struct typeat<0, typearray<T1, ..., T32>, ERR>
{
   typedef T1 type;
};

template <typename T1, ... typename T32, typename ERR>
struct typeat<1, typearray<T1, ..., T32>, ERR>
{
   typedef T2 type;
};

// write all 32 specializations
```

用于类型列表的相同代码更加简洁。列表的第 N 个类型被声明为等于列表尾部的第(N-1)个类型。如果 N 为 0，则结果为头部类型。但是，如果遇到空列表，结果是 ERR。

```
template <size_t N, typename T1, typename T2, typename ERR>
struct typeat<N, typepair<T1, T2>, ERR>
{
   typedef typename typeat<N-1, T2, ERR>::type type;
};

template <typename T1, typename T2, typename ERR>
struct typeat<0, typepair<T1, T2>, ERR>
 {
   typedef T1 type;
};

template <size_t N, typename ERR>
struct typeat<N, empty, ERR>
{
   typedef ERR type;
};
```

注意，无论使用什么索引，typeat <n typearray="">>只需要一个模板实例化。typeat <n typepair="">>可能需要 N 个不同的实例化。</n></n>

还要注意较短的实现:

```
template <size_t N, typename T1, typename T2, typename ERR>
struct typeat<N, typepair<T1, T2>, ERR> : typeat<N-1, T2, ERR>
{
};
```

3.6.2.返回一个错误

当元函数 F <t>未定义时，例如 typeat <n empty="" err="">，返回错误的常见选项包括:</n></t>

*   完全移除 F <t>的主体。</t>
*   给 F <t>一个空体，没有结果(类型或值)。</t>
*   定义 F<t>:::type，如果使用的话会导致编译错误(void 或者没有定义的类)。</t>
*   使用用户提供的错误类型定义 F<t>:::type(如前所示)。</t>

请记住，强制编译器错误是相当激烈的；这类似于抛出异常。很难忽略这一点，但是伪类型更像是返回 false。false 可以很容易地转换为 throw，而伪类型可以转换为编译器错误(静态断言就足够了)。

3.6.3.深度

借助一些简单的宏 [<sup class="calibre7">23</sup>](#Fn23) ，处理类型数组会更容易:

```
#define MXT_LIST_0(T)
#define MXT_LIST_1(T)   T##1
#define MXT_LIST_2(T)   MXT_LIST_1(T), T##2
#define MXT_LIST_3(T)   MXT_LIST_2(T), T##3
// ...
#define MXT_LIST_32(T)  MXT_LIST_31(T), T##32
```

令人惊讶的是，您可以编写看起来极其简单明了的类声明。下面是一个例子(预处理前后)。

```
template <MXT_LIST_32(typename T)>
struct depth< typelist<MXT_LIST_32(T)> >

template <typename T1, ... , typename T32>
struct depth< typelist<T1, ... T32> >
```

名为 depth 的元函数返回类型列表的长度:

```
template <typename CONTAINER>
struct depth;

template <>
struct depth< empty > : static_value<size_t, 0>
{
};

template <typename T1, typename T2>
struct depth< typepair<T1, T2> > : static_value<size_t, depth<T2>::value+1>
{
};
```

*   主模板未定义，因此深度<int>不可用。</int>
*   如果类型列表的深度是 K，编译器必须生成 K 个不同的中间类型(即深度<p1>...深度<pn>其中 Pj 是列表的第 j 个尾部)。</pn></p1>

对于类型数组，再次使用宏。typearray <>的深度为 0；typearray <t1>的深度为 1；而实际上 typearray <mxt_list_n>的深度是 n</mxt_list_n></t1>

```
template <MXT_LIST_0(typename T)>
struct depth< typearray<MXT_LIST_0(T)> >
: static_value<size_t, 0> {};

template <MXT_LIST_1(typename T)>
struct depth< typearray<MXT_LIST_1(T)> >
: static_value<size_t, 1> {};

// ...

template <MXT_LIST_32(typename T)>
struct depth< typearray<MXT_LIST_32(T)> >
: static_value<size_t, 32> {};
```

请注意，即使恶意用户在中间插入一个假的空分隔符，depth 也会返回最后一个非空类型的位置:

```
typedef typearray<int, double, empty, char> t4;
depth<t4>::value; // returns 4
```

事实上，这个调用将匹配深度<t1 t2="" t3="" t4="">，其中恰好 T3 =空。</t1>

在任何情况下，empty 都应该被限制在一个不可访问的名称空间中。

3.6.4.前后

本节向您展示了如何从两个类型容器中提取第一个和最后一个类型。

```
template <typename CONTAINER>
struct front;

template <typename CONTAINER>
struct back;
```

首先，当容器为空时，您会导致一个错误:

```
template <>
struct back<empty>;

template <>
struct front<empty>
{
};
```

虽然 front 很简单，但 back 会遍历整个列表:

```
template <typename T1, typename T2>
struct front< typepair<T1, T2> >
{
   typedef T1 type;
};

template <typename T1>
struct back< typepair<T1, empty> >
{
   typedef T1 type;
};

template <typename T1, typename T2>
struct back< typepair<T1, T2> >
{
   typedef typename back<T2>::type type;
};
```

或者简单地说:

```
template <typename T1, typename T2>
struct back< typepair<T1, T2> > : back<T2>
{
};
```

对于类型数组，你利用了深度和类型的速度非常快的事实，你简单地做了一些自然的事情，比如说，一个向量。后面的元素是大小为-1 的元素。原则上，这也适用于类型列表，但是它会在整个列表中“迭代”几次(每次“迭代”都会导致一个新类型的实例化)。

```
template <MXT_LIST_32(typename T)>
struct back< typearray<MXT_LIST_32(T)> >
{
   typedef typelist<MXT_LIST_32(T)> aux_t;
   typedef typename typeat<depth<aux_t>::value – 1, aux_t>::type type;
};

template <>
struct back< typearray<> >
{
};

template <MXT_LIST_32(typename T)>
struct front< typearray<MXT_LIST_32(T)> >
{
   typedef T1 type;
};

template <>
struct front< typearray<> >
{
};
```

3.6.5.找到

您可以执行顺序搜索，并返回与给定 T 匹配的(第一个)类型的索引。如果 T 没有出现在 CONTAINER 中，您将返回一个常规数字(比如-1)，而不是导致编译器错误。

递归版本的代码基本如下:

*   没有任何东西属于空容器。
*   一对元素中的第一个元素的索引为 0。
*   索引是 1 加上尾部 T 的索引，除非后一个索引是未定义的。

```
template <typename T, typename CONTAINER>
struct typeindex;

template <typename T>
struct typeindex<T, empty>
{
   static const int value = (-1);
};

template <typename T1, typename T2>
struct typeindex< T1, typepair<T1, T2> >
{
   static const int value = 0;
};

template <typename T, typename T1, typename T2>
struct typeindex< T, typepair<T1, T2> >
{
   static const int aux_v = typeindex<T, T2>::value;
   static const int value = (aux_v==-1 ? -1 : aux_v+1);
};
```

类型数组的第一个实现是:

```
/* tentative version */

template <MXT_LIST_32(typename T)>
struct typeindex< T1, typearray<MXT_LIST_32(T)> >
{
   static const int value = 0;
};

template <MXT_LIST_32(typename T)>
struct typeindex< T2, typearray<MXT_LIST_32(T)> >
{
   static const int value = 1;
};

// ...
```

如果要查找的类型与数组中的第一个类型相同，则值为 0；如果它等于数组中的第二个类型，则值为 1，依此类推。不幸的是，下面的*是不正确的*:

```
typedef typearray<int, int, double> t3;

int i = typeindex<int, t3>::value;
```

有不止一个匹配项(即前两个)，这会产生一个编译错误。我把这个问题的解决推迟到下一节之后。

3.6.6.推动和弹出

前面已经提到，类型对最简单的操作是 push_front。只需将新的头部类型与旧的容器包装在一起:

```
template <typename CONTAINER, typename T>
struct push_front;

template <typename T>
struct push_front<empty, T>
{
   typedef typepair<T, empty> type;
};

template <typename T1, typename T2, typename T>
struct push_front<typepair<T1, T2>, T>
{
   typedef typepair< T, typepair<T1, T2> > type;
};
```

很自然，pop_front 也很简单:

```
template <typename CONTAINER>
struct pop_front;

template <>
struct pop_front<empty>;

template <typename T1, typename T2>
struct pop_front< typepair<T1, T2> >
{
   typedef T2 type;
};
```

要对类型数组实现相同的算法，必须采用一个非常重要的技术，名为*模板旋转* ***。*** 该旋转将所有模板参数向左(或向右)移动一个位置。

```
template <P1, P2 = some_default, ..., PN = some_default>
struct container
{
   typedef container<P2, P3, ..., PN, some_default> tail_t;<sup class="calibre7">24</sup>
};
```

由 pop_front 产生的类型称为容器的 *tail* (这就是为什么源代码反复引用 tail_t 的原因)。

参数不必是类型。下面的类计算正整数列表中的最大值。

```
#define MXT_M_MAX(a,b)       ((a)<(b) ? (b) : (a))

template <size_t S1, size_t S2=0, ... , size_t S32=0>
struct typemax : typemax<MXT_M_MAX(S1, S2), S3, ..., S32>
{
};

template <size_t S1>
struct typemax<S1,0,0,...,0> : static_value<size_t, S1>
{
};
```

顺便提一下，只要可行，加速旋转是很方便的。在前面的示例中，您应该编写

```
template <size_t S1, size_t S2=0, ... , size_t S32=0>
struct typemax
: typemax<MXT_M_MAX(S1, S2), MXT_M_MAX(S3, S4), ..., MXT_M_MAX(S31, S32)>
{
};
```

要计算 N 个常数的最大值，只需要 typemax 的 log2(N)个实例，而不是 N 个。

很容易将旋转和宏与优雅结合 [<sup class="calibre7">25</sup>](#Fn25) :

```
template <typename T0, MXT_LIST_31(typename T)>
struct pop_front< typearray<T0, MXT_LIST_31(T)> >
{
   typedef typearray<MXT_LIST_31(T)> type;
};

template <MXT_LIST_32(typename T), typename T>
struct push_front<typearray<MXT_LIST_32(T)>, T>
{
   typedef typearray<T, MXT_LIST_31(T)> type;
};
```

使用 pop_front，您可以实现通用的顺序查找。注意，为了清楚起见，您想要添加一些中间的 typedefs。与元编程一样，类型相当于经典 C++中的变量。您可以将 typedefs 视为等同于(命名的)临时变量。此外，私有和公共部分有助于将“临时”变量从结果中分离出来:

您在这里要遵循的程序是:

*   空容器中 T 的索引是-1。
*   数组<t1 ...="">中 T1 的索引为 0(这一点毫无疑问地成立，即使 T1 出现不止一次)。</t1>
*   要获得 T 在数组<t1 t2="" t3="" ...="">中的索引，需要计算它在一个旋转数组中的索引，并将结果加 1。

    ```
    template <typename T>
    struct typeindex<T, typearray<> >
    {
       static const int value = (-1);
    };

    template <MXT_LIST_32(typename T)>
    struct typeindex< T1, typearray<MXT_LIST_32(T)> >
    {
       static const int value = 0;
    };

    template <typename T, MXT_LIST_32(typename T)>
    struct typeindex< T, typearray<MXT_LIST_32(T)> >
    {
    private:
       typedef typearray<MXT_LIST_32(T)> argument_t;
       typedef typename pop_front<argument_t>::type tail_t;

       static const int aux_v = typeindex<T, tail_t>::value;

    public:
       static const int value = (aux_v<0) ? aux_v : aux_v+1;
    };
    ```</t1> 

3.6.7.关于模板旋转的更多信息

模板参数可以很容易地旋转；然而，从左到右消费通常更简单。假设您想通过输入以 10 为基数的所有数字来合成一个整数。这里有一些伪代码。

```
template <int D1, int D2 = 0, ... , int DN = 0>
struct join_digits
{
   static const int value = join_digits<D2, ..., DN>::value * 10 + D1;
};

template <int D1>
struct join_digits<D1>
{
   static const int value = D1;
};

join_digits<3,2,1>::value;      // compiles, but yields 123, not 321
```

相反，观察到在旋转中消耗 DN 并不容易。这将不会编译，因为每当 DN 等于它的缺省值(零)时，值就根据它本身来定义:

```
template <int D1, int D2 = 0, ..., int DN-1 = 0, int DN = 0>
struct join_digits
{
  static const int value = join_digits<D1,D2, ...,D<sub class="calibre19">N-1</sub>>::value * 10 + DN;
};
```

向右旋转不会产生正确的结果:

```
template <int D1, int D2 = 0, ..., int DN-1 = 0, int DN = 0>
struct join_digits
{
  static const int value = join_digits<0,D1,D2, ...,D<sub class="calibre19">N-1</sub>>::value * 10 + DN;
};
```

解决方案是简单地存储辅助常数，并从尾部借用它们:

```
template <int D1 = 0, int D2 = 0, ..., int DN = 0>
struct join_digits
{
   typedef join_digits<D2, ..., DN> next_t;
   static const int pow10 = 10 * next_t::pow10;
   static const int value = next_t::value + D1*pow10;
};

template <int D1>
struct join_digits<D1>
{
   static const int value = D1;
   static const int pow10 = 1;
};

join_digits<3,2,1>::value;      // now really gives 321
```

模板旋转有两种方式:

*   直接旋转主模板(如上所示):

    ```
    template <int D1 = 0, int D2 = 0, ..., int DN = 0>
    struct join_digits
    { ... };

    template <int D1>
    struct join_digits<D1>
    { ... };
    ```

*   参数的旋转。这增加了额外的“间接性”:

    ```
    template <int D1 = 0, int D2 = 0, ..., int DN = 0>
    struct digit_group
    {
       // empty
    };

    template <typename T>
    struct join_digits;      // primary template not defined

    template <int D1, int D2, ..., int DN>
    struct join_digits< digit_group<D1, ..., DN> >
    {
       // as above
    };

    template <>
    struct join_digits< digit_group<> >
    {
       // as above
    };
    ```

第一种解决方案通常更容易编码。然而，第二种有两个重要的优点:

*   “携带”模板参数元组的 T 类型可以重用。t 通常是某种类型的容器。
*   暂时假设 join_digits <...>是一个真类(不是元函数)，它实际上被实例化了。编写接受任何 join_digits 实例的通用模板将会很容易。他们只需要取 join_digits <x>。但是，如果 join_digits 有一个很长且不确定数量的参数，客户端将不得不像 X. [<sup class="calibre7">26</sup>](#Fn26) 那样处理它</x>

3.6.8.结块

pop_front 中封装的旋转技术可以用来创建元组作为*aggregate 对象*。

在合成中，聚集 A 是一个在其模板参数中包含类型容器 C 的类。该类使用 front <c>并递归继承自 A < pop_front<c>>。“使用”front 类型的最简单方法是声明该类型的成员。在伪代码中:</c></c>

```
template <typename C>
class A : public A<typename pop_front<C>::type>
{
   typename front<C>::type member_;

public:
   // ...
};

template < >
class A<empty>
{
};

template < >
class A< typearray<> >
{
};
```

*   继承可以是公开的、私有的，甚至是受保护的。
*   有两种可能的递归停止器:A <empty_typelist>和 A <empty_typearray>。</empty_typearray></empty_typelist>

因此，一个凝聚体是一个对象包，其类型在容器中列出。如果 C 是 typearray <int double="" std::string="">，A 的布局将如图[图 3-4](#Fig4) 所示。</int>

![9781484210116_Fig03-04.jpg](../Images/image00572.jpeg)

[图 3-4](#_Fig4) 。团聚体 A 的布局

请注意，在所审查的实现中，对象的内存布局相对于类型容器是相反的。

要访问包的元素，您需要再次使用 rotation。假设所有成员都是公共的。通过一个全局函数和一个合适的 traits 类的协作，您将获得对第 n 个聚集成员的引用。

有两种同样好的发展策略:*侵入性特质*和*非侵入性特质*。

*侵入特征*要求团块暴露一些辅助信息:

```
template <typename C>
struct A : public A<typename pop_front<C>::type>
{
   typedef typename front<C>::type value_type;
   value_type member;

   typedef typename pop_front<C>::type tail_t;
};

template <typename agglom_t, size_t N>
struct reference_traits
{
   typedef reference_traits<typename agglom_t::tail_t, N-1> next_t;
   typedef typename next_t::value_type value_type;

   static value_type& ref(agglom_t& a)
   {
      return next_t::ref(a);
   }
};

template <typename agglom_t>
struct reference_traits<agglom_t, 0>
{
   typedef typename agglom_t::value_type value_type;

   static value_type& ref(agglom_t& a)
   {
      return a.member;
   }
};

template <size_t N, typename agglom_t>
inline typename reference_traits<agglom_t,N>::value_type& ref(agglom_t& a)
{
   return reference_traits<agglom_t, N>::ref(a);
}
```

一个简单的例子:

```
typedef typearray<int, double, std::string> C;
A<C> a;

ref<0>(a) = 3;
ref<1>(a) = 3.14;
ref<2>(a) = "3.14";
```

*非侵入性特征*相反，用部分专门化来决定信息:

```
template <typename agglom_t, size_t N>
struct reference_traits;

template <typename C, size_t N>
struct reference_traits< A<C>, N >
{
   typedef reference_traits<typename pop_front<C>::type, N-1> next_t;
   typedef typename front<C>::type value_type;
};
```

在可行的情况下，非侵入性特征是首选。reference_traits 的作者能否修改 a 的定义并不明显。然而，traits 通常需要对象的合理“合作”。此外，自动推导代码是 A 类内部代码的复制，自动推导出的值往往是“刚性的”，因此侵扰性不是一个明显的输家。

一种特殊情况是根据类型列表*建模的不含重复*的团聚体。实现要简单得多，因为用伪造型代替旋转就足够了:

```
template <typename T, typename tail_t>      // cast-like syntax
T& ref(A< typepair<T, tail_t> >& a)         // T is non-deduced
{
   return a.member;
}

typedef  typepair<int, typepair<double, typepair<std::string, empty> > >  C;
A<C> a;

ref<double>(a) = 3.14;
ref<std::string>(a) = "greek pi";
ref<int>(a) = 3;
```

这种转换之所以有效，是因为语法 ref <t>(a)修复了该对的第一个类型，并让编译器匹配后面的尾部。由于唯一性假设，这确实是可能的。</t>

事实上，C++标准允许在参数推导之前进行一次从派生到基的转换，如果这是精确匹配的充分必要条件的话。

这里，将类型 A <c>的参数绑定到对类型 A < typepair<:string tail_t="">的引用的唯一方法是将其转换为类型对<:string empty="">，然后推导出 tail_t = empty。</c>

为了存储从一个聚集中提取的值，声明一个 reference _ traits<agglom_t>:::value _ type 类型的对象。</agglom_t>

最后，稍微多一点侵入性，您只需将一个成员函数添加到:

```
template <typename C>
struct A : public A< typename pop_front<C>::type >
{
   typedef typename front<C>::type value_type;
   value_type member;

   typedef typename pop_front<C>::type tail_t;

   tail_t& tail() { return *this; }
};

template <typename agglom_t, size_t N>
struct reference_traits
{
   // ...

   static value_type& get_ref(agglom_t& a)
   {
      return next_t::get_ref(a.tail());
   }
};
```

调用成员函数而不是隐式转换允许您切换到私有继承，甚至切换到 has-a 关系:

```
template <typename C>
class A
{
public:
   typedef typename pop_front<C>::type tail_t;
   typedef typename front<C>::type value_type;

private:
   A<tail_t> tail_;
   value_type member;

public:
   tail_t& tail() { return tail_; }

   // ...
};
```

对象的内存布局现在与类型容器的顺序相同。

3.6.9.转换

许多算法实际上需要线性数量的递归步骤，对于类型列表和类型数组都是如此。实际上，类型对表示满足了大多数实际目的，除了一个:类型列表的声明确实是不可行的。

正如预期的那样，从类型数组转换到类型列表非常容易，反之亦然。

提供一个统一的实现 [<sup class="calibre7">27</sup>](#Fn27) 是一个有趣的练习:

```
template <typename T>
struct convert
{
   typedef typename pop_front<T>::type tail_t;
   typedef typename front<T>::type head_t;

   typedef
     typename push_front<typename convert<tail_t>::type, head_t>::type
     type;
};

template <>
struct convert< typearray<> >
{
   typedef empty type;
};

template <>
struct convert< empty >
{
   typedef typearray<> type;
};
```

请注意，此代码中的 T 是泛型类型容器，而不是泛型类型。

之前，您使用部分模板专门化来防止*错误的静态参数类型*。例如，如果你尝试 front<int>:::type，编译器将输出 front 不能在 int 上实例化(如果你没有定义主模板)或者它不包含成员类型(如果它是空的)。

然而，这种保护在这里是不必要的。convert 构建在 front 和 pop_front 之上，它们将执行所需的参数验证。在这种情况下，编译器将诊断出在 convert <int>内实例化的 front <int>是非法的。</int></int>

问题只是一个不太清楚的调试信息。在您必须纠正问题的选项中，您可以编写类型特征来标识类型容器，然后放置断言:

```
template <typename T>
struct type_container
{
   static const bool value = false;
};

template <typename T1, typename T2>
struct type_container< typepair<T1, T2> >
{
   static const bool value = true;
};

template <>
struct type_container<empty>
{
   static const bool value = true;
};

template <MXT_LIST_32(typename T)>
struct type_container< typearray<MXT_LIST_32(T)> >
{
   static const bool value = true;
};

template <typename T>
struct convert
   : static_assert< type_container<T>::value >
{
   //...
```

很有可能，编译器会发出指向断言行的第一个错误。

![Image](../Images/image00563.jpeg) **注**5.2 节完全致力于坏的静态参数类型。您将会遇到这样的函数模板，它们静态地将其模板参数限制为那些具有特定接口的模板参数。

通过插入表示该类型的空容器的类型来扩展类型容器特征是有用的(主模板不变)。

```
template <typename T1, typename T2>
struct type_container< typepair<T1, T2> >
{
   static const bool value = true;
   typedef empty type;
};

template <>
struct type_container<empty>
{
   static const bool value = true;
   typedef empty type;
};

template <MXT_LIST_32(typename T)>
struct type_container< typearray<MXT_LIST_32(T)> >
{
   static const bool value = true;
   typedef typearray<> type;
};
```

当足够多的“低级”元函数——如 front、back、push_front 等——可用时，大多数元算法将在数组和列表上工作。您只需要两个不同的递归终止，以及一个对 typearray <>的专门化和一个对 empty 的专门化。

另一个选择是*空-空成语*:让一个 helper 类把原始类型容器作为 T 和第二个类型，第二个类型是同类的空容器(从 traits 获得)。当这些相等时，你停下来。

```
template <typename T>
struct some_metafunction
: static_assert<type_container<T>::value>
, helper<T, typename type_container<T>::type>
{
};

template <typename T, typename E>
struct helper
{
   // general case:
   // T is a non-empty type container of any kind
   // E is the empty container of the same kind
};

template <typename E>
struct helper<E, E>
{
   // recursion terminator
};
```

3.6.10.元函数

用户函子、谓词和二元运算可以用模板-模板参数替换。下面是一个简单的元函数:

```
template <typename T>
struct size_of
{
   static const size_t value = CHAR_BIT*sizeof(T);
};

template <>
struct size_of<void>
{
   static const size_t value = 0;
};
```

下面是一个简单的二元元关系:

```
template <typename X1, typename X2>
struct less_by_size : selector<(sizeof(X1) < sizeof(X2))>
{
};

template <typename X>
struct less_by_size<void, X> : selector<true>
{
};

template <typename X>
struct less_by_size<X, void> : selector<false>
{
};

template <>
struct less_by_size<void, void> : selector<false>
{
};
```

这是一个可能用到它的元函数的框架:

```
template <typename T, template <typename X1, typename X2> class LESS>
struct static_stable_sort
: static_assert< type_container<T>::value >
{
   // write LESS<T1, T2>::value instead of "T1<T2"

   typedef [[RESULT]] type;
};
```

本节不是描述一个实现，而是描述 static_stable 排序的一个可能的应用。假设我们的源代码包含一组返回无符号整数的随机生成器:

```
class linear_generator
{
   typedef unsigned short random_type;
   ...
};

class mersenne_twister
{
   typedef unsigned int random_type;
   ...
};

class mersenne_twister_64bit
{
   typedef /* ... */ random_type;
   ...
};
```

用户将在一个类型容器中列出所有的生成器，按照从最好(首选算法)到最差的顺序。这个容器可以按 sizeof(typename T::random_type)排序。最后，当用户要求 X 类型的随机数时，您扫描排序后的容器并停留在 random_type 至少与 X 大小相同的第一个元素上，然后使用生成器返回值。由于排序是稳定的，第一个合适的类型在用户偏好中也是最好的。

如前所述，我现在转向根据大小(以位为单位)选择无符号整数的问题。

首先，将所有候选对象放入一个类型容器中:

```
typedef typearray<unsigned char, unsigned short, unsigned int,
                  unsigned long, unsigned long long> all_unsigned;
```

您必须从左到右扫描列表，并使用具有指定大小的第一个类型(也可以将特定于编译器的类型追加到列表中)。

![Image](../Images/image00563.jpeg) **注意**这里需要一点代数。根据符号函数的定义，对于任何整数，都有等式δ sign(δ)=|δ|。另一方面，如果 S 是{-1，0，1}中的规定常数，等式δ S=|δ|分别意味着δ≤0，δ=0，δ≥0。这个基本关系允许您用一个整数参数表示三个谓词(小于或等于零、等于零和大于或等于零)。

在下面的代码中，T 是任意类型的容器:

```
#define MXT_M_ABS(a)      ((a)<0 ? –(a) : (a))

enum
{
   LESS_OR_EQUAL = -1,
   EQUAL = 0,
   GREATER_OR_EQUAL = +1
};

template
<
   typename T,
   template <typename X> class SIZE_OF,
   int SIGN,
   size_t SIZE_BIT_N
>
struct static_find_if
: static_assertion< type_container<T>::value >
{
   typedef typename front<T>::type head_t;

   static const int delta = (int)SIZE_OF<head_t>::value – (int)SIZE_BIT_N;

   typedef typename typeif
   <
      SIGN*delta == MXT_M_ABS(delta),
      front<T>,
      static_find_if<typename pop_front<T>::type,
                     SIZE_OF, SIGN, SIZE_BIT_N>
   >::type aux_t;

   typedef typename aux_t::type type;
};

// define an unsigned integer type which has exactly 'size' bits

template <size_t N>
struct uint_n
: static_find_if<all_unsigned, size_of, EQUAL, N>
{
};

// defines an unsigned integer type which has at least 'size' bits

template <size_t N>
struct uint_nx
: static_find_if<all_unsigned, size_of, GREATER_OR_EQUAL, N>
{
};

typedef uint_n<8>::type uint8;
typedef uint_n<16>::type uint16;
typedef uint_n<32>::type uint32;
typedef uint_n<64>::type uint64;

typedef uint_nx<32>::type uint32x;
```

注意，选择模板参数的顺序是为了清楚地说明*使用的是* static_find_if，而不是 static_find_if 本身。 [<sup class="calibre7">28</sup>](#Fn28)

如果找不到合适的类型会怎么样？任何无效的使用都将展开长时间的错误级联(代码已被编辑以抑制大部分干扰):

```
uint_n<25>::type i0 = 8;
uint_nx<128>::type i1 = 8;

error C2039: 'type' : is not a member of 'front<typearray<>>'
                               : see declaration of 'front<typearray<>>'
                               : see reference to class template instantiation
'static_find_if<T,SIZE_OF,SIZE_BIT_N,SIGN>' being compiled
        with
        [
T=pop_front<pop_front<pop_front<pop_front<pop_front<all_unsigned>::type>::type>::type>::type>::type,
        ]
                            : see reference to class template instantiation 'static_find_if<T,SIZE_OF,SIZE_BIT_N,SIGN>' being compiled
        with
        [

  T=pop_front<pop_front<pop_front<pop_front<all_unsigned>::type>::type>::type>::type,
        ]
                            : see reference to class template instantiation
'static_find_if<T,SIZE_OF,SIZE_BIT_N,SIGN>' being compiled
        with
        [
T=pop_front<pop_front<pop_front<all_unsigned>::type>::type>::type,
        ]
[...]
                        : see reference to class template instantiation
'static_find_if<T,SIZE_OF,SIZE_BIT_N,SIGN>' being compiled
        with
        [
            T=all_unsigned,
        ]
                       : see reference to class template instantiation
'uint_n<SIZE_BIT_N>' being compiled
        with
        [
            SIZE_BIT_N=25
        ]
```

基本上，编译器是在说，在 uint _ n<25>:::type 的演绎过程中，在将 pop_front 应用于类型数组五次之后，它以一个空容器结束，该容器没有 front 类型。

然而，很容易得到一个更易于管理的报告。作为递归终止符的结果，您只是添加了一个未定义的类型:

```
template
<
   template <typename X> class SIZE_OF,
   int SIGN,
   size_t SIZE_BIT_N
>
struct static_find_if<typearray<>, SIZE_OF, SIGN, SIZE_BIT_N>
{
   typedef error_UNDEFINED_TYPE type;
};
```

现在，错误消息更加简洁:

```
error C2079: 'i0' uses undefined class 'error_UNDEFINED_TYPE'
error C2079: 'i1' uses undefined class 'error_UNDEFINED_TYPE'
```

3.7.风格概述

编程元函数时，识别:

*   暗示性的名称和语法。
*   表达概念需要哪些模板参数。
*   该算法依赖于哪些原子动作。
*   递归的高效实现。
*   必须隔离的特殊情况。

如果元函数的名称类似于一个经典算法(比如 find_if)，那么您可以采用一个类似的名称(static_find_if)，或者甚至是一个相同的名称(比如 typelist::find_if)。

一些作者在纯静态算法后面添加了下划线，因为这允许模仿真实的关键字(typeif 将被称为 if_)。

如果需要几个模板参数，编写代码以便用户能够记住它们的含义和顺序。通过名称给出语法提示是个好主意:

```
: static_find_if<all_unsigned, size_of, GREATER_OR_EQUAL, N>
```

许多不相关的参数应该被分组到一个 traits 类中，该类应该有一个易于复制的默认实现。

最后，下表可以帮助您将经典算法转换为静态算法。

|   | 

经典 C++函数

 | 

静态元编程

 |
| --- | --- | --- |
| 他们所操纵的 | 对象的实例 | 类型 |
| 参数处理 | 通过参数公共接口 | 通过元功能 |
| 处理不同的争论 | 功能霸主 | 部分模板专门化 |
| 回送结果 | 零个或一个返回语句 | 零个或多个静态数据(类型或常量)，通常是继承的 |
| 错误捕捉 | 尝试...捕捉块 | 额外模板参数错误 |
| 用户提供的回调 | 函子 | 模板-模板参数 |
| 临时对象 | 局部变量 | 私有 typedef/静态常量 |
| 函数调用 | 是的，作为子程序 | 是的，也是通过推导 |
| 算法结构 | 迭代或递归 | 静态递归，用合适的完整/部分模板专门化停止 |
| 有条件的决定 | 语言结构(if，switch) | 部分专业化 |
| 错误处理 | 抛出异常返回 false | 中止编译不返回结果将结果设置为不完整类型 |

___________________

[<sup class="calibre18">1</sup>](#_Fn1) 记住预处理器在编译器之前运行*，所以它不能依赖 sizeof。*

[<sup class="calibre18">2</sup>](#_Fn2) 再读一遍前面的笔记![image](../Images/image00573.jpeg)。

[<sup class="calibre18">3</sup>](#_Fn3) 另请参见[http://www . boost . org/doc/libs/1 _ 46 _ 0/libs/wave/doc/序言. html](http://www.boost.org/doc/libs/1_46_0/libs/wave/doc/preface.html) 。

[<sup class="calibre18">4</sup>](#_Fn4) 这个例子摘自与马可·马塞罗的一次私人谈话。

[<sup class="calibre18">5</sup>](#_Fn5) 我在书中并不总是使用推导记号，主要是为了清晰。然而，我强烈鼓励在产品代码中采用它，因为它提高了代码重用。

[<sup class="calibre18">6</sup>](#_Fn6) 除了强制转换为非整数类型。比如 N*1.2 是非法的，但是 N+N/5 是可以的。

[<sup class="calibre18">7</sup>](#_Fn7) 实际中，N 总是偶数，所以 N-N/2 == N/2。

[<sup class="calibre18">8</sup>](#_Fn8) 参见第 7.2 节中的双重检查停止。

[<sup class="calibre18">9</sup>](#_Fn9) 我坚持认为问题是可解的，因为 is_integer < long >和 is_integer < ptrdiff_t >的实现是完全相同的；否则，它就是病态的。举个反例，考虑一个 time_t 和 long 转换成字符串的问题；即使 time_t 很长，字符串也需要不同。因此，这个问题不能通过 TMP 技术来解决。

[<sup class="calibre18">10</sup>](#_Fn10) 这是好事，因为一个构建良好的模板类不该需要它。

[<sup class="calibre18">11</sup>](#_Fn11) 在这里，假和假+1 都起作用。

[<sup class="calibre18">12</sup>](#_Fn12) *相同*并不意味着所有功能必须完全相同，因为一些差异可能对“统一使用”产生有限的影响。举个简单的例子，参数可以通过值或常量引用传递。

[<sup class="calibre18">13</sup>](#_Fn13) 可得:cantrip.org/trails.html.文章引用的参考文献有[10]、[11]和[12]。

[<sup class="calibre18">14</sup>](#_Fn14) 句子略有重排。

[<sup class="calibre18">15</sup>](#_Fn15) 由 John Maddock 和 Steve Cleary 引入的术语*类型特征*在这里作为一个普通名称使用，但它也作为一个专有名称而流行，表示一个特定的库实现。参见[http://cppreference.com/header/type_traits](http://cppreference.com/header/type_traits)或[http://www . boost . org/doc/libs/1 _ 57 _ 0/libs/type _ traits/doc/html/index . html](http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/index.html)。

[<sup class="calibre18">16</sup>](#_Fn16) 在现代 C++中，有一个专用的< type_traits >头，它包含了这里描述的大部分元函数，以及许多经典 C++中无法复制的功能。比如 has_trivial_destructor < T >没有编译器的配合是无法还原的，当前的实现总是返回 false，除了内置类型。

[<sup class="calibre18">17</sup>](#_Fn17) 可以定义 add _ reference<void>::type 为 void。

[<sup class="calibre18">18</sup>](#_Fn18) 这是实际使用的。一些智能指针，包括 std::unique_ptr，在类型匹配 T[]时使用操作符 delete []，在任何其他情况下使用单次删除。

[<sup class="calibre18">19</sup>](#_Fn19) 或者，std::pair < const int，double >既不是 const 也不能赋值。

[<sup class="calibre18">20</sup>](#_Fn20) “拆型”这个说法是斯蒂芬·c·杜赫斯特提出来的。

[<sup class="calibre18">21</sup>](#_Fn21)c++标准包含一个信息部分，称为“实现数量”，其中建议了模板参数(1024)和嵌套模板实例化(1024)的最小数量，但编译器不需要考虑这些数量。

[<sup class="calibre18">22</sup>](#_Fn22) 论据上的引用是【3】。

无论如何，boost 预处理器库会更合适，但是它的描述将需要另一个章节。这里，重点是简单的*:一个战略性的手写宏可以显著提高代码的美观性。*

 *[<sup class="calibre18">24</sup>](#_Fn24) 原则上，有些 _default 不应该被明确指定。所有形式的代码重复都会导致维护错误。在这里，我展示它是为了强调旋转。

[<sup class="calibre18">25</sup>](#_Fn25) 参见 3.6.3 节。

这不是问题，如果 join_digits 是一个函子，客户很可能会把它当作 X。

[<sup class="calibre18">27</sup>](#_Fn27) 又是一次拆式练习；还要注意，使用 push_back 而不是 push_front 会反转容器。

[<sup class="calibre18">28</sup>](#_Fn28) 我采用了 find_if 这个名字，带有一些滥用的符号；一个真正的 static_find_if 应该是 static_find_if < typename T，template<typename X>class F>，它返回 T 中的第一个类型，其中 F < X > ::value 为 true。**