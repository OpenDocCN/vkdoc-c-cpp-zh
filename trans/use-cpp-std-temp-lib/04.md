# 4.地图容器

Electronic supplementary material The online version of this chapter (doi:[10.​1007/​978-1-4842-0004-9_​4](http://dx.doi.org/10.1007/978-1-4842-0004-9_4)) contains supplementary material, which is available to authorized users.

通过位置从序列容器中检索元素。例如，您可以通过索引位置访问`deque`的第一个或最后一个元素，或者访问`vector`中的一个元素。地图容器的工作方式完全不同，这一章将会解释。在本章中，您将了解以下内容:

*   什么是关联容器？
*   什么是`map`容器，它通常是如何组织的。
*   可用的`map`容器类型及其功能。
*   `map`容器提供的功能。
*   a `pair`是什么，是用来做什么的。
*   什么是`tuple`以及如何使用它。

## 地图容器简介

序列容器是管理数据的有价值的工具，但是对于大量的应用程序来说，它们并不总是提供方便的数据访问机制。使用名称和地址是一个简单的例子，说明序列容器可能不符合您的要求。典型的操作是查找给定名称的地址。如果记录存储在一个序列容器中，你必须搜索。容器提供了一种更有效地存储和访问这些数据的方式。

地图容器是关联容器。在关联容器中，每个对象都是基于与该对象关联的键值来定位的。键可以是基本类型的值，也可以是类类型的对象。字符串经常被用作键，当您想要存储姓名和地址记录时，这很可能适用；名字是一个或多个字符串。一个对象在关联容器中的位置是如何由一个键决定的取决于容器的具体类型，而特定容器类型的内部组织在不同的 STL 实现中会有所不同。

有四种地图容器，每一种都由一个类模板定义。所有地图容器类型都存储键/值对。map 中的元素是类型为`pair<const K,T>`的对象，这些对象封装了类型为`T`的对象及其相关的类型为`K`的键。容器中 pair 元素的键是`const`,因为允许修改键会破坏容器中元素的顺序。地图容器的类模板各有不同的特征:

*   一个`map<K,T>`容器存储了`pair<const K,T>`类型的元素，这些元素封装了键/对象对，其中键属于`K`类型，对象属于`T`类型。密钥必须是唯一的，因此不允许重复的密钥。只要对象的键不同，就可以存储重复的对象。元素是有序的，容器中元素的顺序是通过比较键来确定的。默认情况下，使用一个`less<K>`对象来比较键。
*   一个`multimap<K,T>`容器类似于一个`map<K,T>`,因为元素是有序的。关键字必须是可比较的，元素的顺序通过比较关键字来确定。不同之处在于允许重复的键。因此一个`multimap`可以存储多个具有相同键值的`pair<const K,T>`元素。
*   一个`unordered_map<K,T>`容器是一个映射，其中的`pair<const K,T>`对象不是直接按照键值排序的。使用从元素的键生成的哈希值来定位元素。哈希值是由一个叫做哈希的过程生成的整数，我将在本章后面解释这个过程。不允许重复的密钥。
*   一个`unordered_multimap<K,T>`容器也使用从键中产生的哈希值来定位对象，但是重复的键是允许的。

在地图头中定义了`map`和`multimap`的模板，在`unordered_map`头中定义了`unordered_map,`和`unordered_multimap`的模板。您可以看到，`map`模板类型名称的任何前缀都标识了容器的特征:

*   前缀`multi`表示键不需要唯一；它的缺失表明键必须是唯一的。
*   `unordered_`前缀表示使用从键生成的哈希值而不是比较键值来将元素放置在容器中。它的缺失意味着元素是通过比较键来排序的。

让我们先来看看`map`集装箱。

## 使用地图容器

在`map`头中定义了`map<K,T>`类模板，它定义了一个存储类型为`T`的对象的映射，每个对象都有一个类型为`K`的相关键。容器中对象的位置是通过比较关键字来确定的。通过提供适当的键值，可以从`map`容器中检索一个对象。图 [4-1](#Fig1) 展示了一个`map<K,T>`容器，其中键是名字，对象是代表年龄值的整数值。

![A978-1-4842-0004-9_4_Fig1_HTML.gif](A978-1-4842-0004-9_4_Fig1_HTML.gif)

图 4-1。

A conceptual representation of a map<K,T> container

图 [4-1](#Fig1) 中表示的容器将是类型`map<Name, size_t>`，其中`Name`类可以这样定义:

`class Name`

`{`

`private:`

`std::string firstname{};`

`std::string secondname{};`

`public:`

`Name(std::string first, std::string second) : firstname{first}, secondname{second}{};`

`Name()=default;`

`bool operator<(const Name& name)`

`{ return secondname < name.secondname ||`

`((secondname == name.secondname) && (firstname < name.firstname)); }`

`};`

存储在容器中的对象通常需要定义一个默认的构造函数，以允许在必要时创建默认元素。用于`Name`对象的`operator<()`函数将名称与`secondname`成员进行比较，当它们不同时确定顺序。如果`secondname`成员相等，则`firstname`成员确定比较结果。`string`类定义了`operator<()`，所以默认的`less<string>`比较将正常工作。

不要被使用`less<K>`对`map`中的元素进行排序所误导——这些元素并不是简单有序的序列。STL `map`容器没有特定的组织要求，但是通常元素存储在一个平衡的二叉树中。平衡二叉树中的元素被组织成使得树的高度——根节点和叶节点之间的层数——最小化。如果每个节点的左子树的高度与其右子树的高度相差不超过 1，则称二叉树是平衡的。图 [4-2](#Fig2) 显示了图 [4-1](#Fig1) 所示地图的一种可能的平衡树配置。

![A978-1-4842-0004-9_4_Fig2_HTML.gif](A978-1-4842-0004-9_4_Fig2_HTML.gif)

图 4-2。

Internal organization of a map container

图 [4-2](#Fig2) 中的树有三层，所以任何元素都可以在距离根最多三步的地方找到。选择根节点以最小化树高度，并且对于每个父节点，左侧子节点的键小于父节点的键，右侧子节点的键大于父节点的键。添加新元素会导致需要不同的根节点来保持平衡的树排列。显然，当元素被添加到容器中时，维护平衡的树组织会产生一些开销。这样做的好处是，与顺序排列或非平衡树相比，检索元素会更快，容器中的元素越多，平衡树组织就越有效。从包含`n`个元素的平衡二叉树中检索一个随机元素的时间是`O(log`<sub>`2`</sub>`n)`；从序列中检索元素的时间是`O(n)`。

Note

计算机操作上下文中的`O(n)`符号描述了当参数增加时，执行操作的时间是如何增加的。把`O`想成是暗示“的顺序”。O(n)表示执行时间随`n.`线性增加，执行一个`O(log` <sub>`2`</sub> `n)`操作的时间增加比`n`增加慢得多——因为它与`log` <sub>`2`</sub> `n`成正比。

### 创建地图容器

`map`类模板有四个类型参数，但是通常你只需要为前两个指定值。第一个是键的类型，第二个是要存储的对象的类型。第三和第四个模板参数分别定义用于比较键的函数对象的类型和用于在映射中分配内存的对象的类型。最后两个被赋予了默认值。在本节的稍后部分，我将展示如何定义不同类型的函数对象来比较键，但是我不会去定义替代的分配器类型。

一个`map<>`容器类的默认构造函数创建一个空映射。例如，下面是如何创建一个将年龄值存储为类型`size_t`并以类型`string`的名称作为关键字的地图容器:

`std::map<std::string, size_t> people;`

第一个模板类型参数指定键的类型为`string`，第二个模板类型参数指定值的类型为`size_t`。当然，这里的模板类型参数可以是任何类型，唯一的要求是使用`less<K>`键必须是可比较的，或者一个可选的函数对象类型，如果你指定它的话。

`map<K,T>`中的每个元素都是一个类型为`pair<const K,T>`的对象，它封装了一个对象和它的键，其中`const K`意味着键不能被修改。`r the pair<T1,T2>`类的模板在`utility`头中定义，包含在`map`头中。因此,`people`容器中的元素将是类型`pair<const string, size_t>`。`pair<T1,T2>`模板类型并不专门用于这种情况。必要时，您可以自己使用它将两个不同类型的对象打包成一个对象。在这一章的后面我会有更多的话要说。

您可以使用初始化列表来指定映射中的初始值，但是由于映射包含`pair<const K,T>`元素，初始化列表中的值必须是这种类型。下面是如何为`people`容器指定初始值:

`std::map<std::string, size_t> people{ {"Ann", 25}, {"Bill", 46}, {"Jack", 32}, {"Jill", 32} };`

初始化列表中的值是通过将每个嵌套括号对之间的两个值传递给`pair`构造函数来创建的。因此，该列表将包含四个`pair<const string, size_t>`对象。

`utility`头定义了`make_pair<T1, T2>()`函数模板，它提供了一种组合`T1`和`T2`类型对象的便捷方式。因此，您可以创建 pair 对象来初始化一个`map`，如下所示:

`std::map<std::string, size_t> people{ std::make_pair("Ann", 25), std::make_pair("Bill", 46),`

`std::make_pair("Jack", 32), std::make_pair("Jill", 32) };`

`make_pair<T1, T2>()`函数模板从函数参数中推导出类型参数值，因此列表中由`make_pair<>()`调用返回的对象将是类型`pair<char const*, int>`。因为这些是`people`贴图的初始值，这些`pair`对象将被转换成贴图中元素的类型，即`pair<const string, size_t>`。一个`pair<T1,T2>`对象有公共成员`first`和`second`，分别存储`T1`和`T2`对象。`pair<T1,T2>`构造函数的模板提供了`pair`对象的隐式转换，只要原始`pair`对象的`first`和`second`成员可以隐式转换为目标`pair`对象的相同成员的类型。

`map<K,T>`模板定义了移动和复制构造函数，因此您可以复制一个现有的容器。例如:

`std::map<std::string, size_t> personnel {people};   // Duplicate people map`

`personnel`地图将包含`people`中`pair`元素的副本。

您可以从另一个容器中的一系列`pair`元素创建一个映射。通过 begin 和 end 迭代器以通常的方式指定元素。显然，迭代器必须指向与容器兼容的类型的`pair`元素。这里有一个例子:

`std::map<std::string, size_t> personnel {std::begin(people), std::end(people)};`

这创建了`personnel`，并用`people`容器的迭代器标识的元素初始化它。`map`容器产生双向迭代器，所以你可以增加和减少它们。一个`map`也提供了反向迭代器，所以你可以从最后一个到第一个访问元素。`personnel`地图将包含与`people`地图相同的元素。当然，您可以用另一个容器中的元素子集创建一个容器:

`std::map<std::string, size_t> personnel {++std::begin(people), std::end(people)};`

### 在地图中插入元素

有几个版本的`map<K,T>`容器的`insert()`函数成员在`map`中插入一个或多个`pair<const K,T>`对象。元素只有在地图中不存在时才会被插入。下面的代码片段说明了如何插入单个元素:

`std::map<std::string, size_t> people {std::make_pair("Ann", 25), std::make_pair("Bill", 46),`

`std::make_pair("Jack", 32), std::make_pair("Jill", 32)};`

`auto pr = std::make_pair("Fred", 22);                             // Create a pair element...`

`auto ret_pr = people.insert(pr);                                 // ..and insert it`

`std::cout << ret_pr.first->first << " " << ret_pr.first->second`

`<< " " << std::boolalpha << ret_pr.second << " \n";    // Fred 22 true`

第一条语句创建了`map`容器，并用初始化列表中的四个值初始化它；在这种情况下，这些将被隐式转换为所需的类型。第二条语句创建了另一个要插入的`pair`对象。因为`make_pair<>()`函数模板的类型参数是从参数类型中推导出来的，所以`pr`对象将属于类型`pair<const char*, int>`，但是这个对象将在`insert()`操作中被隐式转换为容器元素类型。当然，如果您不想依赖隐式转换，您可以创建所需类型的`pair`对象:

`auto pr = std::make_pair<std::string, size_t>(std::string {"Fred"}, 22);`

`make_pair<>()`模板的显式模板类型参数决定了返回的`pair`对象的类型。您可以提供一个字符串作为第一个参数，隐式转换将被应用于创建键所需的`string`对象。您可以省略`make_pair<>()`的模板类型参数，让编译器推导它们。假设您将语句写成:

`auto pr = std::make_pair("Fred", 22);                            // pair<const char*, int>`

`pair`对象将不同于所需的类型。当您允许编译器推导模板类型参数时，`make_pair()`的参数会准确地决定`pair`的模板类型参数。第一个参数是类型为`const char*`的文字，第二个参数是类型为`int`的文字。话虽如此，但这在这种情况下并不重要，因为当您插入新元素时，`pair`对象可以隐式转换为容器所需的类型。需要小心的时候是没有从参数类型到容器中键和对象类型的隐式转换的时候。

`insert()`函数成员返回一个`pair<iterator, bool>`对象。对象的`first`成员是一个迭代器，它或者指向被插入的元素，或者指向阻止插入的元素。如果一个对象已经用相同的键存储在映射中，则是后一种情况。返回的对象的`second`成员是一个`bool`值，如果插入成功，该值为`true`，否则为`false`。正如您在输出语句中看到的，访问被插入的对的第一个成员的表达式是`ret_pr.first->first`；`ret_pr`的`first`成员是一个指向`pair`对象的迭代器，所以您使用`->`操作符来访问它所指向的对象的`first`成员。输出显示该元素已被插入。您可以通过执行以下循环来验证这一点:

`for(const auto& p : people)`

`std::cout << std::setw(10) << std::left << p.first << " " << p.second << " \n";`

循环变量`p`将通过引用依次访问`people`图中的每个元素。输出将是:

`Ann        25`

`Bill       46`

`Fred       22`

`Jack       32`

`Jill       32`

这些元素按照关键字的升序排列，因为默认的`less<string>`函数对象用于在地图中对它们进行排序。

通过执行以下两条语句，您可以看到插入一个已经存在的元素的效果:

`ret_pr = people.insert(std::make_pair("Bill", 48));`

`std::cout << ret_pr.first->first << " " << ret_pr.first->second`

`<< " " << std::boolalpha << ret_pr.second << "\n";     // Bill 46 false`

这产生的输出显示在注释中。由`insert()`返回的 pair 对象的`first`成员指向已经在 map 中的具有匹配键的元素，并且`second`成员是`false`以指示不能进行插入。

如果您真的希望当元素存在时键`"Bill"`的年龄值被修改为`48`，您可以使用`insert()`返回的`pair`对象来实现，如下所示:

`if(!ret_pr.second)                                             // If the element is there...`

`ret_pr.first->second = 48;                                   // ... change the age`

当键已经存在于`map`中时,`ret_pr`的第二个成员是`false`,所以这段代码将把值`48`赋给 map 中元素的`second`成员。

您可以使用`pair`构造函数来创建要插入到`insert()`的参数中的对象:

`ret_pr = people.insert(std::pair<const std::string, size_t> {"Bill", 48});`

这将调用一个有右值引用参数的版本`insert()`,所以元素将被移动到容器中，假设它还不存在。

另一个选项允许您提供一个关于元素应该插入到哪里的提示。该提示以迭代器的形式指向`map,`中的现有元素，并且该提示被用作开始搜索新元素插入位置的地方。好的提示可以加快插入操作；一个不好的暗示会适得其反。例如:

`auto ret_pr = people.insert(std::make_pair("Jim", 48));`

`people.insert(ret_pr.first, std::make_pair("Ian", 38));`

第一条语句插入一个元素并返回一个`pair`对象，如前所述。这个`pair`对象的第一个成员是一个迭代器，它或者指向被插入的元素，或者指向与被插入的元素具有相同键的现有元素。下一个`insert()`调用中的第一个参数对应于提示，所以这里的提示是刚刚插入的元素。新元素由`insert(),`的第二个参数指定，它将被插入到由提示标识的元素之前，并尽可能靠近它。如果提示不能以这种方式使用，它将被忽略。同样，如果要插入的元素在地图中，操作会失败。带有提示的`insert()`调用返回一个迭代器，指向插入的元素，或者指向阻止插入的元素。因此，您可以使用返回值来确定插入是否成功。因此，当您确定元素不存在时，最好只提供插入提示。如果你不确定，还是想给点提示，地图上的`count()`成员可以帮忙。它返回给定键的 map 中元素的数量，并且只能是`0`或`1`。因此，您可以写:

`if(!people.count("Ian"))`

`people.insert(ret_pr.first, std::make_pair("Ian", 38));`

只有当`count()`返回 0，表明`"Ian"`键不在`map`中时，`insert()`调用才会发生。当然，你可以在没有提示的情况下插入一个元素，但是`insert()`的返回值会告诉你。

您可以将一系列来自外部源的元素插入到`map`中。元素不必来自另一个`map`容器，但必须与它们所插入的容器中的元素类型相同。下面是演示这一点的一些代码:

`std::map<std::string, size_t> crowd {{"May", 55}, {"Pat", 66}, {"Al", 22}, {"Ben", 44}};`

`auto iter = std::begin(people);`

`std::advance(iter, 4);                       // begin iterator+ 4`

`crowd.insert(++std::begin(people), iter);    // Insert 2nd, 3rd, and 4th elements from people`

这创建了一个新的地图`crowd`，最初有四个元素。`iter`被初始化为`people`图的开始迭代器。容器的迭代器是双向的，所以你可以增加或减少它们，但不能增加或减少值。你在第 1 章的[中遇到的`advance()`函数模板的一个实例被用于将`iter`递增 4，这样它将指向第五个元素，这被用作下一行中`crowd`的`insert()`调用的参数中指定的范围的结束迭代器。范围的 begin 迭代器是加 1 的`people`映射的 begin 迭代器，所以操作从第二个元素开始，将三个元素从`people`插入到`crowd`。](01.html)

有一个版本`insert()`接受一个初始化列表作为参数:

`crowd.insert({{"Bert", 44}, {"Ellen", 99}});`

这会将初始化列表中的两个元素插入到`crowd`映射中。由自变量表达式创建的`initializer_list<>`对象将属于`initializer_list<const string,size_t>`类型，因为编译器知道这是`insert()`函数参数的类型。当然，您可以独立创建初始化列表，并将其作为参数传递给`insert()`:

`std::initializer_list<std::pair<const std::string, size_t>> init {{"Bert", 44}, {"Ellen", 99}};`

`crowd.insert(init);`

`initializer_list`模板的第一个类型参数必须是`const`。没有从`initializer_list<string,size_t>`到`initializer_list<const string,size_t>`的隐式转换，所以前一种类型的对象不会被接受为`insert()`的参数。

我们可以在一个完整的例子中看到其中的一些工作。我将使用我们将要定义的一种类型的对象来使它有一点不同。`Name`类型将代表一个人的名字，并且用于类定义的头文件内容将是:

`// Name.h for Ex4_01`

`// Defines a person’s name`

`#ifndef NAME_H`

`#define NAME_H`

`#include <string>                                // For string class`

`#include <ostream>                               // For output streams`

`#include <istream>                               // For input streams`

`class Name`

`{`

`private:`

`std::string first {};`

`std::string second {};`

`public:`

`Name(const std::string& name1, const std::string& name2) :`

`first (name1), second (name2) {}`

`Name() = default;`

`// Less-than operator`

`bool operator<(const Name& name) const`

`{`

`return second < name.second || (second == name.second && first < name.first);`

`}`

`friend std::istream& operator>>(std::istream& in, Name& name);`

`friend std::ostream& operator<<(std::ostream& out, const Name& box);`

`};`

`// Extraction operator overload`

`inline std::istream& operator>>(std::istream& in, Name& name)`

`{`

`in >> name.first >> name.second;`

`return in;`

`}`

`// Insertion operator overload`

`inline std::ostream& operator<<(std::ostream& out, const Name& name)`

`{`

`out << name.first + " " + name.second;`

`return out;`

`}`

`#endif`

这个类非常简单，有两个私有的`string`成员，分别用于名字和名字。有一个构造函数接受`string`参数或字符串作为参数。我们必须为该类定义`operator<()`，以允许对象在`map`容器中用作键。支持流的提取和插入操作符，使得`Name`对象的输入和输出更加容易。

`map`中的元素将属于类型`std::pair<const Name, size_t>,`，但是我们可以使用下面的别名定义使代码不那么冗长:

`using Entry = std::pair<const Name, size_t>;`

现在，当容器类型为`map<Name,size_t>`时，我们可以使用`Entry`作为`map`元素的类型。我们可以在函数定义中很好地使用这个别名来帮助`map`元素输入:

`Entry get_entry()`

`{`

`std::cout << "Enter first and second names followed by the age: ";`

`Name name {};`

`size_t age {};`

`std::cin >> name >> age;`

`return make_pair(name, age);`

`}`

它读取一个`Name`对象，后跟一个来自`cin`的年龄值，并从它们中创建一个`pair`对象。读取`name`的输入将调用`istream`对象的`operator>>()`重载，该重载在`Name.h`中定义，并支持读取`Name`对象。

输出地图中元素的辅助函数将非常有用:

`void list_entries(const map<Name, size_t>& people)`

`{`

`for(auto& entry : people)`

`{`

`std::cout << std::left << std::setw(30) << entry.first`

`<< std::right << std::setw(4) << entry.second << std::endl;`

`}`

`}`

这只是使用了一个基于范围的`for`循环来迭代元素。`entry`循环变量将依次引用每个`map`元素。每个元素都是一个`pair`对象，其中`first`成员是一个`Name`对象，而`second`成员是年龄的一个`size_t`值。

包含`main()`的源文件将有以下内容:

`// Ex4_01.cpp`

`// Storing names and ages`

`#include <iostream>                              // For standard streams`

`#include <iomanip>                               // For stream manipulators`

`#include <string>                                // For string class`

`#include <map>                                   // For map container class`

`#include <utility>                               // For pair<> & make_pair<>()`

`#include <cctype>                                // For toupper()`

`#include "Name.h"`

`using std::string;`

`using Entry = std::pair<const Name, size_t>;`

`using std::make_pair;`

`using std::map;`

`// Definition of get_entry() here...`

`// Definition of list_entries() here...`

`int main()`

`{`

`map<Name, size_t> people { {{"Ann", "Dante"}, 25}, {{"Bill", "Hook"}, 46},`

`{{"Jim", "Jams"}, 32},  {{"Mark", "Time"}, 32} };`

`std::cout << "\nThe initial contents of the map is:\n";`

`list_entries(people);`

`char answer {'Y'};`

`std::cout << "\nEnter a Name and age entry.\n";`

`while(std::toupper(answer) == 'Y')`

`{`

`Entry entry {get_entry()};`

`auto pr = people.insert(entry);`

`if(!pr.second)`

`{ // it’s there already - check whether we should update`

`std::cout << "Key \"" << pr.first->first`

`<< "\" already present. Do you want to update the age (Y or N)? ";`

`std::cin >> answer;`

`if(std::toupper(answer) == 'Y')`

`pr.first->second = entry.second;`

`}`

`// Check whether there are more to be entered`

`std::cout << "Do you want to enter another entry(Y or N)? ";`

`std::cin >> answer;`

`}`

`std::cout << "\nThe map now contains the following entries:\n";`

`list_entries(people);`

`}`

定义了一些额外的别名来进一步减少代码的冗长。您可以对`std`名称空间使用一个`using`指令，并且完全消除对`std`名称限定的需要，但是我不喜欢这样做，因为`std`中的所有名称都被有效地导入了，所以定义名称空间就失去了意义。

容器`map`的定义有初始值，用于初始化列表中定义的元素。这只是为了说明如何在这种情况下使用嵌套括号。在每个定义一个元素的初始化列表中，`Name`对象的括号之间有一个初始化列表。每个元素初始化器都是一个`Name`对象和一个大括号中的年龄值，元素的所有初始值都包含在最外面的一对大括号中。

调用`list_entries()`助手函数来显示容器的初始状态。在`for`循环中读取更多条目。循环由`answer`的值控制，该值在开始时为`'Y'`，因此循环至少执行一次，并且必须从键盘输入至少一个元素。条目对象的类型是`Entry`，这是一个容器元素的类型。由`get_entry()`辅助函数返回的对象被用作初始值。通过将 entry 元素作为参数传递给`insert()`成员，将它插入到容器中。返回的`pair`对象有一个`first`成员，该成员指向容器中的元素，该元素的键与`entry`的键相匹配。这将是原始容器元素，如果它在插入操作之前就存在的话。如果这个键已经在容器中，将不进行插入，并且`pr`的第二个成员将是`false. pr.first`是一个指向容器元素的迭代器，所以`pr.first->second`访问与该键相关的对象，并且如果用户确认更新，它将被更改为`entry.second`中的值。循环中的最后一个动作是决定是否要输入更多的条目。当不再有条目时，循环结束，通过调用`list_entries()`输出容器的最终内容。

以下是该示例的一些输出示例:

`The initial contents of the map is:`

`Ann Dante                       25`

`Bill Hook                       46`

`Jim Jams                        32`

`Mark Time                       32`

`Enter a Name and age entry.`

`Enter first and second names followed by the age: Emma Nate 42`

`Do you want to enter another entry(Y or N)? y`

`Enter first and second names followed by the age: Emma Nate 43`

`Key "Emma Nate " already present. Do you want to update the age (Y or N)? Y`

`Do you want to enter another entry(Y or N)?` `y`

`Enter first and second names followed by the age: Eamonn Target 56`

`Do you want to enter another entry(Y or N)? N`

`The map now contains the following entries:`

`Ann Dante                       25`

`Bill Hook                       46`

`Jim Jams                        32`

`Emma Nate                       43`

`Eamonn Target                   56`

`Mark Time                       32`

元素按键以升序输出，因为它们在容器中是用一个`less<Name>`对象排序的。`Name::operator<()`成员首先比较姓氏，只有当姓氏相同时才比较名字。这将导致名称的正常排序顺序。

### 就地构建地图元素

一个`map`容器有一个`emplace()`函数成员，它就地构造一个新元素，从而避免复制或移动操作。参数是构造一个元素所必需的，这个元素是一个`pair<const K,T>`对象。只有当不存在具有相同键的现有元素时，才会构造元素。这里有一个如何使用它的例子:

`std::map<Name, size_t> people;`

`auto pr = people.emplace(Name{"Dan", "Druff"}, 77);`

这里的`map`包含类型`Name`的键，这是在`Ex4_01`中定义的类类型。对象是类型`size_t`，所以`map`将包含类型`pair<const Name,size_t>`的元素。`emplace()`的第一个参数是作为键的`Name`对象，第二个参数是`size_t`值，函数将在对`pair<const Name,size_t>`构造函数的调用中使用这些参数就地创建元素。如果在`emplace()`的参数中构造`pair`对象，那么`pair<const Name,size_t>`类的 move 构造函数将被调用。

`emplace()`返回的`pair`对象提供的指示与`insert()`函数成员返回的指示相同。`pair`的`first`成员是一个迭代器，指向被插入的元素或阻止插入的元素，而`second`成员是一个`bool`值，如果元素被插入，则该值为`true`。

`map`的`emplace_hint()`成员以与`emplace()`基本相同的方式就地创建元素，除了您作为第一个参数提供的迭代器被用作搜索创建新元素的位置的起点。例如:

`std::map<Name, size_t> people;`

`auto pr = people.emplace(Name{"Dan", "Druff"}, 77);`

`auto iter = people.emplace_hint(pr.first, Name{"Cal", "Cutta"}, 62);`

`emplace_hint()`调用使用前面的`emplace()`调用返回的`pair`中的迭代器作为提示。如果容器接受了提示，新元素将被放置在这个位置的前面并尽可能靠近它。提示后面的参数用于构造新元素。需要注意的是，返回的值与`emplace()`函数成员的值完全不同。`emplace_hint()`成员不返回`pair`对象——如果插入了新元素，它返回一个指向新元素的迭代器，如果没有插入新元素，则返回具有相同键的现有元素。对于元素是否被创建，您没有直接的指示。然而，并没有全部丢失——一种可能是使用返回`map`中元素数量的`size()`成员来检查元素计数的增加。例如:

`auto pr = people.emplace(Name{"Dan", "Druff"}, 77);`

`auto count = people.size();`

`auto iter = people.emplace_hint(pr.first, Name{"Cal", "Cutta"}, 62);`

`if(count < people.size()) std::cout << "Success!\n";`

仅当元素`count`因调用`emplace_hint()`而增加时，才会显示该消息。

### 访问地图中的元素

您已经知道可以获得开始和结束迭代器以及反向迭代器，这些迭代器提供对`map`容器中所有元素的访问。`map`的`at()`函数成员返回与您作为函数参数提供的键相关联的对象。如果键不存在，抛出一个`out_of_range`异常。下面是一个如何使用它的例子:

`Name key;`

`try`

`{`

`key = Name {"Dan", "Druff"};`

`auto value = people.at(key);`

`std::cout << key << " is aged " << value << std::endl;`

`key = Name {"Don", "Druff"};`

`value = people.at(key);`

`std::cout << key << " is aged " << value << std::endl;`

`}`

`catch(const std::out_of_range& e)`

`{`

`std::cerr << e.what() << '\n'`

`<< key << " was not found." << std::endl;`

`}`

为一个`map`调用`at()`的语句需要在一个`try`块中——如果异常被抛出并且没有被捕获，程序将被终止。这个片段使用`at()`来获取与`people`容器中的两个`Name`键相关联的对象。如果`map`的内容是通过执行上一节的代码片段确定的，这将产生输出:

`Dan Druff is aged 77`

`invalid map<K, T> key`

`Don Druff was not found.`

`try`块中的第一个`at()`调用成功，产生第一行输出。第二个调用失败并抛出一个`out_of_range`异常，这个异常被捕获并导致最后两行输出。exception 对象的`what()`成员返回一个描述异常原因的字符串。当`catch`块代码执行时，`try`块中的所有局部变量都被销毁，因此无法访问。在`try`块之前定义了`key`变量，因此仍然可以从`catch`块中访问该变量。

下标操作符由一个`map`容器实现，接受一个键作为参数，并返回一个对相关对象的引用。这里有一个例子:

`auto age = people[Name {"Dan", "Druff"}];`

这将检索与`Name`键相关联的`size_t`值。注意，使用下标不仅仅是一种检索机制。如果该键不存在，则为该键创建一个新元素，并使用类类型的默认构造函数创建关联的对象，如果关联的对象是基本类型，则创建零的等效项。例如:

`auto value = people[Name {"Ned", "Kelly"}];   // Creates a new element if the key is not there`

将使用该键创建一个新元素，因为容器中不存在该键。关联的值将为 0，并且将返回该值。当您更新地图中的元素或插入它们(如果它们还不存在)时，您可以使用下标运算符。下标操作符的另一个主要用途是在赋值的左边改变现有的条目:

`people[Name {"Ned", "Kelly"}]  =  39;       // Sets the value associated with the key to 39`

让我们尝试一个工作示例，它以一种与您目前所看到的稍微不同的方式使用了一个`map`，并且使用了下标操作符。您可以使用一个`map`容器来确定每个单词在文本中出现的频率。确定词频可能是有用的——例如，它可以帮助对文档进行分类。下面是计算每个单词在任意文本序列中出现频率的代码:

`// Ex4_02.cpp`

`// Determining word frequency`

`#include <iostream>                             // For standard streams`

`#include <iomanip>                              // For stream manipulators`

`#include <string>                               // For string class`

`#include <sstream>                              // For istringstream`

`#include <algorithm>                            // For replace_if() & for_each()`

`#include <map>                                  // For map container`

`#include <cctype>                               // For isalpha()`

`using std::string;`

`int main()`

`{`

`std::cout << "Enter some text and enter * to end:\n";`

`string text_in {};`

`std::getline(std::cin, text_in, '*');`

`// Replace non-alphabetic characters by a space`

`std::replace_if(std::begin(text_in), std::end(text_in),`

`[](const char& ch){ return !isalpha(ch); }, ' ');`

`std::istringstream text(text_in);             // Text input string as a stream`

`std::istream_iterator<string> begin(text);    // Stream iterator`

`std::istream_iterator<string> end;            // End stream iterator`

`std::map<string, size_t> words;               // Map to store words & word counts`

`size_t max_len {};                            // Maximum word length`

`// Get the words, store in the map, and find maximum length`

`std::for_each(begin, end, [&max_len, &words](const string& word)`

`{  words[word]++;`

`max_len = std::max(max_len, word.length());`

`});`

`// Ouput the words and their counts`

`size_t per_line {4}, count {};`

`for(const auto& w : words)`

`{`

`std::cout << std::left << std::setw(max_len + 1) << w.first`

`<< std::setw(3) << std::right << w.second << "  ";`

`if(++count % per_line == 0)  std::cout << std::endl;`

`}`

`std::cout << std::endl;`

`}`

使用`string`对象的`getline()`函数将文本从标准输入流读入`text_in`。`replace_if()`算法用于将输入中的非字母字符替换为空格。`replace_if()`的前两个参数是定义元素范围的迭代器，在本例中是输入字符串中的字符。下一个参数是一个函数对象，当一个元素要被替换时，它返回`true`；这是一个λ表达式。最后一个参数是元素的替换，在本例中是空格。该函数将替换所有标点符号，因此我们最终只得到由空格分隔的单词。

我们从`text_in`创建一个`istringstream`对象`text`。一个`istringstream`对象允许在它封装的字符串上进行流输入操作，因此它充当一个流。这包括获取`text`的流迭代器的能力，然后我们可以在`for_each()`算法中使用它来提取单个单词。输入流的迭代器将连续指向每个输入实体。这里的输入是一连串的单词，所以由 begin 和 end 迭代器为`text`指定的范围定义了所有的单词。`for_each()`算法将作为第三个参数的 function 对象应用到迭代器所指向的每个元素，该元素在由前两个参数定义的范围内——在本例中是来自`text`的每个单词。函数对象必须引用迭代器指向的对象类型作为参数，所以这里是`const string&`。lambda 表达式通过引用捕获`max_len`变量和`map`，因此它可以修改这两个变量。lambda 的主体通过将每个单词指定为下标来将其作为一个键存储在容器中，并递增与该单词相关联的值。当单词不存在时，这将创建一个新条目，将单词作为键，值为 1。如果这个单词之前已经被添加到容器中，那么操作只会增加这个值。因此，与每个单词相关联的值是文本中出现的累计次数。lambda 表达式还更新了`max_len`,因此它记录了最长字符串的长度；该值将在输出过程中使用。

因此，对`for_each()`算法的调用将输入中的所有单词插入到`map`中——无论单词有多少——并累计每个单词出现的次数，计算出总的最大单词长度——对于一条语句来说，这还不错！剩下的代码是输出单词和它们的计数，我相信你能明白这是如何工作的。以下是该程序的输出示例:

`Enter some text and enter * to end:`

`How much wood would a wood chuck chuck,`

`If a woodchuck could chuck wood?`

`A woodchuck would chuck as much wood as a woodchuck could chuck`

`if a woodchuck could chuck wood.`

`*`

`A           1  How         1  If          1  a           4`

`as          2  chuck       6  could       3  if          1`

`much        2  wood        5  woodchuck   4  would       2`

这个例子将整数类型的对象存储在一个`map`中，因此我们可以将 increment 操作符应用于容器的下标操作符返回的值。当下标操作符为`map`返回的值返回一个类类型的对象时，也可以使用操作符，只要操作符已经为该类实现。为了说明我正在谈论的这类事情，让我们创建另一个工作示例。

假设我们想按名字存储和检索人们的引用。显然，有些人的名字中有很多著名的引语，所以我们需要允许为一个键存储多个引语。我们不能在一个`map`容器中存储重复的键，但是我们可以将一个键与一个可以封装多个引用的对象相关联。我们可以使用来自`Ex4_01`的`Name`类的实例作为键，并且我们可以定义一个`Quotations`类来保存给定名称的所有引用。

我们知道对键使用下标操作符可以访问与键相关的对象，所以我们可以通过在`Quotations`类中实现`operator[]()`来扩展符号。我们也可以在类中实现`operator<<()`,这样它就可以给一个`Quotation`对象添加一个引用。我们可以方便地将报价存储在一个`vector`容器中。下面是定义该类的`Quotations.h`的内容:

`#ifndef QUOTATIONS_H`

`#define QUOTATIONS_H`

`#include <vector>                                          // For vector container`

`#include <string>                                          // For string class`

`#include <exception>                                       // For out_of_range exception`

`class Quotations`

`{`

`private:`

`std::vector<std::string> quotes;                         // Container for the quotations`

`public:`

`// Stores a new quotation that is created from a string literal`

`Quotations& operator<<(const char* quote)`

`{`

`quotes.emplace_back(quote);`

`return *this;`

`}`

`// Copies a new quotation in the vector from a string object`

`Quotations& operator<<(const std::string& quote)`

`{`

`quotes.push_back(quote);`

`return *this;`

`}`

`// Moves a quotation into the vector`

`Quotations& operator<<(std::string&#x0026;& quote)`

`{`

`quotes.push_back(std::move(quote));`

`return *this;`

`}`

`// Returns a quotation for an index`

`std::string& operator[](size_t index)`

`{`

`if(index < quotes.size())`

`return quotes[index];`

`else`

`throw std::out_of_range {"Invalid index to quotations."};`

`}`

`size_t size() const {  return quotes.size();  }        // Returns the number of quotations`

`// Returns the begin iterator for the quotations`

`std::vector<std::string>::iterator begin()`

`{`

`return std::begin(quotes);`

`}`

`// Returns the const begin iterator for the quotations`

`std::vector<std::string>::const_iterator begin() const`

`{`

`return std::begin(quotes);`

`}`

`// Returns the end iterator for the quotations`

`std::vector<std::string>::iterator end()`

`{`

`return std::end(quotes);`

`}`

`// Returns the const end iterator for the quotations`

`std::vector<std::string>::const_iterator end() const`

`{`

`return std::end(quotes);`

`}`

`};`

`#endif`

使用`<<`操作符来添加引用相当符合它在其他上下文中的使用，比如流输入。您可以在这里使用`+=`操作符。该类定义了三个版本的`operator<<()`,提供了添加新报价的各种方式。第一个版本接受传递给`vector`的`emplace_back()`成员的字符串参数，该参数将调用`string`构造函数就地创建元素。第二个版本有一个引用字符串的参数，因此参数被传递给`vector`的`push_back()`成员。第三个版本有一个右值引用参数。当您通过名称访问函数体中的右值引用参数时，它将是一个左值，因此您必须使用`move()`将参数作为右值传递给`vector`的`push_back()`成员。这将使对象能够一直移动，而不需要复制。

该类的`operator[]()`成员使用索引访问一个`vector`元素。如果索引不在范围内，该函数将引发异常；这不应该发生，如果发生了，这是程序中的一个错误。

`begin()`和`end()`成员为`vector`中的引用返回迭代器。请注意返回类型是如何指定的。提供迭代器的容器一般会定义一个`iterator`成员，它是它们所支持的迭代器类型的别名，所以你不需要知道详细的类型规范。定义迭代器的类的对象可以与基于范围的`for`循环结合使用，只要迭代器至少是前向迭代器。

还有`begin()`和`end()`成员的`const`版本，它们返回在`Quotations`类中定义的`const`迭代器。返回类型也是在`vector`模板中定义的别名。如果没有定义`begin()`和`end()`的`const`版本，就不可能使用带有`const`循环变量的基于范围的`for`循环，如下所示:

`for(const auto& pr : quotations)                 // Requires const iterators`

`...`

我们可以定义几个在`main()`中使用的`inline`助手函数。第一个读着一个来自`cin`的名字:

`inline Name get_name()`

`{`

`Name name {};`

`std::cout << "Enter first name and second name: ";`

`std::cin >> std::ws >> name;`

`return name;`

`}`

这将一个名字读为第一个和第二个名字。`ws`操纵器消耗空白，因此通过从`cin.`读取字符跳过任何留下的空白

第二个助手只是读了一段引语:

`inline string get_quote(const Name& name)`

`{`

`std::cout << "Enter the quotation for " << name`

`<< ". Enter * to end:\n";`

`string quote;`

`std::getline(std::cin >> std::ws, quote, '*');`

`return quote;`

`}`

使用星号终止输入允许输入多行。支持存储报价的 Ex4_03.cpp 文件如下所示:

`// Ex4_03.cpp`

`// Stores one or more quotations for a name in a map`

`#include <iostream>                              // For standard streams`

`#include <cctype>                                // For toupper()`

`#include <map>                                   // For map containers`

`#include <string>                                // For string class`

`#include "Quotations.h"`

`#include "Name.h"`

`using std::string;`

`// get_name() definition goes here...`

`// get_quote() definition goes here...`

`int main()`

`{`

`std::map<Name, Quotations> quotations;         // Container for name/quotes pairs`

`std::cout << "Enter 'A' to add a quote."`

`"\nEnter 'L' to list all quotes."`

`"\nEnter 'G' to get a quote."`

`"\nEnter 'Q' to end.\n";`

`Name name {};                                  // Stores a name`

`string quote {};                               // Stores a quotation`

`char&#x00A0; command {};                              // Stores a command`

`while(command != 'Q')`

`{`

`std::cout << "\nEnter command: ";`

`std::cin >> command;`

`command = static_cast<char>(std::toupper(command));`

`switch(command)`

`{`

`case 'Q':`

`break;                                     // Quit operations`

`case 'A':`

`name = get_name();`

`quote = get_quote(name);`

`quotations[name] << quote;`

`break;`

`case 'G':`

`{`

`name = get_name();`

`const auto& quotes = quotations[name];`

`size_t count = quotes.size();`

`if(!count)`

`{`

`std::cout << "There are no quotes recorded for "`

`<< name << std::endl;`

`continue;`

`}`

`size_t index {};`

`if(count > 1)`

`{`

`std::cout << "There are " << count << " quotes for " << name << ".\n"`

`<< "Enter an index from 0 to " << count - 1 << ": ";`

`std::cin >> index;`

`}`

`std::cout << quotations[name][index] << std::endl;`

`}`

`break;`

`case 'L':`

`if(quotations.empty())                                      // Test for no pairs`

`{`

`std::cout << "\nNo quotations recorded for anyone." << std::endl;`

`}`

`// List all quotations`

`for(const auto& pr : quotations)                            // Iterate over pairs`

`{`

`std::cout << '\n' << pr.first << std::endl;`

`for(const auto& quote : pr.second)                        // Iterate over quotations`

`{`

`std::cout << "  " << quote << std::endl;`

`}`

`}`

`break;`

`default:`

`std::cout << " Command must be 'A', 'G', 'L', or 'Q'. Try again.\n";`

`continue;`

`break;`

`}`

`}`

`}`

`quotations`容器存储类型为`pair<const Name, Quotations>`的对象。像`quotations[name]`这样的表达式导致对与`Name`对象`name`相关联的对象的引用。如果在对应于`name`键的地图中没有现存的`pair`，将会创建一个与之相关联的默认`Quotations`对象，该对象将为空。为给定的`name`存储新报价`quote`的语句是:

`quotations[name] << quote;`

`<<`的左操作数相当于返回与名称相关联的`Quotations`对象的`quotations.operator[](name)`。因此，该语句相当于:

`quotations.operator[](name).operator<<(quote);`

你可以在`main()`中看到，我们可以用表达式`quotations[name][index]`访问给定索引处名称的引用，这对应于`quotations.operator[](name).operator[](index).`我想你现在应该能够理解`main()`中其余代码是如何工作的了。以下是一些输出示例:

`Enter 'A' to add a quote.`

`Enter 'L' to list all quotes.`

`Enter 'G' to get a quote.`

`Enter 'Q' to end.`

`Enter command: a`

`Enter first name and second name: Winston Churchill`

`Enter the quotation for Winston Churchill . Enter * to end:`

`There are a terrible lot of lies going around the world, and the worst of it is half of them are true.*`

`Enter command: a`

`Enter first name and second name: Dorothy Parker`

`Enter the quotation for Dorothy Parker . Enter * to end:`

`Beauty is only skin deep, but ugly goes clean to the bone.*`

`Enter command:` `a`

`Enter first name and second name: Winston Churchill`

`Enter the quotation for Winston Churchill . Enter * to end:`

`Never in the field of human conflict was so much owed by so many to so few.*`

`Enter command: a`

`Enter first name and second name: Winston Churchill`

`Enter the quotation for Winston Churchill . Enter * to end:`

`Courage is what it takes to stand up and speak, Courage is also what it takes to sit down and listen.*`

`Enter command: a`

`Enter first name and second name: Dorothy Parker`

`Enter the quotation for Dorothy Parker . Enter * to end:`

`Money cannot buy health, but I’d settle for a diamond-studded wheelchair.*`

`Enter command: g`

`Enter first name and second name: Winston Churchill`

`There are 3 quotes for Winston Churchill .`

`Enter an index from 0 to 2: 1`

`Never in the field of human conflict was so much owed by so many to so few.`

`Enter command: L`

`Winston Churchill`

`There are a terrible lot of lies going around the world, and the worst of it is half of them are true.`

`Never in the field of human conflict was so much owed by so many to so few.`

`Courage is what it takes to stand up and speak, Courage is also what it takes to sit down and listen.`

`Dorothy Parker`

`Beauty is only skin deep, but ugly goes clean to the bone.`

`Money cannot buy health, but I’d settle for a diamond-studded wheelchair.`

`Enter command: q`

显然，这个程序可以做更多的错误恢复功能，并可能提供比较键无论大小写，但你得到的想法。

一个`map`容器有一个`find()`函数成员，该成员返回一个迭代器，该迭代器指向具有与参数匹配的键的元素。例如:

`std::map<std::string, size_t>  people {{"Fred", 45}, {"Joan", 33}, {"Jill", 22}};`

`std::string name{"Joan"};`

`auto iter = people.find(name);`

`if(iter == std::end(people))`

`std::cout <<"Not found.\n";`

`else`

`std:: cout << name << " is " << iter->second << std::endl;`

如果没有找到匹配的参数，`find()`返回容器的结束迭代器，所以在尝试使用迭代器之前，必须检查这一点。

为了与`multimap`兼容，`map`容器包括`equal_range()`、`upper_bound()`和`lower_bound()`函数成员，但是因为这些的目的是找到具有相同键的多个元素，我将在本章后面的`multi` `map`容器的上下文中讨论这些。

### 删除元素

`map`的`erase()`函数成员将删除具有匹配参数的键的元素，并返回被删除元素的数量。例如:

`std::map<std::string, size_t>  people {{"Fred", 45}, {"Joan", 33}, {"Jill", 22}};`

`std::string name{"Joan"};`

`if(people.erase(name))`

`std::cout << name << " was removed." << std::endl;`

`else`

`std::cout << name << " was not found." << std::endl;`

显然，对于一个`map`容器，返回值只能是 0 或 1，0 表示没有找到该元素。您还可以将指向要删除的元素的迭代器作为参数传递给`erase()`。在这种情况下，返回一个迭代器，指向被移除的元素后面的元素。参数必须是容器的有效迭代器，并且不能是结束迭代器。如果迭代器参数指向容器中的最后一个元素，将返回结束迭代器。例如:

`auto iter = people.erase(std::begin(people));`

`if(iter == std::end(people))`

`std::cout << "The last element was removed." << std::endl;`

`else`

`std::cout << "The element preceding " << iter->first << " was removed." << std::endl;`

当最后一个元素被删除时，这个片段将输出一条消息，或者输出被删除元素后面的元素的键。

`erase()`还有一个进一步的版本，它接受两个迭代器参数来定义要删除的元素范围。例如:

`auto iter = people.erase(++std::begin(people), --std::end(people));  // Erase all except 1st & last`

返回的迭代器指向被移除的范围中最后一个元素之后的元素。当你想从一个`map`中移除所有元素时，你可以调用`clear()`成员。

## 使用对<>和元组<>对象

您已经看到了一个`pair<const K,T>`对象如何封装一个键和一个关联的对象，以及如何表示一个`map`中的一个元素。一般来说，`pair`封装的对象可以是任何类型，你可以为任何目的创建`pair<T1,T2>`对象——例如，你可以创建一个数组或一个`pair<T1,T2>`对象的`vector`,或者一个`pair`封装两个序列容器或两个指向序列容器的指针。在`utility`头中定义了`pair<T1,T2>`模板，当你想独立于`map`使用`pair`对象时，你需要包含这个模板。

`tuple<>`模板是`pair`模板的一般化，允许定义`tuple`模板实例，它封装了任意数量的不同类型的对象。因此，`tuple`实例可以有任意数量的模板类型参数。信不信由你，`tuple`模板是在`tuple`头中定义的。术语`tuple`也用于许多其他环境，例如数据库环境，其中元组是由许多不同类型的不同数据项组成的记录，因此概念是相似的。你会发现`tuple`对象有很多用途。对于将多个对象作为单个对象传递给一个函数或返回多个对象，类型非常有用。显然，定义由几个对象组成的容器元素的能力也将派上用场。我将首先进入`pair<T1,T2>`模板的细节，然后我们将看看如何创建和使用`tuple`对象。

### 成对运算

考虑到它是一个相对简单的模板类型，只有两个公共数据成员，`first`和`second`，一对`<T1, T2>`有令人惊讶的构造函数的多样性。您已经看到了如何使用`first`和`second`的值创建一个对象。有带引用参数和右值引用参数的版本。还有一些版本带有右值引用参数，允许将参数隐式转换为所需的类型。例如，以下是定义同一个`pair`对象的四种方法:

`std::string s1 {"test"}, s2{"that"};`

`std::pair<std::string, std::string> my_pair{s1, s2};`

`std::pair<std::string, std::string> your_pair{std::string {"test"}, std::string {"that"}};`

`std::pair<std::string, std::string> his_pair{"test", std::string {"that"}};`

`std::pair<std::string, std::string> her_pair{"test", "that"};`

第一个`pair`构造函数调用复制参数值，第二个移动参数值，第三个将第一个参数转发给`string`构造函数进行隐式转换，最后一个构造函数调用将两个参数隐式转换为`string`对象，这些对象被移动到`pair`的`first`和`second`成员。因为提供了构造函数的右值引用版本，任一或两个`pair`模板类型参数都可以是`unique_ptr<T>`。

`make_pair<T1, T2>()`函数模板是一个帮助函数，它创建并返回一个`pair<T1,T2>`对象。您可以创建前面代码块生成的 pair 对象，如下所示:

`auto my_pair = std::make_pair(s1, s2);`

`auto your_pair = std::make_pair(std::string {"test"}, std::string {"that"});`

`auto his_pair = std::make_pair<std::string, std::string>("test", std::string {"that"});`

`auto her_pair = std::make_pair<std::string, std::string>("test", "that");`

在前两条语句中，函数模板的类型参数是由编译器推导出来的。在最后两条语句中，它们是明确的。如果在最后两条语句中省略了模板类型参数，那么对象的类型将是`pair<const char*, string>`和`pair<const char*, const char*>`。

一个对象也是复制或移动可构造的，只要它的成员是。例如:

`std::pair<std::string, std::string> new_pair{my_pair};     // Copy constructor`

`std::pair<std::string, std::string> old_pair{std::make_pair(std::string{"his"}, std::string{"hers"})};`

`old_pair`是由`pair<string,string>`类移动构造函数创建的。

还有另一个 pair 构造函数，它使用了 C++11 中引入的机制，该机制允许通过就地创建`first`和`second`成员来构造`pair<T1, T2>`对象。`T1`和`T2`构造函数的参数作为`tuple<>`参数传递给`pair`构造函数；我将在下一节详细解释你可以用`tuple`对象做什么。下面是一个使用这个`pair`构造函数的例子:

`std::pair<Name, Name> couple{std::piecewise_construct,`

`std::forward_as_tuple("Jack", "Jones"), std::forward_as_tuple("Jill", "Smith")};`

这里,`pair`构造函数的第一个参数是在`utility`头中定义的`piecewise_construct_t`类型的一个实例。这是一个空类型，用作标记或记号。`piecewise_construct`参数的唯一目的是区分这个构造函数调用和两个`tuple`参数用作`pair`的`first`和`second`成员的值的构造函数调用。这里，构造函数的第二个和第三个参数指定了用于构造`first`和`second`对象的参数集。`forward_as_tuple()`是在`tuple`表头定义的函数模板；在这里，它创建了一个对其参数的引用的`tuple`,然后可以被转发。您不太可能经常需要这个`pair`构造函数，但是它提供了创建`pair<T1, T2>`对象的独特能力，其中类型`T1`和`T2`不支持复制或移动操作——它们只能就地创建。

注意，如果参数是临时对象，`forward_as_tuple()`将创建一个右值引用的`tuple`。例如:

`int a {1}, b {2};`

`const auto& c = std::forward_as_tuple(a,b);`

这里，`c`的类型是`tuple<int&, int&#x0026;>`，所以成员是引用。但是，假设您编写了以下语句:

`const auto& c = std::forward_as_tuple(1,2);`

这里的`c`是`tuple<int&#x0026;&, int&#x0026;&>`，成员为右值引用。

如果成员可以复制或移动，则`pair`对象支持复制和移动分配。例如:

`std::pair<std::string, std::string> old_pair;                      // Default constructor`

`std::pair<std::string, std::string> new_pair{std::string{"his"}, std::string{"hers"}};`

`old_pair = new_pair;                                               // Copy assignment`

`new_pair = pair<std::string, std::string>`

`{std::string{"these"}, std::string{"those"}};  // Move assignment`

`old_pair`将由默认的`pair`构造函数创建，其成员为空的`string`对象。第三条语句将`new_pair`逐个成员地复制到`old_pair`。第四条语句将作为赋值的右操作数的`pair`对象的成员移动到`new_pair`。

当`pair`对象包含不同类型的成员时，也可以将一个`pair`赋值给另一个，只要右操作数`pair`的成员类型可以隐式转换为左操作数`pair`的成员类型。这里有一个例子:

`auto pr1 = std::make_pair("these", "those");   // Type pair<const char*, const char*>`

`std::pair<std::string, std::string> pr2;       // Type pair<string, string>`

`pr2 = pr1;                                     // OK in this case`

`pr1`的`first`和`second`成员属于`const char*`类型。这种类型可以隐式地转换为类型`string`，这是`pr2`成员的类型，所以赋值是有效的。如果类型不可隐式转换，则赋值不会编译。

对于`pair`对象、`==`、`!=`、`<`、`<=`、`>`和`>=`，您已经有了一整套比较操作符。为了使这些工作，作为操作数的`pair`对象必须是相同的类型，并且它们的成员必须以相同的方式进行比较。如果左右操作数的对应成员相等，则相等运算符返回`true`:

`std::pair<std::string, std::string> new_pair;`

`new_pair.first = "his";`

`new_pair.second = "hers";`

`if(new_pair == std::pair<std::string, std::string> {"his", "hers"})  std::cout << "Equality!\n";`

`new_pair`的`first`和`second`成员的赋值将它们的值设置为包含右操作数字符串的`string`对象。因为`pair`对象是相等的，所以`if`语句将输出消息。如果`pair`对象的一个或两个成员不相等，则`!=`比较将产生`true`。

对于小于或大于比较，`pair`对象的成员按字典顺序进行比较。如果`new_pair.first`小于`old_pair.first`，表达式`new_pair < old_pair`将为真。如果`first`成员相等且`new_pair.second`小于`old_pair.second`，也将是`true`。这里有一个例子:

`std::pair<int, int> p1 {10, 9};`

`std::pair<int, int> p2 {10, 11};`

`std::pair<int, int> p3 {11, 9};`

`std::cout << std::boolalpha << (p1 < p2) << " "            // Outputs "true"`

`<< (p1 > p3) << " "            // Outputs "false"`

`<< (p3 > p2) << std::endl;     // Outputs "true"`

第一个比较是`true`，因为`p1`的第一个成员等于`p2`的第一个成员，而`p1`的`second`成员小于`p2`的成员。第二个比较是`false`，因为 p1 的`first`成员不大于`p3`的成员。第三个比较是`true`因为`p3`的第一个成员大于`p2`的第一个成员。

一个`pair`对象的`swap()`成员将其第一个和第二个成员与作为参数传递的`pair`成员交换。显然，参数必须是相同的类型。这里有一个例子:

`std::pair<int, int> p1 {10, 11};`

`std::pair<int, int> p2 {11, 9};`

`p1.swap(p2);                                               // p1={11,9} p2={10,11}`

如果你执行同一个`swap()`调用两次，你将回到你开始的地方。

### 元组操作

创建一个`tuple`对象最简单的方法是使用在`tuple`头中定义的`make_tuple()`辅助函数。该函数接受任意数量的任意类型的参数，它返回的`tuple`的类型由参数的类型决定。例如:

`auto my_tuple = std::make_tuple(Name{"Peter", "Piper"}, 42, std::string{"914 626 7890"});`

因为模板类型参数被推导为`make_tuple()`的参数，所以`my_tuple`对象将是类型`tuple<Name, int, string>`。如果您只提供一个字符串作为第三个参数给`make_tuple()`,`my_tuple`的类型将是`tuple<Name, int, const char*>`，这是不同的。

对象的构造函数提供了你可能需要的每一个选项。以下是一些例子:

`std::tuple<std::string, size_t> my_t1;                       // Default initialization`

`std::tuple<Name, std::string> my_t2{Name{"Andy", "Capp"}, std::string{"Programmer"}};`

`std::tuple<Name, std::string> copy_my_t2{my_t2};             // Copy constructor`

`std::tuple<std::string, std::string> my_t3{"this", "that"};  // Implicit conversion`

默认构造函数用默认值初始化`tuple`中的对象。对`my_t2`的构造函数调用将参数移动到`tuple`的元素中。下一个语句调用复制构造函数来创建元组，在最后一个构造函数调用中，`tuple`元素是通过将参数隐式转换为类型`string`来创建的。

您可以从一个`pair`构造一个`tuple`，其中的`pair`可以是一个左值或一个右值。显然，`tuple`只能有两个元素。这里有几个例子:

`auto the_pair = std::make_pair("these", "those");`

`std::tuple<std::string, std::string> my_t4 {the_pair};`

`std::tuple<std::string, std::string> my_t5 {std::pair <std::string, std::string > {"this", "that"}};`

第二条语句从`the_pair`创建一个`tuple`，它是一个左值。这里，`the_pair`的`first`和`second`成员将被隐式转换为`tuple`中元素的类型。最后一条语句从一个右值的`pair`对象创建元组。

您可以使用任何比较运算符来比较相同类型的`tuple`对象。被比较的元组对象中的元素按字典顺序进行比较。这里有一个例子:

`std:: cout << std::boolalpha << (my_t4 < my_t5) << std::endl;  // true`

`tuple`对象中的元素被连续比较，在这种情况下，第一个不同的元素决定结果。`my_t4`中的第一个元素比`my_t5`中的第一个元素少，所以结果是`true`。如果比较是为了相等，任何不同的对应元素对都会产生一个`false`结果。

`tuple`对象的`swap()`函数成员将其元素与自变量的元素互换。参数必须是同一类型的`tuple`对象。例如:

`my_t4.swap(my_t5);`

通过调用`my_t4`中每个元素的`swap()`成员与`my_t5`中相应的元素进行元素交换。显然，`tuple`中的所有元素类型都必须是可交换的，`tuple`头定义了一个全局`swap()`函数，它将以同样的方式交换两个`tuple`对象中的元素。

因为一个`tuple`是一个`pair`的概括，它必须以不同的方式工作。一个`pair`中对象的数量是固定的，所以它们有成员名。在一个`tuple`中可以有任意数量的对象，因此访问它们的机制必须适应这一点。`get<>()`模板函数从`tuple`返回一个元素。第一个模板类型参数可以是类型为`size_t`的值，它是参数`tuple`中元素的索引，因此 0 选择第一个`tuple`元素，1 选择第二个，依此类推。`get<>()`模板的其余类型参数被推断为与作为参数的`tuple`的类型参数相同。下面是一个使用带有索引值的`get<>()`来选择元素的例子:

`auto my_tuple = std::make_tuple(Name{"Peter", "Piper"}, 42, std::string{"914 626 7890"});`

`std::cout << std::get<0>(my_tuple)`

`<< " age = " << std::get<1>(my_tuple)`

`<< " tel: "  << std::get<2>(my_tuple) << std::endl;`

输出语句中对`get<>()`的第一次调用返回了对`my_tuple`中第一个元素的引用，这是一个`Name`对象。第二个`get<>()`调用返回对下一个元素的引用，是一个整数；第三个调用返回对第三个元素的引用，这是一个`string`对象。因此，输出将是:

`Peter Piper  age = 42 tel: 914 626 7890`

您也可以基于类型使用`get<>()`从`tuple`中获得一个元素，只要该类型只有一个元素。例如:

`auto my_tuple = std::make_tuple(Name{"Peter", "Piper"}, 42, std::string{"914 626 7890"});`

`std::cout << std::get<Name>(my_tuple)`

`<< " age = " << std::get<int>(my_tuple)`

`<< " tel: "  << std::get<std::string>(my_tuple) << std::endl;`

如果`tuple`包含多个类型参数值为`get<>()`的元素，代码将不会编译。在这里，`tuple`的三个成员都是不同类型的，所以它是有效的。

在`tuple`头中定义的全局`tie<>()`函数模板提供了另一种访问`tuple`中元素的方法。这个函数可以将元组中元素的值传递给一组由`tie<>()`绑定在一起的左值。`tie<>()`的模板类型参数是从函数参数推导出来的。这里有一个例子:

`auto my_tuple = std::make_tuple(Name{"Peter", "Piper"}, 42, std::string{"914 626 7890"});`

`Name name{};`

`size_t age{};`

`std::string phone{};`

`std::tie(name, age, phone) = my_tuple;`

作为最后一条语句中赋值的左操作数的`std::tie(name,age,phone)`表达式返回对参数的引用的`tuple`。因此，赋值操作的左右操作数是`tuple`对象。作为`tie()`参数的变量将被赋予来自`my_tuple`的元素值。可能是你不想存储每个元素的值。下面是如何从`my_tuple`中只存储`name`和`phone`元素的方法:

`std::tie(name, std::ignore, phone) = my_tuple;`

`ignore`在`tuple`头中定义，用于标记`tie()`函数调用中要忽略的值。对应于`ignore`的`tuple`元素的值将不会被记录。在示例中，它仅允许复制`my_tuple`的第一个和第三个元素。

您还可以使用`tie()`函数来实现一个类的数据成员的字典式比较。例如，您可以在`Ex4_01`的`Name`类中实现`operator<()`,如下所示:

`bool Name::operator<(const Name& name) const`

`{`

`return std::tie(second, first) < std::tie(name.second, name.first);`

`}`

由函数体中的`tie()`调用产生的`tuple`对象中的元素按顺序进行比较。使用`<`运算符比较连续的对应元素对。不同的第一对决定结果；结果是不同元素比较的结果。如果所有元素相等或等价，结果为`false`。

### 行动中的元组和对

让我们放一个练习`tuple` s 和`pair` s 的工作示例；它不一定反映做它所做的事情的最佳方式，但是目标是用`tuple`和`pair`对象来尝试操作。该示例将利用一个`map`容器，该容器将一个`pair`对象作为键，将一个`tuple`对象作为与该键相关联的对象。每个`map`元素将记录一个人的数据。关键字将是一个名字，相关的`tuple`对象将包含这个人的出生日期、身高和职业作为元素。出生日期也将是一个元组，因此我们将创建一个将`tuple`作为元素的`tuple`。该示例将使用一组类型别名来使代码不那么冗长:

`using std::string;`

`using Name = std::pair<string, string>;                     // Defines a name`

`using DOB = std::tuple<size_t, size_t, size_t>;             // Month, day, year`

`using Details = std::tuple< DOB, size_t, string> ;           // DOB, height(inches), occupation`

`using Element_type = std::map<Name, Details>::value_type;   // Type of map element`

`Name`是封装两个字符串对象的 pair 类型的别名。DOB 是 tuple 类型的别名，它有三个元素`size_t`,分别是月、日和年值。`Details`是与一个键相关联的对象的类型别名，并且是类型为`DOB`、`size_t`的年龄值和`string`的职业的三个元素的`tuple`。map 中元素的类型是一个`pair<const K,T>`对象，在这种情况下，这是一个相当混乱的类型。尽管是由`map`容器的`value_type`成员指定的类型，但是我们可以很容易地为它定义`Element_type`别名。如果进行替换，您会看到 map 元素的完整显式类型名称是:

`std::pair<std::pair<std::string, std::string>,`

`std::tuple<std::tuple<size_t, size_t, size_t>, size_t, std::string>>`

这说明了类型别名是多么有用。

我们可以像这样使用这些别名来定义容器:

`std::map<Name, Details> people;                            // Records of the people`

键是类型`Name`，关联的对象是类型`Details`——使用别名定义非常简单。我们可以进一步为容器类型定义一个别名:

`using People = std::map<Name, Details>;`

现在我们可以将容器定义为:

`People people;                                             // Records of the people`

我们可以将`map`元素的输入过程打包到一个函数中:

`void get_people(Peoples& people)`

`{`

`string first {}, second {};                              // Stores name inputs`

`size_t month {}, day {}, year {};                        // Stores DOB input`

`size_t height {};                                        // Stores height input`

`string occupation {};                                    // Stores occupation input`

`char answer {'Y'};`

`while(std::toupper(answer) == 'Y')`

`{`

`std::cout << "Enter a first name and a second name: ";`

`std::cin >> std::ws >> first >> second;`

`std::cout << "Enter date of birth as month day year (integers): ";`

`std::cin >> month >> day >> year;`

`DOB dob {month, day, year};                            // Create DOB tuple`

`std::cout << "Enter height in inches: ";`

`std::cin >> height;`

`std::cout << "Enter occupation: ";`

`std::getline(std::cin >> std::ws, occupation, '\n');`

`// Create the map element in place- a pair containing a Name pair and a tuple object`

`people.emplace(std::make_pair(Name {first, second}, std::make_tuple(dob, height, occupation)));`

`std::cout << "Do you want to enter another(Y or N): ";`

`std::cin >> answer;`

`}`

`}`

其中大部分是简单的流输入。使用`getline()`读取职业，允许输入多个单词描述。`getline()`的第一个参数消除了前一个输入操作可能留在输入缓冲区中的空白，这里就是这样。如果缓冲区中有换行符，那么`getline()`会读取一个空行。保存出生日期值的`tuple`是使用类型`tuple`的别名`DOB`从输入中创建的。通过调用`emplace()`成员，在`map`中就地创建元素`pair`对象。元素`pair`的`first`成员是使用`Name`别名创建的`pair<string,string>`对象，因此调用构造函数。元素`pair`的`second`成员是一个包含`DOB`元组、高度和职业的`tuple`。这是通过调用`make_tuple()`辅助函数创建的。

在读取了`map`的输入数据后，程序将按姓名顺序列出这些人以及他们的职业。另一个函数将完成这项工作:

`void list_DOB_Job(const People& people)`

`{`

`DOB dob;`

`string occupation {};`

`std::cout << '\n';`

`for(auto iter = std::begin(people); iter != std::end(people); ++iter)`

`{`

`std::tie(dob, std::ignore, occupation) = iter->second;`

`std::cout   << std::setw(20) << std::left << (iter->first.first + " " + iter->first.second)`

`<< "DOB: " << std::right               << std::setw(2) << std::get<0>(dob) << "-"`

`<< std::setw(2) << std::setfill('0') << std::get<1>(dob) << "-"`

`<< std::setw(4) << std::get<2>(dob) << std::setfill(' ')`

`<< "  Occupation: " << occupation << std::endl;`

`}`

`}`

产生输出的`for`循环使用迭代器——只是为了说明我们可以。使用基于范围的`for`循环会更简单，但是下一个函数将演示这一点。循环中的第一条语句是赋值语句。左边的操作数是一个`tie()`函数调用，它创建一个`tuple`，函数参数作为左值成员。赋值的右操作数是`iter`指向的`pair`对象的`second`成员，它是`Details`类型的`tuple`。赋值操作将右操作数`tuple`的成员复制到左操作数`tuple`的成员。因为`tie()`的第二个参数是`ignore`，所以只存储赋值右边的`tuple`的第一个和第三个成员——在变量`dob`和`occupation`中，变量`dob`本身就是一个`tuple`。

循环体中的第二条语句输出姓名、出生日期和职业。一个人的名字和名字记录在 p `a` ir 元素的`first`和`second`成员中:也就是键。`iter`指向`pair`元素，因此`iter->first`引用关键对象；因此`iter->first.first`访问作为键的`pair`的`first`成员，而`iter->first.second`访问`second`成员。使用`get<>()`函数模板访问`DOB`元组的成员。`get<>()`模板参数自变量选择`tuple`成员。

我们还可以包含一个函数来输出每个人的所有细节。如果可以选择按照记录中的任何字段对输出中的记录进行排序，那就太好了。实现这一点的一种方法是允许 function 对象作为参数传递，该参数比较与键相关联的`Details`对象的成员之一。下面是实现这一点的代码:

`template<typename Compare>`

`void list_sorted_people(const People& people, Compare comp)`

`{`

`std::vector< Element_type*> folks;`

`for(const auto& pr : people)`

`folks.push_back(&pr);`

`// Lambda to compare elements via pointers`

`auto ptr_comp =`

`[&comp](const Element_type* pr1, const Element_type* pr2)->bool`

`{  return comp(*pr1, *pr2);  };`

`std::sort(std::begin(folks), std::end(folks), ptr_comp); // Sort the pointers to elements`

`// Output the sorted elements`

`DOB dob {};`

`size_t height {};`

`string occupation {};`

`std::cout << '\n';`

`for(const auto& p : folks)`

`{`

`std::tie(dob, height, occupation) = p->second;`

`std::cout << std::setw(20) << std::left << (p->first.first + " " + p->first.second)`

`<< "DOB: " << std::right << std::setw(2) << std::get<0>(dob) << "-"`

`<< std::setw(2) << std::setfill('0') << std::get<1>(dob) << "-"`

`<< std::setw(4) << std::get<2>(dob) << std::setfill(' ')`

`<< "  Height: " << height`

`<< "  Occupation: " << occupation << std::endl;`

`}`

`}`

这是一个函数模板，它使函数对象的类型能够决定在函数调用中推导出的输出顺序。map 中元素的顺序是由键的顺序决定的，所以很明显，重新排序必须发生在`map`容器之外。我们可以将所有元素复制到另一个容器中，但是更好、更有效的方法是将指向元素的指针存储在另一个容器中，并使用作为第二个参数传递的函数对象对指针进行排序。

存储在`vector`容器中的指针是类型为`const Element_type*`的原始指针。在这里使用`unique_ptr`对象并不是一个好主意，因为`unique_ptr<T>`拥有它所指向的`T`对象。如果`vector`包含了`unique_ptr<Element_type>`元素，那么`map`元素就会被复制，这样就违背了使用指针的目的。在这种情况下使用原始指针没有坏处，因为`vector`及其元素对于函数来说是局部的，只是充当`map`元素的观察者。

`vector`元素只是地图中`pair`对象的地址，这些地址是在`for`循环中创建和存储的，该循环遍历`map`中的元素。调用者不一定知道排序是使用指针完成的，所以`list_sorted_people()`函数模板假设传递给它的函数对象实现了两个`map`元素的比较。函数体中定义的 lambda 表达式`ptr_comp`使用`comp`进行比较，其结果是将指向`map`元素的指针解引用为参数。因此，在对`vector`中的指针进行排序的`sort()`函数调用中使用了`ptr_comp` lambda 表达式。最后，在基于范围的`for`循环中产生输出，该循环遍历`vector`中的指针。`tie()`函数用于将`Details`元组中的所有元素提取到局部变量中。然后输出相关联的`Details`元组的名称和元素。

包含行使这些功能的`main()`的源文件的内容是:

`// Ex4_04.cpp`

`// Using tuples and pairs`

`#include <iostream>                                        // For standard streams`

`#include <iomanip>                                         // For stream manipulators`

`#include <string>                                          // For string class`

`#include <cctype>                                          // For toupper()`

`#include <map>                                             // For map container`

`#include <vector>                                          // For vector container`

`#include <tuple>                                           // For tuple template`

`#include <algorithm>                                       // For sort() template`

`using std::string;`

`using Name = std::pair <string, string>;                   // Defines a name pair`

`using DOB = std::tuple <size_t, size_t, size_t>;           // Month, day, year tuple`

`using Details = std::tuple < DOB, size_t, string > ;       // DOB, height(inches), occupation`

`using Element_type = std::map<Name, Details>::value_type; // Type of map element`

`using People = std::map<Name, Details>;                    // Type of people container`

`// Code  for get_people() function goes here...`

`// Code  for list_DOB_Job() function goes here...`

`// Code  for list_sorted_people() function template goes here...`

`int main()`

`{`

`std::map<Name, Details> people;                     // Records of the people`

`get_people(people);                                 // Read all the people`

`std::cout << "\nThe DOB & jobs are: \n";`

`list_DOB_Job(people);                               // List names, DOB & job`

`// Define height comparison for` `people`

`auto comp = [](const Element_type& pr1, const Element_type& pr2)`

`{`

`return std::get<1>(pr1.second) < std::get<1>(pr2.second);`

`};`

`std::cout << "\nThe people in height order are : \n";`

`list_sorted_people(people, comp);`

`}`

有一个令人印象深刻的标准库头文件的`#include`指令列表，后面是您之前看到的类型别名的定义。`main()`中的代码相对简单——本质上是三个函数调用。`map`元素的比较器由 lambda 表达式定义，尽管它可能是一个函数对象。在这种情况下，它比较`Details`对象中的第二个元素，即一个人的高度。高度值是使用`get<>()`以你看到的方式提取的。对于地图元素的任何特征，`list_sorted_people()`模板将与比较器一起工作。以下是一些输出示例:

`Enter a first name and a second name: Dan Druff`

`Enter date of birth as month day year (integers): 2 3 1978`

`Enter height in inches: 74`

`Enter occupation: Trichologist`

`Do you want to enter another(Y or N): y`

`Enter a first name and a second name: Jane Brudit`

`Enter date of birth as month day year (integers): 13 11 1990`

`Enter height in inches: 63`

`Enter occupation: Barista`

`Do you want to enter another(Y or N): y`

`Enter a first name and a second name: Will Derness`

`Enter date of birth as month day year (integers): 5 5 1981`

`Enter height in inches: 76`

`Enter occupation: Explorer`

`Do you want to enter another(Y or N): N`

`The DOB & jobs are:`

`Dan Druff           DOB:  2-03-1978  Occupation: Trichologist`

`Jane Brudit         DOB: 13-11-1990  Occupation: Barista`

`Will Derness        DOB:  5-05-1981  Occupation: Explorer`

`The people in height order are :`

`Jane Brudit         DOB: 13-11-1990  Height: 63  Occupation: Barista`

`Dan Druff           DOB:  2-03-1978  Height: 74  Occupation: Trichologist`

`Will Derness        DOB:  5-05-1981  Height: 76  Occupation: Explorer`

## 使用多地图容器

一个`multimap`容器是有序的，它存储键/值对，就像一个`map`一样，但是它允许重复的键。具有相同键的元素将按照它们被添加到容器的顺序出现在一个`multimap`中。对于`multimap`和`map`，你有相同范围的构造函数，用于比较键的默认函数对象是`less<K>()`。`multimap`的大多数函数成员的工作方式与`map`的相同。这种差异是因为容器中可能存在重复的键。我将只描述与`map`不同的`multimap`的函数成员。

`multimap`容器的`insert()`成员插入一个或多个元素，并且总是成功。这个函数有多种版本来`insert()`单个元素，所有版本都返回指向被插入元素的迭代器。下面是一些假设为`std::string`使用 using 声明的例子:

`std::multimap<string, string> pets;                    // Element is pair{pet_type, pet_name}`

`auto iter = pets.insert(std::pair<string, string>{string{"dog"}, string{"Fang"}});`

`iter = pets.insert(iter, std::make_pair("dog", "Spot"));   // Insert Spot before Fang`

`pets.insert(std::make_pair("dog", "Rover"));               // Inserts Rover after Fang`

`pets.insert(std::make_pair("cat", "Korky"));               // Inserts Korky before all dogs`

`pets.insert({{"rat", "Roland"}, {"pig", "Pinky"}, {"pig", "Perky"}}); // Inserts list elements`

第三条语句中的第一个参数是一个迭代器，它提示应该将元素放在哪里。该元素直接插入到由`iter`指向的元素之前，因此这允许您覆盖默认的插入位置，该位置将跟随使用等同于`"dog"`的键插入的前一个元素。使用默认比较，按键的升序顺序插入元素。具有相同键的元素将按照您插入它们的顺序排列，除非您提供一个提示来改变这个顺序。最后一条语句插入初始化列表中的元素。`insert()`还有一个进一步的版本，它接受两个迭代器参数来标识要插入的元素范围。

一个`multimap`的`emplace()`成员以与一个`map`相同的方式在容器中构建一个新元素。您还可以使用带有`multimap`的`emplace_hint()`,在这里您可以以迭代器的形式提供一个提示，以控制元素相对于具有相同键的元素的创建位置:

`auto iter = pets.emplace("rabbit", "Flopsy");`

`iter = pets.emplace_hint(iter, "rabbit", "Mopsy");         // Create preceding Flopsy`

这两个函数都返回指向插入元素的迭代器。`emplace_hint()`函数在第一个参数指向的位置之前创建新元素，并尽可能靠近它。只需使用`emplace()`插入`"Mopsy"`就可以用`"rabbit"`键将其定位在所有现有元素之后。

`multimap`不支持下标操作符，因为键不一定标识唯一元素。类似地，你为一个`map`容器所拥有的`at()`函数对于一个`multimap`来说是不可用的。`multimap`的`find()`函数成员返回一个迭代器，该迭代器指向一个元素，该元素的键等同于参数。例如:

`std::multimap<std::string, size_t> people{ {"Ann", 25}, {"Bill", 46}, {"Jack", 77},`

`{"Jack", 32}, {"Jill", 32}, {"Ann", 35} };`

`std::string name {"Bill"};`

`auto iter = people.find(name);`

`if(iter != std::end(people))  std::cout << name << " is " << iter->second << std::endl;`

`iter = people.find("Ann");`

`if(iter != std::end(people))  std::cout << iter->first << " is " << iter->second << std::endl;`

如果找不到键，则返回容器的结束迭代器，因此您应该经常检查这一点。第一个`find()`调用有一个 key 对象作为参数，输出语句将会执行，因为这个键存在。第二个`find()`调用有一个字符串作为参数，这表明参数不必与键的类型相同。使用对容器有效的函数对象，可以将任何值或对象作为可以与键进行比较的参数进行传递。执行最后一个输出语句是因为有一个相当于`"Ann."`的键，实际上有两个相当于`"Ann"`的键，在我的系统上，输出对应于 25 岁的 Ann。您可能会得到与第一个人工神经网络相同的输出，但这不能保证。

如果您正在使用一个`multimap`容器，它几乎肯定会包含具有重复键的元素；否则你会使用一个`map`。因此，通常情况下，您会希望访问与给定键对应的所有元素。`equal_range()`函数成员完成了这项工作。具有等价于参数的键的元素范围作为封装在一个`pair`对象中的一对迭代器返回——还有什么！例如:

`auto pr = people.equal_range("Ann");`

`if(pr.first != std::end(people))`

`{`

`for(auto iter = pr.first ; iter != pr.second; ++iter)`

`std::cout << iter->first << " is " << iter->second << std::endl;`

`}`

`equal_range()`的参数可以是与键相同类型的对象，也可以是与键不同类型的对象。返回的`pair`对象的`first`成员是一个迭代器，指向第一个元素，该元素的键不小于参数；这将是具有等效键的第一个元素(如果存在的话)。如果找不到键，`pair`的`first`成员将是容器的结束迭代器，所以您应该经常检查这种可能性。`pair`的`second`成员是一个迭代器，指向第一个键大于参数的元素；如果没有这样的元素，这将是结束迭代器。代码片段输出来自容器元素的信息，这些元素的键相当于`"Ann."`

`multimap`的`lower_bound()`函数成员返回一个迭代器，该迭代器要么指向第一个元素，其键等于或大于函数的参数，要么指向容器的结束迭代器。`upper_bound()`成员返回一个迭代器，它指向第一个键大于函数参数的元素，如果没有这样的元素，则返回结束迭代器。因此，当存在一个或多个等价键时，这些函数返回容器中匹配该键的元素范围的开始和结束迭代器，这些迭代器与由`equal_range()`返回的迭代器相同。你可以用这些来重写之前的片段:

`auto iter1 = people.lower_bound("Ann");`

`auto iter2 = people.lower_bound("Ann");`

`if(iter1 != std::end(people))`

`{`

`for(auto iter = iter1 ; iter != iter2; ++iter)`

`std::cout << iter->first << " is " << iter->second << std::endl;`

`}`

这会产生与前面的代码片段完全相同的输出。通过调用`multimap`的`count()`函数成员，可以发现有多少元素的键等同于给定的键:

`auto n = people.count("Jack");                             // Returns 2`

你可以用不同的方式使用它。一种可能是在`find()`或`equal_range()`之间选择访问元素。如果您使用 class 作为键将学生存储在一个`multimap`中，那么您可以使用`count()`成员来获得班级大小。当然，您也可以通过将您在[第 1 章](01.html)中遇到的`distance()`函数模板应用到`equal_range()`函数成员返回的迭代器或`lower_bound()`和`upper_bound()`返回的迭代器中，来获得相当于给定键的元素数量:

`std::string key{"Jack"};`

`auto n = std::distance(people.lower_bound(key), people.upper_bound(key));           // No. of elements matching key`

Note

有全局`equal_range()`、`lower_bound(),`和`upper_bound()`函数模板，它们与关联容器中同名函数成员的工作方式略有不同。你将在本书的后面了解到这些。

一个`multimap`的`erase()`成员有三个版本。一个版本接受指向一个元素的迭代器作为删除该元素的参数；该函数不返回任何内容。第二个版本接受一个键作为参数，并删除所有包含该键的元素；它返回从容器中移除的元素数量。第三个版本接受两个迭代器，它们将容器中的一系列元素定义为参数。该范围内的所有元素都被删除，函数返回一个迭代器，该迭代器指向被删除的最后一个元素之后的元素。

让我们在一个工作示例中尝试一些`multimap`操作:

`// Ex4_05.cpp`

`// Using a multimap`

`#include <iostream>                                        // For standard streams`

`#include <string>                                          // For string class`

`#include <map>                                             // For multimap container`

`#include <cctype>                                          // For toupper()`

`using std::string;`

`using Pet_type = string;`

`using Pet_name = string;`

`int main()`

`{`

`std::multimap<Pet_type, Pet_Name> pets;`

`Pet_type type {};`

`Pet_name name {};`

`char more {'Y'};`

`while(std::toupper(more) == 'Y')`

`{`

`std::cout << "Enter the type of your pet and its name: ";`

`std::cin >> std::ws >> type >> name;`

`// Add element - duplicates will be LIFO`

`auto iter = pets.lower_bound(type);`

`if(iter != std::end(pets))`

`pets.emplace_hint(iter, type, name);`

`else`

`pets.emplace(type, name);`

`std::cout << "Do you want to enter another(Y or N)? ";`

`std::cin >> more;`

`}`

`// Output all the pets`

`std::cout << "\nPet list by type:\n";`

`auto iter = std::begin(pets);`

`while(iter != std::end(pets))`

`{`

`auto pr = pets.equal_range(iter->first);`

`std::cout << "\nPets of type " << iter->first << " are:\n";`

`for(auto p = pr.first; start != pr.second; ++p)`

`std::cout << "  " << p->second;`

`std::cout << std::endl;`

`iter = pr.second;`

`}`

`}`

有类型别名可以使代码中的类型与它们所代表的内容相关联。`pets`容器存储`pair<string,string>`对象，这些对象包含作为键的宠物类型和作为对象的宠物名称。第一个循环中的代码将具有给定键的第二个和后续元素插入到具有该键的序列的开头。这使用`emplace_hint()`来插入元素。如果它是给定类型的第一个元素，则通过调用`emplace()`就地创建该元素。在第二个`while`循环中，元素按 pet 类型分组输出。这是通过找到由`iter`指向的第一个 pet 条目的类型，并使用由`equal_range(). iter`返回的迭代器列出该 pet 类型的整个序列来完成的，然后将该序列的结束迭代器设置为指向下一个 pet 类型的第一个元素的迭代器，或者是容器的结束迭代器。后者结束了循环。以下是一些输出示例:

`Enter the type of your pet  and their name: rabbit Flopsy`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: rabbit Mopsy`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: rabbit Cottontail`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: dog Rover`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: dog Spot`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: snake Slither`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: snake Sammy`

`Do you want to enter another(Y or N)? y`

`Enter the type of your pet  and their name: cat Max`

`Do you want to enter another(Y or N)? n`

`Pet list by type:`

`Pets of type cat are:`

`Max`

`Pets of type dog are:`

`Spot  Rover`

`Pets of type rabbit are:`

`Cottontail  Mopsy  Flopsy`

`Pets of type snake are:`

`Sammy  Slither`

输出显示元素按照键的升序排序，具有相同键的元素按照与输入时相反的顺序排序。

## 更改比较函数

您可能需要更改`map`或`multimap`的比较函数有几个原因:您可能希望元素按降序排序，而不是默认的升序；或者，您的键可能需要一个不同于直接小于或大于运算的比较函数，例如，如果键是指针，这将适用。在我举例说明如何指定一个可选的比较之前，我将首先强调您为比较键定义的任何函数对象的一个非常重要的要求:

Caution

为了相等，`map`容器的比较函数不能返回`true`。

换句话说，你不能使用`<=`或`>=`比较。那么这是为什么呢？一个`map`或`multimap`容器使用等价来决定什么时候键是相等的。两个键`key1`和`key2`是等价的，因此如果表达式`key1 < key2`和`key2 < key1`都产生`false`，则认为它们是相等的。换句话说，等价意味着表达式`!(key1 < key2) && !(key2 < key1)`的计算结果为`true`。考虑一下如果你的函数对象实现了`<=`会发生什么。当`key1`等于`key2`时，`key1 <= key2`和`key2 <= key1`都计算为`true`，所以表达式`!(key1 <= key2)&&!(key2 <= key1)`计算为`false`；这意味着从容器的角度来看，这些键根本就不相等。事实上，没有任何情况下键会被确定为相等。这意味着容器不能正常工作。让我们看看如何提供一个替代的比较函数，使容器正确运行。

### 使用更大的<t>对象</t>

假设我们为本章前面使用的`Name`类实现了`operator>()`。在类定义中，`operator>()`成员的代码将是:

`bool operator>(const Name& name) const`

`{`

`return second > name.second || (second == name.second && first > name.first);`

`}`

当然，您可以将成员的定义放在类之外:

`inline Name::bool operator>(const Name& name) const`

`{`

`return second > name.second || (second == name.second && first > name.first);`

`}`

现在我们可以用`Name`对象作为键定义一个`map`，并让容器中的`pair`对象按降序排列:

`std::map<Name, size_t, std::greater<Name>> people`

`{ {Name{"Al", "Bedo"}, 53}, {Name{"Woody", "Leave"}, 33}, {Name{"Noah", "Lot"}, 43} };`

比较键的函数对象的类型由第三个模板类型参数指定。一个`greater<Name>`对象将使用`>`操作符来比较`Name`对象，这是可行的，因为`Name`类实现了`operator>()`。这三个元素现在将按降序排列。如果您列出这些元素，这一点会很明显，您可以这样做:

`for( const auto& p : people)`

`std::cout << p.first << " " << p.second << " \n";`

基于范围的`for`循环遍历`people`容器中的元素，输出将是:

`Noah Lot  43`

`Woody Leave  33`

`Al Bedo  53`

### 定义自己的函数对象来比较元素

如果`map`或`multimap`中的键是指针，那么你需要定义一个函数来比较它们所指向的内容，否则指针所代表的地址就会被比较，而这很少是你想要的。如果键的类型不直接支持小于或大于比较，您必须定义一个函数对象，使键能够被适当地比较，以便在`map`或`multimap`中使用它们。你处理这两种情况的方式基本相同。

假设我们想要使用指向我们在堆上创建的对象的指针作为`map`容器中的键。我将使用指向`string`对象的智能指针来说明这一点。键的类型可以是`unique_ptr<string>`，在这种情况下，我们需要一个比较函数，它将有两个`unique_ptr<string>`参数，并将比较所指向的`string`对象。你可以通过一个仿函数来定义它——一个函数对象——我假设一个`std::string`的`using`指令:

`// Compares keys that are unique_ptr<string> objects`

`class Key_compare`

`{`

`public:`

`bool operator()(const std::unique_ptr<string>& p1, const std::unique_ptr<string>& p2) const`

`{`

`return *p1 < *p2;`

`}`

`};`

我们可以使用`Key_compare`类型作为函数对象的类型，`map`应该使用它来比较键:

`std::map<std::unique_ptr<string>, std::string, Key_compare> phonebook;`

第三个`map`模板参数指定提供元素比较的函数对象的类型。因为这个类型参数有一个指定的默认值`less<T>`，所以您必须指定您的函数对象的类型。地图中的元素是`pair`对象，封装了一个指向存储为`string`的名称的智能指针，以及一个存储为`string`的电话号码。我们不能用这个`map`来使用初始化列表，因为初始化列表涉及到复制，而`unique_ptr`对象不能被复制。我们至少有几种方法可以向容器中添加元素:

`phonebook.emplace(std::make_unique<string>("Fred"), "914 626 7897");`

`phonebook.insert(std::make_pair(std::make_unique<string>("Lily"), "212 896 4337"));`

第一条语句创建了`pair`对象，它是元素的位置。有一个`pair`构造函数可以移动这里指定的参数，所以不需要复制它们。第二条语句调用容器的`insert()`成员，这也将把作为参数的元素移动到容器中。

您可以像这样列出`phonebook`容器中的元素:

`for(const auto& p: phonebook)`

`std::cout << *p.first << " " << p.second << std::endl;`

基于范围的`for`循环遍历`map`中的元素，这些元素是`pair`对象。每个`pair`对象的第一个成员是一个惟一的指针，所以必须取消引用才能访问它所指向的字符串。如果使用迭代器访问元素，语法会有所不同:

`for(auto iter = std::begin(phonebook); iter != std::end(phonebook); ++iter)`

`std::cout << *iter->first << " " << iter->second << std::endl;`

这与前面的循环产生相同的输出，但是使用了迭代器。必须使用`->`操作符来访问`pair`对象的成员。由于定义`Key_compare`函子的方式，容器中的元素将按升序排列。

## 散列法

如果将对象及其相关的键存储在容器中，而键/对象对不是按键排序的，那么必须有一个方案，以某种方式使用键值来定位内存中的元素。例如，作为字符串等对象的键的问题是，可能的变体数量巨大。例如，10 个字符的字母串的可能值的数量是 26 <sup>10</sup> ，换句话说就是 2.6×10<sup>10</sup>–2600 亿。这不是一个有用的索引范围。你需要的是一种机制，将这样的范围缩小到更合理的限度内；理想情况下，该机制应该为每个键产生一个唯一的值。这是哈希做的事情之一。

哈希是从基本类型的数据项或从字符串等对象生成给定范围内的整数值的过程。哈希得到的值称为哈希值或哈希代码，通常在容器中用来定位表中的对象。正如我所说的，理想情况是散列应该在每种情况下产生唯一的值，但这在一般情况下是不可能的。俗话说“你不能把一夸脱放进一品脱的锅里”，这是显而易见的，因为当不同键值的数量大于可能的哈希值的数量时，你迟早会得到重复的键值。重复的哈希值被称为冲突。使用散列来定位元素的容器为处理来自不同键的重复散列值做好了准备，我将在无序 map 容器的上下文中解释它们是如何做到这一点的。

哈希不仅用于在容器中存储对象。它还有许多其他应用，例如在加密和安全系统中，用于将数据转换成不易理解的形式。例如，密码识别有时涉及散列。以原始形式存储系统密码是一个主要的安全风险。存储密码的哈希值而不是原始的密码字符串可以提供一定的安全性来防止黑客攻击。获得哈希值访问权限的黑客需要能够将哈希值转换回原始密码才能使用它们——这是一项困难的任务。因此，STL 为各种类型的散列数据提供的能力不仅适用于关联容器；它们也可以在更广泛的背景下使用。

理解散列如何与使用它的容器一起工作并不重要，但是对它的一些实现方式有一个基本的理解是有用和有趣的。有许多散列算法，但没有普遍适用的方法。为特定的上下文确定合适的散列方法并不总是容易的。计算除法后的余数经常会涉及到。也许最简单的散列算法是将密钥——不管它是什么——视为一个数值，比如说，`k`然后计算除以给定数字后的余数，比如说，`m`,并将其用作散列值。因此，散列值将是表达式`k%m`的结果。显然，这种方法最多允许`m`个不同的哈希值，值可以从`0`到`m-1`。很容易看出哪里会出现重复的哈希值。给定`k`的哈希值将被复制为`k+m`、`k+2*m`的键值，以此类推，这些值可能会出现。选择`m`的值对于最小化生成重复哈希值的可能性和确保值均匀分布至关重要。如果`m`是 2 的幂，比如说 2 <sup>n</sup> ，哈希值就是`k`的最低有效位`n`。这不是一个很好的结果，因为`k`的最高有效位对哈希值没有影响；理想情况下，密钥中的所有位都会影响哈希的结果。`m`通常被选为质数，因为这使得散列值更有可能均匀地分布在整个范围内。

另一种更好的计算哈希值的方法是将键值`k`乘以精心选择的常数`a`，计算`a*k`除以整数`m`后的余数，然后从`(a*k)%m`结果的中间选择一个给定长度的比特序列`n`作为哈希值。显然，`a`和`m`的选择很重要。对于 32 位整数的计算机，通常选择`m`为 2 <sup>32</sup> 。然后选择乘数`a`为与`m`互质的值，这意味着`a`和`m`没有大于 1 的公因数。此外，`a`的二进制表示不应该有前导零或尾随零，否则会因为键值有前导零和/或尾随零而产生冲突。由于显而易见的原因，这种方法被称为散列的乘法方法。

散列字符串有专门的算法。一种方法是将一个字符串视为多个单词，使用乘法等方法计算第一个单词的哈希值，向其添加下一个单词并对结果进行哈希运算，然后对所有单词以相同的方式继续计算，以产生该字符串的最终哈希值。幸运的是，STL 为散列提供了相当多的帮助，所以这是下一个主题。

### 生成哈希值的函数

`functional`头定义了无序关联容器使用的`hash<K>`模板的专门化。`hash<K>`模板为从类型`K`的对象创建哈希值的函数对象定义了类型。一个`hash<K>`实例的`operator()()`成员接受一个类型为`K`的参数，并将哈希值作为类型`size_t`返回。所有的基本类型和指针类型都有`hash<K>`模板的专门化。

`hash<K>`模板专门化使用的算法取决于实现，但是如果要符合 C++14 标准，它们必须满足一些特定的要求。其中包括:

*   它们不能抛出异常。
*   它们必须为相等的键生成相等的哈希值。
*   不相等密钥的冲突概率必须非常小——接近最大值`size_t`的倒数。

请注意，为相同的键生成相同的哈希值的要求仅适用于单次执行中。特别允许对给定的密钥进行散列可以在不同的场合产生不同的散列值。这允许在哈希算法中使用随机数据，这在将哈希应用于密码术时是理想的——例如，当哈希密码时。还要注意，符合 C++14 的条件并不排除给定类型的关键字的散列值可能与该关键字相同的可能性。在无序关联容器中用于散列整数键的散列函数可能就是这种情况。

下面是一个使用`hash<K>`从整数生成哈希值的例子:

`std::hash<int> hash_int;                                     // Function object to hash int`

`std::vector<int> n {-5, -2, 2, 5, 10};`

`std::transform(std::begin(n), std::end(n), std::ostream_iterator<size_t>(std::cout, " "), hash_int);`

这使用了`transform()`算法来散列`vector`中元素的值。`transform()`的参数是定义操作范围的迭代器，定义结果目的地的迭代器，这里是`ostream`迭代器，最后是应用于范围内值的函数—`hash<int>`对象。在我的系统上，输出是:

`554121069 2388331168 3958272823 3132668352 1833987007`

对于 C++编译器和库，哈希值可能会有所不同，这适用于所有哈希值。下面是一个散列浮点值的例子:

`std::hash<double> hash_double;`

`std::vector<double> x {3.14, -2.71828, 99.0, 1.61803399, 6.62606957E-34};`

`std::transform(std::begin(x), std::end(x),                std::ostream_iterator<size_t>(std::cout, " "), hash_double);`

我的系统上的输出是:

`4023697370 332724328 2014146765 3488612130 3968187275`

散列指针同样简单:

`std::hash<Box*> hash_box;                                  // Box class as in` [第二章](02.html)

`Box box{1, 2, 3};`

`std::cout << "Hash value = " << hash_box(&box) << std::endl;                                    // Hash value = 2916986638 for me`

您可以使用相同的函数对象来散列智能指针:

`std::hash<Box*> hash_box;                                  // Box class as in` [第二章](02.html)

`auto upbox = std::make_unique<Box>(1, 2, 3);`

`std::cout << "Hash value = " << hash_box(upbox.get()) << std::endl;                                    // Hash value = 1143026886 for me`

这只是调用`unique_ptr<Box>`对象的`get()`成员来获取原始指针，该指针将是空闲存储中的一个地址，并将其传递给哈希函数。还有一个针对`unique_ptr<T>`和`shared_ptr<T>`对象的`hash<K>`模板的专门化。例如，您可以散列`unique_ptr<Box>`对象，而不是它包含的原始指针:

`std::hash<std::unique_ptr<Box>> hash_box;                  // Box class as in` [第二章](02.html)

`auto upbox = std::make_unique<Box>(1, 2, 3);`

`std::cout << "Hash value = " << hash_box(upbox) << std::endl;                                    // Hash value = 4291053140 for me`

原始指针和`unique_ptr`的散列值将是相同的。不要被这误导，认为当键的类型没有特定的散列函数时，散列指针的能力是合适的。你散列的是一个地址，而不是对象本身。指针指向什么都无关紧要。考虑一下，如果使用指向键的指针而不是键将对象存储在无序容器中，会发生什么。指向一个键的指针的哈希值将与原始键的哈希值有很大不同，因为地址不同，所以它对检索对象没有用。需要有一种方法来为您使用的任何类型的密钥生成哈希值。如果键是您已经定义的类型，一种选择是使用 STL 提供的散列函数从您的类的数据成员生成一个散列值。

在`string`头中定义了`hash<K>`模板的专门化。这些生成的函数对象将从表示字符串的对象中计算哈希值。有四种专门化，对应于字符串类型:`string`、`wstring`、`u16string`和`u32string`。类型为`wstring`的字符串包含类型为`wchar_t`的宽字符；类型`u16string`包含`char16_t`字符，是 UTF-16 编码的 Unicode 字符。类型`u32string`包含`char32_t`字符，这是 UTF-32 编码的 Unicode 字符。当然，字符类型`char`、`wchar_t`、`char16_t,`、`char32_t`都是 C++ 14 中的基础类型。下面是散列一个`string`对象的例子:

`std::hash<std::string> hash_str;`

`std::string food {"corned beef"};`

`std::cout << "corned beef hash is " << hash_str(food) << std::endl;`

这将创建一个函数对象，以与本节前面的示例相同的方式散列`string`对象。这段代码的输出是:

`corned beef hash is 3803755380`

对于 C 风格字符串的散列没有具体的规定。使用类型为`const char*`的`hash<T>`模板将使用指针的专门化。如果您想获得一个 C 风格字符串的哈希值作为字符序列的哈希值，您可以从中创建一个`string`对象并使用一个`hash<string>`函数对象。

我所展示的代码片段产生的哈希值都是巨大的数字，对于决定在无序容器中何处存储对象来说，看起来并不十分有用。有多种方法可以使用哈希值在容器中定位对象。一种常见的方法是使用来自哈希值的位的子序列作为索引来识别对象在表或树中的位置。

## 使用 unordered_map 容器

一个`unordered_map`容器存储具有唯一键的键/值对元素。元素在容器中不是有序的。元素是使用键的散列值来定位的，因此对于您使用的键的类型，必须有一个散列函数。如果你正在使用一个你已经定义为键的类类型的对象，你需要为它定义一个实现散列函数的函数对象。如果您的键是 STL 中受特殊化`hash<T>`支持的类型的对象，容器可以使用它来生成键的哈希值。因为键允许无序映射中的对象无需搜索即可访问，所以检索元素的速度比在有序映射容器中更快。在无序映射中迭代一系列元素通常比在有序映射中慢，所以在任何特定应用程序中容器的选择取决于您希望如何访问元素。

一个`unordered_map`容器中的元素组织方式与一个`map`容器中的完全不同，元素内部组织的具体方式取决于你的 C++实现。通常，元素存储在哈希表中，表中的条目被称为桶，一个桶可以保存几个元素。给定的散列值选择特定的桶，并且因为可能的散列值的数量几乎肯定大于桶的数量，所以两个不同的散列值可以映射到同一个桶。因此，可能由于两个不同的关键字导致相同的散列值而产生冲突，也可能由于两个不同的散列值选择相同的桶而产生冲突。

有许多参数会影响元素存储的管理方式:

*   容器中的桶数。存储桶的数量是默认的，但是您也可以指定初始数量。
*   负载系数，即每个存储桶的平均元素数量。这是存储在容器中的元素数除以存储桶数。
*   负载系数的最大值，默认为 1.0，但是您可以更改它，正如您将看到的。这是负载系数的上限。当达到装载因子的最大值时，容器将为更多的桶分配空间，这通常包括重新散列容器中的元素。

不要将任何给定时刻一个桶中的最大元素数量与最大负载系数相混淆。假设您有一个包含八个桶的容器，进一步假设前两个桶中各有 3 个元素，其余的桶为空。这种情况下的负载系数是`6/8`，也就是`0.75`，小于默认的最大负载系数 1.0，所以这是可以的。

一个`unordered_map`的基本组织如图 [4-3](#Fig3) 所示。

![A978-1-4842-0004-9_4_Fig3_HTML.gif](A978-1-4842-0004-9_4_Fig3_HTML.gif)

图 4-3。

Data in an unordered_map

为了简单起见，图 4-4 只显示了每个桶中的一个元素。可以使用从 0 开始的索引来访问存储桶。

有各种方法来组织存储桶。一种可能是简单地将一个桶定义为一个序列，比如一个`vector`，并将该序列的地址存储在哈希表中。另一种方法是将 bucket 定义为一个链表，并将根节点存储在哈希表中。使用的具体方法取决于您的实现。

一个`unordered_map`必须能够比较键是否相等。这对于识别要从包含多个元素的桶中检索的特定元素，以及确定容器中何时已经存在相同的键是必要的。默认情况下，容器将使用在`functional`头中定义的`equal_to<K>`模板的一个实例。这将使用`==`操作符来比较键，因此容器在键相等时确定它们是相同的，这不同于使用等价的`map`容器。如果你使用的键是没有实现`operator==()`的类类型，你需要提供一个函数对象来比较你的键。

### 创建和管理无序映射容器

您可以像创建`map`一样简单地创建`unordered_map`容器，只要键类型`K`可以使用`hash<K>`实例散列，并且键可以使用`==`操作符比较。例如，下面是如何定义和初始化一个`unordered_map`:

`std::unordered_map<std::string, size_t> people {{"Jan", 44}, {"Jim", 33}, {"Joe", 99}}; // Name,age`

这将创建包含`pair<string, size_t>`元素的容器，并从初始化列表中初始化它。容器将有默认数量的桶，并使用一个`equal_to<string>()`对象来比较键是否相等。它将使用`string`头定义的`hash<K>`模板的`hash<string>`专门化的一个实例来散列这些键。如果不提供初始值，默认构造函数会创建一个空容器，其中包含默认数量的桶。

当您对要存储在容器中的元素数量有了一个很好的概念时，您可以指定构造函数应该分配的存储桶数量:

`std::unordered_map<std::string, size_t> people {{{"Jan", 44}, {"Jim", 33}, {"Joe", 99}}, 10};`

这个构造函数有两个参数:初始化列表和要分配的桶的数量。

您还可以创建一个容器，其中包含由迭代器定义的一系列`pair`对象的内容。显然，只要范围包含所需类型的`pair`对象，任何对象源都是可接受的。例如:

`std::vector<std::pair<string, size_t>> folks {{"Jan", 44}, {"Jim", 33}, {"Joe", 99},`

`{"Dan", 22}, {"Ann", 55}, {"Don", 77}};`

`std::unordered_map<string, size_t> neighbors {std::begin(folks), std::end(folks), 500};`

`neighbors`容器由来自`folks`向量的`pair<string,size_t>`元素填充。这也为`neighbors,`分配了 500 个存储桶，但是您可以省略这个参数并获得默认的存储桶计数。

您可以指定一个 function 对象，该对象使用前面两个构造函数中的任何一个来定义哈希函数；function 对象是初始化列表构造函数的第三个参数，是范围构造函数的第四个参数，所以在这样做的时候还必须指定一个桶计数。我将说明如何用接受初始化列表的构造函数来实现这一点。

假设我们想使用`Name`对象作为键，并在`Ex4_01`中定义`Name`类。我们必须为该类定义一个散列函数，以及相等运算符，因此该类定义需要扩展如下:

`class Name`

`{`

`// Private and public members and friends as in Ex4_01...`

`public:`

`size_t hash() const { return std::hash<std::string>()(first+second); }`

`bool operator==(const Name& name) const { return first == name.first && second== name.second; }`

`};`

在这种情况下，编译器可以提供的默认`operator==()`函数成员是令人满意的，但是我还是把定义放了进去。`hash()`成员使用一个`hash<string>()`函数对象来散列一个`Name`对象的`first`和`second`成员的连接。一个`unordered_map`容器需要的散列函数必须接受一个与键相同类型的参数，并以类型`size_t`返回散列值。我们可以定义一个函数对象类型，它将调用一个`Name`对象的`hash()`成员来满足需求:

`class Hash_Name`

`{`

`public:`

`size_t operator()(const Name& name) const { return name.hash(); }`

`};`

我们可以使用一个`Hash_Name`对象来指定一个`unordered_map`容器在创建时应该使用的散列函数:

`std::unordered_map<Name, size_t, Hash_Name> people`

`{{{{"Ann", "Ounce"}, 25}, {{"Bill", "Bao"}, 46}, {{"Jack", "Sprat"}, 77}},`

`500,                                         // Bucket count`

`Hash_Name()};                                // Hash function for keys`

元素将是`pair<Name, size_t>`对象。初始化列表是容器构造函数的第一个参数，它定义了三个这样的对象。请注意大括号是如何嵌套的。最里面的大括号包含了`Name`构造函数的参数。下一级大括号括起了`pair<Name,size_t>`构造函数的参数。`unordered_map`构造函数的第二个参数是桶计数——我们必须指定这个参数，因为我们想要指定第三个参数，它是散列键的函数对象。函数对象的类型是指定作为容器的第三个模板类型参数为`Hash_Name`。这是必要的，因为模板类型参数有一个默认值，它将不同于我们的函数对象的类型。创建一个用 range 初始化的`unordered_map`的构造函数，前两个参数是迭代器，第三和第四个参数分别是桶计数和散列函数。

当您需要指定一个函数对象来比较键对象是否相等时，您还必须指定桶计数，以及将从键生成哈希值的函数对象。如果我们忽略`Name`类的`operator==()`成员，并假设我们已经定义了一个定义函数对象的`Name_Equal`类类型，您可以像这样为构造函数指定一个`Name_Equal`函数对象:

`std::unordered_map<Name, size_t, Hash_Name, Name_Equal> people`

`{{{{"Ann", "Ounce"}, 25}, {{"Bill", "Bao"}, 46}, {{"Jack", "Sprat"}, 77}},`

`500,                                         // Bucket count`

`Hash_Name(),                                 // Hash function for keys`

`Name_Equal()};                               // Equality comparison for keys`

有一个额外的模板类型参数和一个额外的构造函数参数。模板类型参数是必需的，因为该参数有默认值。使用接受一系列元素作为初始值的构造函数来指定键相等比较的函数对象本质上是一样的。

您有一个`unordered_map`的移动和复制构造函数。显然，您将创建一个与参数容器具有相同桶计数和散列函数的重复容器。

### 调整存储桶计数

如果在保持当前负载系数的情况下，向容器中插入的元素多于存储桶的数量，容器将不得不增加存储桶的数量。这将导致元素被重新散列，以在新的存储桶集中重新分配它们。这将使容器中现有的迭代器失效。您可以通过调用`rehash()`函数成员随时更改存储桶的数量:

`people.rehash(15);                                         // Make bucket count 15`

`rehash()`的参数可以是比当前更多或更少的桶。只要不会导致超过最大装载系数，此语句就会将存储桶计数更改为 15。整个内容将被重新散列，以便在新的存储桶集合中重新分配元素，这将使周围的所有迭代器无效。如果指定的铲斗数超过了最大装载系数，铲斗将会增加，因此不会超过最大值。

如果您想确保增加存储桶计数，可以使用`bucket_count()`返回的值:

`people.rehash((5*people.bucket_count())/4);                // Increase bucket count by 25%`

另一种可能性是增加最大负载系数，从而允许每个桶的平均元件数增加:

`people.max_load_factor(1.2*people.max_load_factor());      // Increse max load factor by 20%`

要更改最大装载因子，您可以使用新值作为参数来调用容器的`max_load_factor()`；如果在没有参数的情况下调用成员，它将返回当前最大值，您可以在此语句中使用该最大值来指定新值。

您可以通过调用`unordered_map`对象的`load_factor()`来发现当前的负载系数，返回值是类型`float`:

`float lf = people.load_factor();`

您还可以选择设置存储桶的数量，以便它们可以容纳给定数量的元素，同时将负载系数保持在最大值范围内:

`size_t max_element_count {100};`

`people.reserve(max_element_count);`

这将设置存储桶计数，以便它可以容纳 100 个元素，而不会超过当前的加载因子限制。这将导致容器的内容被重新散列，从而使现有的迭代器失效。当然，您可以创建和使用`unordered_map`容器，而不用担心桶数或装载因素。集装箱会处理好的。对于性能很重要并且容器是其中一个重要因素的实际应用程序，这是值得考虑的。当每个桶不超过一个元素时，将获得最快的访问，但是这在实践中是不现实的，因为这将需要大量的存储器，因为不可避免地会有大量的空桶。增加最大加载因子允许每个存储桶有更多的元素，因此总的存储桶更少，这样可以更有效地使用内存。但是，每个存储桶中的元素越多，访问元素的速度越慢，因此性能会越差。这是在每个应用环境中的判断，在那里你设置条件。也许你能做的最重要的事情是避免重复地重复内容。如果您能够很好地猜测将要存储的元素的数量，那么您可以将存储桶的数量和/或加载因子设置在适当的级别，以最大限度地减少重新散列的可能性。

### 插入元素

一个`unordered_map`容器的`insert()`成员提供了与在`map`中相同的功能范围。您可以通过复制或移动来插入单个元素，可以提示也可以不提示。你也可以插入几个在初始化列表中标识的元素，或者由两个定义范围的迭代器标识的元素。让我们看一些例子，这是第一个:

`std::unordered_map<std::string, size_t> people { {"Jim", 33}, {"Joe", 99}};      // Name,age`

`std::cout << "people container has " << people.bucket_count() << " buckets.\n";  // 8 buckets for me`

`auto pr = people.insert(std::pair<string,size_t> {"Jan", 44});                   // Move insert`

`std::cout << "Element " << (pr.second ? "was" : "was not") << " inserted." << std::endl;`

第一条语句创建一个包含两个初始元素和一个默认桶计数的容器。下一条语句调用`people`的`bucket_count()`成员来获取桶计数；在我的系统上执行这段代码会返回注释中显示的值，但是您的系统可能会有所不同。`insert()`调用将是带有右值引用参数的版本，因此`pair`对象将被移动到容器中。这个函数返回一个`pair`对象，其中第一个成员是一个迭代器，指向新元素，或者如果它没有被插入，指向阻止它插入的元素。`pair`的`second`成员是一个`bool`值，如果插入了对象，则该值为`true`。

看看这些陈述:

`std::pair<std::string, size_t> Jim {"Jim", 47};`

`pr = people.insert(Jim);`

`std::cout << "\nElement " << (pr.second ? "was" : "was not") << " inserted." << std::endl;`

`std::cout << pr.first->first << " is " << pr.first->second << std::endl;         // 33`

因为参数是左值，所以调用带有`const`引用参数的`insert()`版本，如果插入成功，它将复制参数。这个插入将会失败，因为已经有一个键值为`string("Jim")`的元素，所以最后一个语句将报告年龄为 33。

下面是如何插入一个元素，并给出它应该放在哪里的提示:

`auto count = people.size();`

`std::pair<std::string, size_t> person {"Joan", 33};`

`auto iter = people.insert(pr.first, person);`

`std::cout << "\nElement " << (people.size() > count ? "was" : "was not") << " inserted." << std::endl;`

这里`insert()`的第一个参数是迭代器，它是前面的`insert()`调用返回的`pair`的第一个成员，这是一个关于元素应该放在哪里的提示；容器可能会也可能不会遵守提示。`insert()`的第二个参数是要插入的元素。这个版本的`insert()`函数不返回一个`pair`对象；它只返回一个迭代器，要么指向被插入的元素，要么指向阻止插入的元素。代码片段使用容器中的元素计数(由它的`size()`成员返回)来确定插入是否成功。

你也可以插入初始化列表的内容:

`people.insert({{"Bill", 21}, {"Ben", 22}});            // Inserts the two elements in the list`

此版本的`insert()`不返回值，插入一系列元素的版本也不返回值:

`std::unordered_map<std::string, size_t> folks;       // Empty container`

`folks.insert(std::begin(people), std::end(people));  // Insert copies of all people elements`

这些迭代器定义的范围包含来自与`folks`相同类型的容器的元素，但是它可以来自任何类型的容器，只要这些元素是`folks`所要求的类型。

您可以通过调用`emplace()`或`emplace_hint()`成员在`unordered_map`容器中就地创建元素。例如:

`auto pr = people.emplace("Sue", 64);                    // returns pair<iterator, bool>`

`auto iter = people.emplace_hint(pr.first, "Sid", 67);   // Returns iterator`

`people.emplace_hint(iter, std::make_pair("Sam", 59));   // Uses converting pair<string, size_t>`

`emplace()`成员根据您提供的参数在容器中创建对象。它返回一个包含迭代器的`pair`和一个与`insert()`意义相同的`bool`值。`emplace_hint()`的第一个参数是作为提示的迭代器，后面是用于创建元素的参数。它只返回一个迭代器，指向插入的元素或阻止插入的元素。

一个`unordered_map`容器实现了赋值操作符，用作为参数的`unordered_map`对象的内容替换容器的内容；

`folks = people;                                 // Replace folks elements by people elements`

显然，参数必须包含与当前容器相同类型的元素。

### 访问元素

您可以使用带键的下标操作符来获取对`unordered_map`中相应对象的引用。例如:

`people["Jim"] = 22;                             // Set Jim’s age to 22;`

`people["May"] = people["Jim"];                  // Set May’s age to Jim’s`

`++people["Joe"];                                // Increment Joe’s age`

`people["Kit"] = people["Joe"];                  // Set Kit’s age to Joe’s`

这与在`map`容器中的工作是一样的。对元素使用不存在下标操作符的键将导致使用该键的元素以关联对象的默认值创建。如果容器中没有`"Kit"`，最后一条语句将创建以`"Kit"`为关键字、年龄为 0 的元素；与`"Joe"`相关的对象将被复制到`"Kit."`

`at()`成员返回一个对与参数相关的对象的引用，该参数是一个键，但是如果键不存在，则抛出一个`out_of_range`异常。因此，当你不想用默认对象创建元素时，你可以使用`at()`而不是下标操作符。您还有`find()`和`equal_range()`成员，它们的工作方式与我描述的`map`相同。

迭代器可用于`unordered_map`，因此您可以访问基于范围的`for`循环中的元素，例如:

`for(const auto& person : people)`

`std::cout << person.first << " is " << person.second << std::endl;`

这列出了`people`容器中的所有元素。

### 移除元素

您可以通过调用`erase()`成员从`unordered_map`中移除元素。参数可以是标识元素的键，也可以是指向元素的迭代器。当参数是一个键时，`erase()`成员返回一个整数，即被删除的元素的数量，所以`0`返回表示没有找到。当参数是迭代器时，返回一个迭代器，该迭代器指向被移除元素之后的元素。以下是它的一些用法示例:

`auto n = people.erase("Jim");                      // Returns 0 if key not found`

`auto iter = people.find("May");                    // Returns end iterator if key not found`

`if(iter != people.end())`

`iter = people.erase(iter);                           // Returns iterator for element after "May"`

您还可以删除由某个范围标识的一系列元素。例如:

`// Remove all except 1st and last`

`auto iter = people.erase(++std::begin(people), --std::end(people));`

这将返回一个迭代器，它指向最后一个被移除的元素之后的元素。

当容器中没有元素时，`clear()`函数成员移除所有元素，而`empty()`成员返回`true`。

### 访问存储桶

您可以访问`unordered_map`中的单个存储桶及其包含的元素。您可以使用容器的`begin()`和`end()`成员的重载来实现，这些重载返回容器中元素的迭代器。存储桶从 0 开始索引，您可以通过将它的索引传递给容器的`begin()`成员来获得一个迭代器，该迭代器指向存储桶中作为给定索引位置的第一个元素。例如:

`auto iter = people.begin(1);                         // Returns an iterator for the 2nd bucket`

向容器的`cbegin()`成员传递一个索引会返回一个`const`迭代器，该迭代器指向桶中该索引位置的第一个元素。容器的`end()`和`cend()`成员也有接受索引的版本，它们分别返回一个迭代器和一个`const`迭代器，指向桶中指定索引位置的最后一个元素。因此，您可以用这样的循环输出特定存储桶(换句话说，存储桶列表)中的元素:

`size_t index{1};`

`std::cout << "The elements in bucket[" << index << "] are:\n";`

`for(auto iter = people.begin(index); iter != people.end(index); ++iter)`

`std::cout << iter->first << " is " << iter->second << std::endl;`

您已经看到了一个`unordered_map`的`bucket_count()`成员返回桶的数量。`bucket_size()`成员返回作为参数的索引所选择的存储桶中的元素数量。`bucket()`函数成员返回一个桶的索引，该桶包含您作为参数传递的键的元素。您可以以各种方式组合使用这些工具。例如:

`string key {"May"};`

`if(people.find(key) != std::end(people))`

`std:: cout << "The number of elements in the bucket containing " << key << " is "`

`<< people.bucket_size(people.bucket(key)) << std::endl;`

`bucket_size()`的参数是由`bucket()`返回的索引。当`key`在容器中时，这个片段执行输出语句。输出记录了包含`key`的桶中的元素数量。

这里有一个例子，可以让你了解当你添加元素时，`unordered_map`容器在你的系统上是如何工作的:

`// Ex4_06.cpp`

`// Analyzing how and when the number of buckets in an unordered_map container increases`

`#include <iostream>                              // For standard streams`

`#include <iomanip>                               // For stream manipulators`

`#include <string>                                // For string class`

`#include <unordered_map>                         // For unordered_map container`

`#include <vector>                                // For vector container`

`#include <algorithm>                             // For max_element() algorithm`

`using std::string;`

`using std::unordered_map;`

`// Outputs number of elements in each bucket`

`void list_bucket_counts(const std::vector<size_t>& counts)`

`{`

`for(size_t i {}; i < counts.size(); ++i)`

`{`

`std::cout << "bucket[" << std::setw(2) << i << "] = " << counts[i] << "  ";`

`if((i + 1) % 6 == 0) std::cout << '\n';`

`}`

`std::cout << std::endl;`

`}`

`int main()`

`{`

`unordered_map<string, size_t> people;`

`float mlf {people.max_load_factor()};          // Current maximum load factor`

`size_t n_buckets {people.bucket_count()};      // Number of buckets in container`

`std::vector<size_t> bucket_counts (n_buckets);   // Records number of elements per bucket`

`string name {"Name"};                          // Key - with value appended`

`size_t value {};                               // Element value`

`size_t max_count {8192};                       // Maximum number of elements to insert`

`auto lf = people.load_factor();                // Current load factor`

`bool rehash {false};                           // Records when rehash occurs`

`while(mlf <= 1.5f)                                    // Loop until max load factor is 1.5`

`{`

`std::cout << "\n\n***************New Container***************"`

`<< "\nNumber of buckets: " << n_buckets`

`<< "  Maximum load factor: " << mlf << std::endl;`

`// Insert max elements in container`

`for(size_t n_elements {}; n_elements < max_count; ++n_elements)`

`{`

`lf = people.load_factor();                        // Record load factor before insert`

`people.emplace("name" + std::to_string(++value), value);`

`auto new_count = people.bucket_count();           // Current bucket count`

`if(new_count > n_buckets)                         // If bucket count increases...`

`{                                                 // Output info`

`std::cout << "\nBucket count increased to " << new_count`

`<< ". Load factor was " << lf << " and is now " << people.load_factor()`

`<< "\nMaximum elements in a bucket was "`

`<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts))`

`<< std::endl;`

`if(n_buckets <= 64)`

`{`

`std::cout << "Bucket counts before increase were: " << std::endl;`

`list_bucket_counts(bucket_counts);`

`}`

`n_buckets = new_count;                                  // Update bucket count`

`bucket_counts = std::vector < size_t > (n_buckets);     // New vector for counts`

`rehash = true;                                          // Record rehash occurred`

`}`

`// Record current bucket counts`

`for(size_t i {}; i < n_buckets; ++i)`

`bucket_counts[i] = people.bucket_size(i);`

`if(rehash)                                        // If the container was rehashed...`

`{                                                 // ...output info`

`rehash = false;                                 // Reset rehash indicator`

`std::cout << "\nRehashed container. Bucket count is " << n_buckets`

`<< ". Element count is " << people.size()`

`<< "\nMaximum element count in a bucket is now "`

`<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts)) << std::endl;`

`if(n_buckets <= 64)                             // If no more than 64 buckets...`

`{`

`std::cout << "\nBucket counts after rehash are:\n";`

`list_bucket_counts(bucket_counts);`

`}`

`}`

`}`

`std::cout << "Final state for this container is:\n"`

`<< "Bucket count: " << people.bucket_count()`

`<< "  Element count: " << people.size()`

`<< "  Maximum element count in a bucket: "`

`<< *std::max_element(std::begin(bucket_counts), std::end(bucket_counts))`

`<< std::endl;`

`value = 1;                                              // Reset key suffix`

`people = unordered_map<string, size_t>();               // New empty container`

`n_buckets = people.bucket_count();`

`bucket_counts = std::vector < size_t >(n_buckets);      // New vector for bucket counts`

`mlf += 0.25f;                                             // Increase max load factor...`

`people.max_load_factor(mlf);                            // ...and set for container`

`}`

`}`

这个程序的想法是随着容器中元素数量的增加，跟踪负载系数和桶的数量。这将提供对容器如何增加桶计数以及在什么条件下增加桶计数的洞察。你需要耐心，因为它需要相当长的时间来执行。如果花费的时间太长，减少`max`变量的值。

该示例从一个空的`unordered_map`容器开始，并插入新元素，直到达到由`max.`指定的限制。唯一键是通过将`to_string()`返回的字符串加上递增`value`的结果作为`"name."`的参数来生成的。`string`头中定义的`to_string()`函数将任何类型的数值转换为`string`对象。

每个桶中的元素数量记录在一个`vector`容器中。只要最大负载系数小于或等于 1.5，外部`while`循环就会继续。嵌套的`for`循环在`unordered_map`容器中插入`max_count`元素。每当桶的数量发生变化时，就会调用`list_bucket_counts()`辅助函数来输出每个桶中的元素数量。为了防止已经庞大的输出变得难以管理，只列出了 64 个或更少桶的桶计数。当`max_count`元素已经被插入时，一个新的`unordered_map`被创建，具有更大的最大装载因子，并且内部循环对新的容器重复。这是为了显示最大负载系数如何影响存储桶数量增加的级别，从而导致元素被重新散列。

我不会复制我的系统的输出，因为它会占用太多的空间，但我会概述发生了什么。初始默认桶计数是 8。添加 8 个元素后，桶数从 8 增加到 64，这是一个非常大的变化。当任何存储桶中的最大元素数为 2，并且除了一个存储桶之外的所有存储桶都包含元素时，会出现这种情况；元素的总数是 9。输出显示，铲斗的增加是由负载系数达到 1.0 触发的。在我的系统上，桶数的下一次增加也是 8 倍，从 64 增加到 512。桶计数增加的因子在此之后减慢到 2，因此桶计数的顺序是:8、64、512、1024、2048、4096 和 8192。看看空桶的数量是如何随着桶的数量而增加的，这很有意思。在我的系统中，任何 bucket 中的最大元素数是 8，不出所料，这是最高的最大负载系数。我在一个最大负载系数为 1.5 的桶中获得了 7 个元素。存储桶数量的每次增加都会导致容器中的所有元素被重新散列并分配到新的存储桶位置。您可以轻松地调整程序，通过在存储桶计数增加之前和之后输出特定元素，来输出它们是如何移动的。这涉及到相当大的开销，因此随着要存储的元素数量的增加，一开始就正确地计算桶数变得更加重要。

我的系统的输出让我们对容器如何将原始哈希值映射到桶索引有了更多的了解。桶的数量总是 2 的幂。这允许桶的索引是来自原始哈希值的固定长度的位序列——3 位用于 8 个桶，6 位用于 64 个桶，9 位用于 512 个桶，等等。这使得获取桶索引变得简单而快速。这解释了为什么在桶计数增加后需要重新散列元素。从给定的散列值中取出 6 位几乎肯定会表示不同于从相同值中取出 3 位的索引值，因此给定的原始散列值很可能映射到不同的桶。

## 使用 unordered_multimap 容器

一个`unordered_multimap`容器是一个允许重复键的无序映射。因此，它支持的操作基本上与`unordered_map`容器相同，除了处理相同的多个键所必需的更改和添加。我只讨论不同之处。创建一个`unordered_multimap`是通过与`unordered_map`相同范围的构造函数选项。这里有一个例子:

`std::unordered_multimap<std::string, size_t> people {{"Jim", 33}, {"Joe", 99}};`

使用`insert()`、`emplace()`或`emplace_hint()`添加新元素总是使用`unordered_multimap`，只要参数与容器中的元素类型一致。每个函数成员返回一个迭代器，指向容器中的新元素；这与`insert()`和`emplace()`中的`unordered_map`不同，在`insert()`和`emplace()`中，返回一个`pair`对象来提供成功或失败的指示以及一个迭代器。以下是一些例子:

`auto iter = people.emplace("Jan", 45);`

`people.insert({"Jan", 44});`

`people.emplace_hint(iter, "Jan", 46);`

第三条语句使用第一条语句返回的迭代器作为放置元素的提示。容器或者您的实现可能会随意忽略这个提示。

由于潜在的重复键，`unordered_map`支持的`at()`和`operator[]()`成员对`unordered_multimap`不可用。访问元素的唯一选项是`find()`和`equal_range()`成员。成员总是返回一个迭代器到它找到的第一个元素，或者如果它没有找到键，返回结束迭代器。您可以使用一个键参数调用`count()`来发现容器中具有给定键的元素的数量。这里有一个实例:

`std::string key{"Jan"};`

`auto n = people.count(key);                      // Number of elements stored with key`

`if(n == 1)`

`std::cout << key << " is " << people.find(key)->second << std::endl;`

`else if(n > 1)`

`{`

`auto pr = people.equal_range(key);           // pair of begin & end iterators returned`

`while(pr.first != pr.second)`

`{`

`std::cout << key << " is " << pr.first->second << std::endl;`

`++pr.first;                                // Increment begin iterator`

`}`

`}`

如果只有一个带有`key`的元素，那么使用`find()`来访问该元素；如果有多个元素，那么使用`equal_range()`来访问该范围。当然，在任何一种情况下你都可以使用`equal_range()`。

让我们看一个`unordered_multimap`的工作示例。这个例子还将展示一些定义函数模板来使用容器的方法。该计划将实现一个电话簿，允许查找一个或多个名字的电话号码。我将使用一个`pair`对象来封装第一个和第二个名字，使用一个`tuple`来记录区号、交换和号码，作为`string`对象。我将使用以下指令来简化代码的外观:

`using std::string;`

`using std::unordered_multimap;`

`using Name = std::pair<string, string>;`

`using Phone = std::tuple<string, string, string>;`

电话号码可以用三个整数来表示，但其组成部分更像代码而不是数字。数字中的每个元素都有固定的位数，并且不允许某些数字组合。使用`string`对象使得检查正确的数字位数或验证区号变得非常简单，如果你想增加这种能力的话。我没有包括它，因为对于这本书来说代码太多了。

重载提取操作符从一个`istream`对象中读取电话号码将有助于例子中的输入操作。该函数如下所示:

`inline std::istream& operator>>(std::istream& in, Phone& phone)`

`{`

`string area_code {}, exchange {}, number {};`

`in >> std::ws >> area_code >> exchange >> number;`

`phone = std::make_tuple(area_code, exchange, number);`

`return in;`

`}`

`Phone`是一个`tuple`模板类型。这使用`make_tuple()`从从`in`读取的局部变量的值中创建`phone`对象。

我们可以对`Name`对象做同样的事情:

`inline std::istream& operator>>(std::istream& in, Name& name)`

`{`

`in >> std::ws >> name.first >> name.second;`

`return in;`

`}`

这只是丢弃任何前导空格，并从`in`中读取两个名称字符串，它们是`pair`对象的成员`name`。

当然，我们也需要输出能力。下面是为`Phone`对象提供输出的`operator<<()`函数定义:

`inline std::ostream& operator<<(std::ostream& out, const Phone& phone)`

`{`

`std::string area_code {}, exchange {}, number {};`

`std::tie(area_code, exchange, number) = phone;`

`out << area_code << " " << exchange << " " << number;`

`return out;`

`}`

这使用了`tie<>()`函数模板来创建一个引用三个局部变量的`tuple`。将`phone`赋值给由`tie<>()`产生的`tuple`，将`phone`成员的值存储在局部变量中，然后写入 out。或者，您可以使用`get<>()`函数模板来访问`phone`成员的值。这将是一个更好的方法，因为它将避免在上面的实现中出现的对`string`对象的复制，但是这个想法是要展示运行中的`tie<>()`函数。

为`Name`对象重载`<<`很简单:

`inline std::ostream& operator<<(std::ostream& out, const Name& name)`

`{`

`out << name.first << " " << name.second;`

`return out;`

`}`

所有这些 I/O 函数都是`inline`，所以我把它们放在一个名为`Record_IO.h`的头文件中。文件开头的`#include`和`using`指令是:

`#include <string>                                // For string class`

`#include <istream>                               // For istream class`

`#include <ostream>                               // For ostream class`

`#include <utility>                               // For pair type`

`#include <tuple>                                 // For tuple type`

`using Name = std::pair <std::string, std::string>;`

`using Phone = std::tuple <std::string, std::string, std::string>;`

该程序将使用两个关联容器——一个以姓名作为关键字，另一个以电话号码作为关键字，因此它们都包含相同的基本信息，但访问方式不同。有其他更有效的方法来实现同样的事情，但是这个想法是尝试使用`unordered_multimap`容器。容器将在`main()`中定义如下:

`unordered_multimap<Name, Phone, NameHash> by_name {8, NameHash()};`

`unordered_multimap<Phone, Name, PhoneHash> by_number {8, PhoneHash()};`

没有为`pair`或`tuple`对象提供默认的散列功能，所以我们必须定义它们。这里它们是`NameHash`和`PhoneHash`类型的函数对象。哈希函数对象的构造函数参数前面是桶计数的参数，因此必须指定桶计数。我只是把它作为我系统的默认值。

我将两种散列函数类型的定义放在同一个头文件中，我用下面的指令开始将其称为`Hash_Function_Objects.h`:

`#include <string>                                // For string class`

`#include <utility>                               // For pair type`

`#include <tuple>                                 // For tuple type`

`using Name = std::pair<std::string, std::string>;`

`using Phone = std::tuple < std::string, std::string, std::string>;`

我是这样定义`PhoneHash`类型的:

`class PhoneHash`

`{`

`public:`

`size_t operator()(const Phone& phone) const`

`{`

`return std::hash<std::string>()(std::get<0>(phone)+std::get<1>(phone)+std::get<2>(phone));`

`}`

`};`

哈希值是通过将在`string`头中定义的`hash<string>()`模板专门化应用于连接电话号码中三个元素的结果而产生的。我以类似的方式定义了`HashName`类型:

`class NameHash`

`{`

`public:`

`size_t operator()(const Name& name) const`

`{`

`return std::hash<std::string>()(name.first + name.second);`

`}`

`};`

我将输出打包，显示在一个单独的函数中支持的操作:

`void show_operations()`

`{`

`std::cout << "Operations:\n"`

`<< "A: Add an element.\n"`

`<< "D: Delete elements.\n"`

`<< "F: Find elements.\n"`

`<< "L: List all elements.\n"`

`<< "Q: Quit the progr.\n\n";`

`}`

列出所有元素的操作将允许按名称或数字输出。我们可以定义一个函数模板来处理这两种可能性:

`template<typename Container>`

`void list_elements(const Container& container)`

`{`

`for(const auto& element : container)`

`std::cout << element.first << "  " << element.second << std::endl;`

`}`

模板将从调用函数时使用的参数中推断出容器类型。两个容器中的元素都是`pair`对象。对于`by_name`容器，元素是`pair<Name, Phone>`对象，对于`by_number`容器，元素是`pair<Phone, Name>`对象。因为我们已经为`Name`和`Phone`类型重载了`operator<<()`，所以循环体将自动从`pair`元素的成员类型中选择适当的输出函数。我将把这个函数模板和随后的模板放在完整示例的`My_Templates.h`头文件中。

按名称或编号查找元素的过程本质上是相同的，因此我们也可以为此定义一个函数模板:

`template<typename Container>`

`auto find_elements(const Container& container) ->`

`std::pair<typename Container::const_iterator, typename Container::const_iterator>`

`{`

`typename Container::key_type key {};`

`std::cin >> key;`

`auto pr = container.equal_range(key);`

`return pr;`

`}`

模板的这段代码对应于 C++ 11 标准。返回类型是一个依赖于容器类型的`pair<>`模板类型。这是因为由返回的`pair`封装的迭代器的类型是特定于容器类型的。这意味着编译器不能处理函数名前面的返回类型规范，因为容器类型是由后面的函数参数决定的。要使 C++ 11 编译器能够确定返回类型，必须使用尾随返回类型语法。这允许编译器在处理完函数参数后处理返回类型。注意，`typename`关键字在`pair`模板类型参数的规范中是必不可少的。这在局部变量`key`的类型规范中也是必不可少的。容器中键的类型由容器类的成员`key_type`指定，因此`key`的类型规范自动为容器选择正确的类型。如果您需要与一个键相关联的对象类型，它由`Container::mapped_type`成员指定，容器的元素类型由`Container::value_type`给出。

C++ 14 标准引入了编译器推断函数返回类型的能力，因此函数模板可以写成这样:

`template<typename Container>`

`auto find_elements(const Container& container)`

`{`

`typename Container::key_type key {};`

`std::cin >> key;`

`auto pr = container.equal_range(key);`

`return pr;`

`}`

不需要尾随的返回类型，因为编译器可以将返回类型推断为返回值的类型，即`pr`的类型。

查找元素的操作将允许通过名称或编号进行搜索，在每种情况下，结果可以是一个包含迭代器的`pair`对象，迭代器定义了一系列这种或那种类型的元素。我们可以定义另一个函数模板来输出这样一系列元素:

`template<typename T>`

`void list_range(const T& pr)`

`{`

`if(pr.first != pr.second)`

`{`

`for(auto iter = pr.first; iter != pr.second; ++iter)`

`std::cout << "  " << iter->first << "  " << iter->second << std::endl;`

`}`

`else`

`std::cout << "No records found.\n";`

`}`

如果作为参数的`pair`对象的成员相同，则该范围为空，在这种情况下，我们只输出一条消息。为`Name`和`Phone`类型实现插入操作符的函数使这个模板能够工作。`pair`成员的实际类型将自动选择所需的`operator<<()`功能。请注意，这些模板不会减少编译程序中的代码。它们只是为生成所使用的函数提供了一种方便的机制，并提供了一些如何使用模板的简单示例。

`main()`函数将在代码下载的`Ex4_07.cpp`中，它包含以下语句:

`// Ex4_07.cpp`

`#include <iostream>                              // For standard streams`

`#include <cctype>                                // For toupper()`

`#include <string>                                // For string class`

`#include <unordered_map>                         // For unordered_map container`

`#include "Record_IO.h"`

`#include "My_Templates.h"`

`#include "Hash_Function_Objects.h"`

`using std::string;`

`using std::unordered_multimap;`

`using Name = std::pair<string, string>;`

`using Phone = std::tuple<string, string, string>;`

`// show_operations() definition goes here...`

`int main()`

`{`

`unordered_multimap<Name, Phone, NameHash> by_name {8, NameHash()};`

`unordered_multimap<Phone, Name, PhoneHash> by_number {8, PhoneHash()};`

`show_operations();`

`char choice {};                                     // Operation selection`

`Phone number {};                                    // Records a number`

`Name name {};                                       // Records a name`

`while(std::toupper(choice) != 'Q')                  // Go until you quit...`

`{`

`std::cout << "Enter a command: ";`

`std::cin >> choice;`

`switch(std::toupper(choice))`

`{`

`case 'A':                                         // Add a record`

`std::cout << "Enter first & second names, area code, exchange, "`

< < "和用空格分隔的数字:\ n "；

`std::cin >> name >> number;`

`by_name.emplace(name, number);                  // Create in place...`

`by_number.emplace(number, name);                // ...in both containers`

`break;`

`case 'D':                                         // Delete records`

`{`

`std::cout << "Enter a name: ";                  // Only find by name`

`auto pr = find_elements(by_name);`

`auto count = std::distance(pr.first, pr.second);  // Number of elements`

`if(count == 1)`

`{                                               // If there’s just the one...`

`by_number.erase(pr.first->second);            // ...delete from numbers container`

`by_name.erase(pr.first);                      // ...delete from names container`

`}`

`else if(count > 1)`

`{                                               // there’s more than one`

`std::cout << "There are " << count << " records for "`

`<< pr.first->first << ". Delete all(Y or N)? ";`

`std::cin >> choice;`

`if(std::toupper(choice) == 'Y')`

`{`

`// Erase records from by_number container first`

`for(auto iter = pr.first; iter != pr.second; ++iter)`

`{`

`by_number.erase(iter->second);`

`}`

`by_name.erase(pr.first, pr.second);         // Now delete from by_name`

`}`

`}`

`}`

`break;`

`case 'F':                                         // Find a record`

`std::cout << "Find by name(Y or N)? ";`

`std::cin >> choice;`

`if(std::toupper(choice) == 'Y')`

`{`

`std::cout << "Enter first name and second name: ";`

`list_range(find_elements(by_name));`

`}`

`else`

`{`

`std::cout << "Enter area code, exchange, and number separated by spaces: ";`

`list_range(find_elements(by_number));`

`}`

`break;`

`case 'L':                                         // List all records`

`std::cout << "List by name(Y or N)? ";`

`std::cin >> choice;`

`if(std::toupper(choice) == 'Y')`

`list_elements(by_name);`

`else`

`list_elements(by_number);`

`break;`

`case 'Q':`

`break;`

`default:`

`std::cout << "Invalid command - try again.\n";`

`}`

`}`

`}`

我想你不会觉得这很难理解。在输出可能的操作之后，所有的事情都在 while 循环中发生，直到进入`'q'`或`'Q'`为止。循环体只是一个选择所需操作的大的`switch`语句。

添加一个元素只需要在每个容器中就地创建一个元素，将与`by_name`容器一起使用的键/对象值切换为`by_number`容器。

删除元素使用带有`by_name`容器的`find_elements()`函数模板。首先从`by_number`容器中删除元素以保持容器内容的同步是很重要的。为了从`by_name`容器中删除几个元素，用迭代器调用它的`erase()`函数，迭代器将范围定义为参数。所有元素都有相同的键，所以您可以将范围中第一个元素的键传递给`erase()`来删除它们，就像这样:

`by_name.erase(pr.first->first);                   // Delete elements with the specified key`

对于查找操作，由`find_elements()`模板的实例返回的`pair`被直接传递给`list_range()`模板实例的实例。编译器会自动确保进行正确的调用。最后，为了列出元素，通过指定的键调用`list_elements()`模板的一个实例来输出元素。

以下是一些输出的示例:

`Operations` `:`

`A: Add an element.`

`D: Delete elements.`

`F: Find elements.`

`L: List all elements.`

`Q: Quit the program.`

`Enter a command: a`

`Enter first & second names, area code, exchange, and number separated by spaces:`

`Bill Bloggs 112 234 4545`

`Enter a command: a`

`Enter first & second names, area code, exchange, and number separated by spaces:`

`Nell Bloggs`

`112 234 4545`

`Enter a command: a`

`Enter first & second names, area code, exchange, and number separated by spaces:`

`Bill Bloggs 914 626 7890`

`Enter a command: a`

`Enter first & second names, area code, exchange, and number separated by spaces:`

`Al Capone 312 334 4566`

`Enter a command: l`

`List by name(Y or N)? y`

`Nell Bloggs  112 234 4545`

`Bill Bloggs  112 234 4545`

`Bill Bloggs  914 626 7890`

`Al Capone  312 334 4566`

`Enter a command: l`

`List by name(Y or N)? n`

`112 234 4545  Bill Bloggs`

`112 234 4545  Nell` `Bloggs`

`914 626 7890  Bill Bloggs`

`312 334 4566  Al Capone`

`Enter a command: f`

`Find by name(Y or N)? y`

`Enter first name and second name: Bill Blogs`

`No records found.`

`Enter a command: f`

`Find by name(Y or N)? y`

`Enter first name and second name: Bill Bloggs`

`Bill Bloggs  112 234 4545`

`Bill Bloggs  914 626 7890`

`Enter a command: f`

`Find by name(Y or N)? n`

`Enter area code, exchange, and number separated by spaces: 112 234 4545`

`112 234 4545  Bill Bloggs`

`112 234 4545  Nell Bloggs`

`Enter a command:` `q`

## 摘要

你在本章中学到的关联容器是使用键而不是索引值来访问数据的强大工具。这尤其适用于涉及相关数据项的应用程序——姓名和电话号码，例如:人员和地址、组件和子组件；或子组件和零件。无序映射容器通常提供比有序映射容器更快的对象访问，但是这依赖于具有散列函数的键，这些散列函数在大多数时候生成唯一的散列值。一个差的散列函数将会减慢元素检索的速度，因为需要在桶中搜索匹配的关键字的情况会更频繁地出现。如果您对您的键的散列有疑问，您最好使用有序映射容器。

虽然 map 容器为编程提供了极大的便利，但是存储 pair 对象的 sequence 容器是否是一个合理的选择，尤其是当您可以按键对容器进行排序时，这总是值得考虑的。这有时会比关联容器提供更好的解决方案。

您在本章中学到的重要内容包括:

*   一个`pair<T1,T2>`对象封装了两个任意类型的对象。
*   模板类型的一个实例可以封装任意数量的不同类型的对象。
*   所有的地图容器都将作为键/对象对的元素存储为`pair<const K,T>`对象。
*   一个`map<K,T>`容器存储具有唯一键的元素，默认情况下使用小于操作符按键排序，所以键类型必须支持`<`操作符，除非您指定一个替代的比较函数。
*   一个`multimap<K,T>`容器中的元素以与一个`map`相同的方式排序，但是允许重复的键。
*   有序关联容器使用等价来确定两个键何时相同。其结果是键的比较只能小于或大于。当键相等时返回`true`的比较函数将阻止容器正确工作。
*   哈希是从对象生成相对唯一的整数(称为哈希值)的过程。哈希用于决定元素在无序关联容器中的存储位置。哈希在密码学中也很重要。
*   元素存储在一个`unordered_map<K,T>`容器中，使用从键中生成的哈希值。哈希值选择一个特定的桶，每个桶可以包含几个元素。`unordered_map<K,T>`中的键必须是唯一的。
*   一个`unordered_multimap`容器类似于一个`unordered_map`，但是允许重复的键。
*   默认情况下，使用`equal_to<K>`比较无序映射容器中的键是否相等，因此键类型必须支持键对象的`==`比较和散列。

ExercisesImplement a program that uses a `map<K,T>` container to store the names of the students in each of an arbitrary number of classes. The program should support adding and deleting classes and listing all classes. The list of students in a class should be retrieved and displayed by supplying the class name such as “Biology.”   Implement a program that uses a multi`map<K,T>` container to store the classes that are attended by each student where there may be more than one student with the same name. The elements should be in descending order. Provide for adding and deleting students, listing all students and their classes, and retrieving and displaying the class for a given student name.   Write a program that simulates a supermarket with a number of checkouts entered from the keyboard. Each checkout should be represented by an element in a `map` container where the key is the checkout ID, and the queue at that checkout is the associated object. Customers should arrive at random intervals with random checkout occupancy times when they are served. The program should report average and maximum queue lengths for each checkout after a given period that is also entered from the keyboard.   Define a class for `Person` objects that store a name, an address, and a phone number. Use an `unordered_multimap` container to store `Person` object with names as keys. Provide for retrieving an address, or a phone number for a name, as well as listing all `Person` objects in ascending sequence of names. Define a `main()` program to demonstrate all the functions offered.