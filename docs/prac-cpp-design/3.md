# 3.堆栈

堆栈是我们将要设计和实现的计算器的第一个模块。虽然我们在第 [2](2.html) 章中定义了模块的公共接口，但我们对它的实现说得很少。我们现在需要将堆栈分解成提供模块功能的函数和类。因此，这是我们开始的地方。如果你对栈数据结构的机制有点生疏，现在是查阅你最喜欢的数据结构和算法书籍的好时机。我个人最喜欢的是科尔曼等人的作品[10]。

## 3.1 堆栈模块的分解

在分解栈模块时要问的第一个问题是，“栈应该分成多少块？”在面向对象的说法中，我们问，“我们需要多少对象，它们是什么？”在这种情况下，答案相当明显:一，堆栈本身。本质上，整个堆栈模块是单个数据结构的表现，可以很容易地用单个类封装。这个类的公共接口已经在第 [2](2.html) 章描述过了。

人们可能会问的第二个问题是，“我需要构建一个类吗？或者我可以直接使用标准模板库(STL) `stack`类吗？”这其实是一个很好的问题。所有的设计书籍都宣扬，当您可以使用库中的数据结构时，您不应该编写自己的数据结构，尤其是当数据结构可以在 STL 中找到时，STL 保证是符合标准的 C++发行版的一部分。事实上，这是明智的建议，我们不应该重写堆栈数据结构的机制。然而，我们也不应该在我们的系统中直接使用 STL `stack`作为堆栈。相反，我们将编写自己的 stack 类，将 STL 容器封装为私有成员。

假设我们选择使用 STL `stack`来实现堆栈模块。与直接利用相比，人们更喜欢封装 STL 容器(或来自任何供应商的数据结构)有几个原因。首先，通过包装 STL `stack`，我们为计算器的其余部分添加了一个接口保护。也就是说，我们通过将堆栈的接口与其实现分离，将其他计算器模块与底层堆栈实现的潜在变化隔离开来(还记得封装吗？).当使用供应商软件时，这种预防措施可能特别重要，因为这种设计决策将对包装器实现的更改本地化，而不是对堆栈模块接口的更改。如果供应商修改其产品的接口(供应商都是这样狡猾的),或者您决定用一个供应商的产品替换另一个供应商的产品，这些更改只会在本地影响您的堆栈模块的实现，而不会影响堆栈模块的调用方。即使底层实现是标准化的，比如 ISO 标准化 STL `stack`，接口保护也能让用户在不影响相关模块的情况下改变底层实现。例如，如果您改变了主意，后来决定使用`vector`而不是`stack`来重新实现您的堆栈类，该怎么办？

包装 STL 容器而不是直接使用它的第二个原因是，这个决定允许我们限制接口以完全符合我们的需求。在第 [2](2.html) 章中，我们花费了大量精力为堆栈模块设计了一个有限的、最小的接口，能够满足 pdCalc 的所有用例。通常，底层实现可能提供比您实际希望公开的更多的功能。如果我们直接选择 STL `stack`作为堆栈模块，这个问题不会很严重，因为 STL `stack`的接口与我们为计算器的堆栈定义的接口非常相似，这并不奇怪。然而，假设我们选择了 Acme Corporation 的`RichStack`类及其 67 个公共成员函数作为我们的堆栈模块。一个初级开发人员，如果忽略了阅读设计规范，可能会在不知不觉中调用一个本不应该在应用程序上下文中公开的`RichStack`函数，从而违反了我们的堆栈模块的一些隐式设计契约。虽然这种滥用可能与模块的文档化接口不一致，但是我们不应该依赖其他开发人员真正阅读或遵守文档(可悲，但却是事实)。如果您可以通过编译器可以强制执行的语言构造(例如，访问限制)来强制防止误用的发生，请这样做。

包装 STL 容器的第三个原因是扩展或修改底层数据结构的功能。例如，对于 pdCalc，我们需要添加 STL `stack`类中没有的两个函数(`getElements()`和`swapTop()`)，并将错误处理从标准异常转换为自定义错误事件。因此，包装类使我们能够修改 STL 的标准容器接口，以便我们能够符合我们自己内部设计的接口，而不是被 STL 提供给我们的功能所束缚。

正如人们所预料的，前面描述的封装场景经常出现，因此已经被编码为一种设计模式，适配器(包装器)模式[11]。正如 Gamma 等人所描述的，适配器模式用于将一个类的接口转换成客户机期望的另一个接口。通常，适配器提供了某种形式的转换功能，从而也充当了不兼容类之间的代理。

在模式的原始描述中，适配器被抽象为允许一条消息通过多态使用适配器类层次结构包装多个不同的适配器。对于 pdCalc 的堆栈模块的需求，一个简单的具体适配器类就足够了。记住，设计模式的存在是为了帮助设计和交流。尽量不要陷入完全按照文本中规定的方式实现模式的陷阱。使用文献作为指导来帮助阐明您的设计，但是，最终，更喜欢实现适合您的应用的最简单的解决方案，而不是最接近学术理想的解决方案。

我们应该问的最后一个问题是，“我的栈应该是通用的(即模板化的)吗？”这里的答案是一个响亮的也许。理论上，设计一个抽象的数据结构来封装任何数据类型都是合理的做法。如果数据结构的最终目标是出现在一个库中或者被多个项目共享，那么数据结构应该是一般化的。然而，在单个项目的环境中，我不建议将数据结构通用化，至少一开始不建议。通用代码更难编写，更难维护，更难测试。除非预先存在多种类型使用场景，否则我觉得编写通用代码不值得这么麻烦。我已经完成了太多的项目，在这些项目中，我花了额外的时间来设计、实现和测试一个通用数据结构，只是为了将它用于一种类型。实际上，如果你有一个非泛型的数据结构，突然发现你需要把它用于一个不同的类型，必要的重构通常不会比类从一开始就被设计成泛型更困难。此外，现有的测试将很容易适应通用接口，为单一类型建立的正确性提供基线。因此，我们将把我们的堆栈设计成`double`特定的。

## 3.2 堆栈类

既然我们已经确定我们的模块将包含一个类，一个底层堆栈数据结构的适配器，我们开始设计它。设计类时首先要问的一个问题是，“这个类将如何被使用？”例如，你是否设计了一个抽象基类来继承，从而可以多态地使用？你设计一个类主要是作为一个普通的旧数据(POD)仓库吗？在任何给定的时间，这个类会有许多不同的实例吗？任何给定实例的生命周期是多长？谁通常拥有这些类的实例？实例会被共享吗？这个类会并发使用吗？通过提出这些和其他类似的问题，我们发现了我们堆栈的以下功能需求列表:

*   系统中应该只有一个堆栈。

*   堆栈的生命周期就是应用程序的生命周期。

*   UI 和命令调度程序都需要访问堆栈；两者都不应该拥有堆栈。

*   堆栈访问不是并发的。

只要满足前面提到的前三个标准，这个类就是单例模式的绝佳候选[11]。

### 单例模式

singleton 模式用于创建一个类，在这个类中，系统中应该只存在一个实例。singleton 类不属于它的任何消费者，但是类的单个实例也不是全局变量(然而，有些人认为 singleton 模式是伪装的全局数据)。为了不依赖荣誉系统，使用语言机制来确保只有一个实例化存在。

此外，在单例模式中，实例的生命周期通常是从第一次实例化开始，直到程序终止。根据实现的不同，可以创建线程安全的或者仅适用于单线程应用程序的单件。关于不同 C++单例实现的精彩讨论可以在 Alexandrescu [5]中找到。对于我们的计算器，我们更喜欢满足我们目标的最简单的实现。

为了得到一个简单的单例实现，我们参考我们的 C++语言知识。首先，如前所述，没有其他类拥有单例实例，单例实例也不是全局对象。这意味着单例类需要拥有它的单个实例，并且所有权访问应该是私有的。为了防止其他类实例化我们的 singleton，我们还需要将它的构造函数和赋值操作符私有或删除。第二，知道系统中应该只存在一个 singleton 实例意味着我们的类应该静态地保存它的实例。最后，其他类将需要访问这个实例，我们可以通过一个公共静态函数来提供。结合前面提到的要点，我们为 singleton 类构建了以下 shell:

```
class Singleton
{
public:
  static Singleton& Instance
  {
    static Singleton instance;
    return instance;
  }

  void foo(){ /* does foo things */ }

private:
  // prevent public instantiation, copying, assignment, movement,
  // & destruction
  Singleton() { /* constructor */ }
  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;
  Singleton(Singleton&&) = delete;
  Singleton&& operator=(Singleton&&) = delete;
  ~Singleton() { /* destructor */ }
};

```

`Singleton`类的静态实例保存在函数作用域而不是类作用域，以防止在一个单例类的构造函数依赖于另一个单例的情况下出现不可控的实例化顺序冲突。C++的实例化排序规则的细节超出了本书的范围，但是可以在 Alexandrescu [5]中找到关于单例的详细讨论。

注意，由于缺少对一个实例访问的锁定，我们的模型 singleton 目前只适合单线程环境。在这个多核处理器时代，这样的限制明智吗？对于 pdCalc，绝对！我们的简单计算器不需要多线程。编程很难。多线程编程要难得多。除非绝对必要，否则不要把简单的设计问题变成困难的问题。

现在我们有了一个`Singleton`类的外壳，让我们看看如何使用它。为了访问实例并调用`foo()`函数，我们只需使用以下代码:

```
Singleton::Instance().foo();

```

在对`Instance()`函数的第一次函数调用中，`instance`变量被静态实例化，并返回对该对象的引用。因为在函数作用域静态分配的对象会一直保留在内存中，直到程序终止，`instance`对象在`Instance()`函数作用域结束时不会被析构。在将来对`Instance()`的调用中，`instance`变量的实例化被跳过(它已经从之前的函数调用中构造好并存在内存中)，对`instance`变量的引用被简单地返回。注意，虽然底层的单例实例是静态的，但是`foo()`函数本身并不是静态的。

好奇的读者现在可能会问，“为什么要费心保存一个类的实例呢？为什么不干脆将所有数据和`Singleton`类的所有函数都变成静态的呢？”原因是因为单例模式允许我们在需要实例语义的地方使用`Singleton`类。这些语义的一个特别重要的用途是在回调的实现中。举个例子，以 Qt 的信号和插槽机制(我们会在第 [6](6.html) 章中遇到信号和插槽)为例，它可以被松散地解释为一个强大的回调系统。为了将一个类中的信号连接到另一个类中的插槽，我们必须提供指向两个类实例的指针。如果我们在没有`Singleton`类的私有实例化的情况下实现了我们的 singleton(也就是说，只利用静态数据和静态函数)，那么将我们的`Singleton`类与 Qt 的信号和插槽一起使用将是不可能的。

### 3.2.2 作为单例类的堆栈模块

我们现在拥有了堆栈模块的基本设计。我们决定将整个模块封装在一个类中，这个类实质上充当了 STL 容器的适配器。我们已经决定我们的一个类符合单例的模型标准，这个单例类将拥有在第 [2](2.html) 章中设计的公共接口。将这些设计元素结合起来，我们就有了类的初始声明。

```
// All module names in the repository source code are separated by
// underscores instead of periods due to a Visual Studio compiler bug.
// The book text uses the more conventional period as the module name
// separator (i.e., pdCalc_stack in source code).
export module pdCalc.stack;

export class Stack
{
public:
  static Stack& Instance();
  void push(double);
  double pop();
  void getElements(int, vector<double>&) const;
  void swapTop();

private:
  Stack();
  ~Stack();
  // appropriate blocking of copying, assigning, moving...
  deque<double> stack_;
};

Listing 3-1The stack as a singleton

```

因为这本书的重点是设计，除非细节特别有指导意义或者突出了设计的关键元素，否则在正文中不提供每个成员函数的实现。提醒一下，pdCalc 的完整实现可以从 GitHub 资源库下载。偶尔，存储库源代码会是文本中出现的理想化接口的更复杂的变体。这将是本书其余部分的通用格式。

你可能注意到了，尽管 STL 提供了一个`stack`容器，我们的`Stack`类是用一个`deque`实现的；太奇怪了。让我们绕一小段路来讨论这个相关的实现细节。我们花了很多时间回顾在`Stack`的设计中使用适配器模式来隐藏底层数据结构的重要性。这个决定的理由之一是，它能够无缝地改变底层实现，而不会影响依赖于`Stack`接口的类。问题是，“为什么`Stack`的底层实现可能会改变？”

在我的第一个版本的`Stack`实现中，我选择了底层数据结构 STL `stack`。然而，我很快就遇到了使用 STL `stack`的效率问题。我们的`Stack`类的接口提供了一个`getElements()`函数，使用户界面能够查看计算器堆栈的内容。不幸的是，STL `stack`的接口没有提供类似的功能。查看 STL `stack`顶部元素之外的元素的唯一方法是连续弹出`stack`直到到达感兴趣的元素。显然，因为我们只是试图看到`stack`的元素，而不是改变`stack`本身，所以我们需要立即将所有条目推回到`stack`上。有趣的是，对于我们的目的来说，STL `stack`被证明是不适合实现堆栈的数据结构！一定有更好的解决办法。

幸运的是，STL 提供了另一种适合我们任务的数据结构，双端队列，或`deque`。`deque`是一个 STL 数据结构，其行为类似于`vector`，除了`deque`允许将元素推到它的正面和背面。尽管`vector`被优化为在提供连续性保证的同时增长，但是`deque`被优化为通过牺牲连续性来快速增长和收缩。这个特性正是有效实现堆栈所必需的设计权衡。事实上，实现 STL `stack`最常见的方法就是简单地包装 STL `deque`(是的，就像我们的`Stack`，STL 的`stack`也是适配器模式的一个例子)。幸运的是，STL `deque`也允许非破坏性迭代，这是 STL `stack`中额外缺少的需求，我们需要实现`Stack`的`getElements()`方法。我使用封装对接口隐藏了`Stack`的实现，这很好。在意识到可视化 STL `stack`的局限性后，我能够更改`Stack`类的实现来使用 STL `deque`，而不会影响 pdCalc 的任何其他模块。

## 3.3 添加事件

构建符合第 [2 章](2.html)中堆栈接口的`Stack`的最后一个必要元素是事件的实现。事件是弱耦合的一种形式，它允许一个对象(通知者或发布者)向任意数量的其他对象(侦听器或订阅者)发出信号，告知发生了一些有趣的事情。耦合很弱，因为通知者和监听器都不需要直接知道对方的接口。事件的实现方式依赖于语言和库，即使在一种给定的语言中，也可能存在多种选择。比如在 C#中，事件是核心语言的一部分，事件处理相对容易。在 C++中，我们就没有这么幸运了，必须实现我们自己的事件系统，或者依赖一个提供这种功能的库。

C++程序员有几个已发布的库选项来处理事件；这些选择中最突出的是 boost 和 Qt。boost 库支持信号和插槽，这是发布者通过回调向订阅者发送事件信号的静态类型机制。另一方面，Qt 提供了完整的事件系统和动态类型的事件回调机制，巧合的是，这也被称为信号和插槽。这两个库都有很好的文档记录，经过了很好的测试，受到了广泛的尊重，并且可以用于开源和商业用途。这两个库都是在我们的计算器中实现事件的可行选择。然而，出于指导性的目的，也为了最小化我们的计算器后端对外部库的依赖性，我们将实现我们自己的事件系统。在设计您自己的软件时，做出适当的决定是非常依赖于具体情况的，您应该检查使用库与为您自己的应用程序构建自定义事件处理的利弊。也就是说，除非有令人信服的理由，否则默认情况下应该使用库。

### 3.3.1 观察者模式

因为事件是一个如此普遍实现的 C++特性，所以您可以放心，描述事件的设计模式是存在的；这个模式就是观察者。观察者模式是发布者和监听器的抽象实现的标准方法。正如该模式的名称所暗示的，在这里，侦听器被称为观察者。

在 Gamma 等人[11]描述的模式中，具体发布者实现抽象发布者接口，具体观察者实现抽象观察者接口。名义上，实现是通过公共继承实现的。每个发布者拥有一个观察者容器，发布者的接口允许附加和分离观察者。当事件发生(引发)时，发布者循环访问其观察器集合，并通知每个观察器事件已经发生。通过虚拟调度，每个具体的观察者根据自己的实现来处理这个通知消息。

观察器可以通过两种方式之一接收来自发布者的状态信息。首先，一个具体的观察者可以有一个指向它所观察的具体发布者的指针。通过这个指针，观察者可以查询事件发生时发布者的状态。这种机制被称为拉语义。或者，可以实现推送语义，从而发布者将状态信息与事件通知一起推送给观察者。在图 [3-1](#Fig1) 中可以找到展示推送语义的观察者模式的简化类图。

![../images/454125_2_En_3_Chapter/454125_2_En_3_Fig1_HTML.png](../images/454125_2_En_3_Chapter/454125_2_En_3_Fig1_HTML.png)

图 3-1

观察者模式的类图的简化版本，因为它是为 pdCalc 实现的。该图说明了事件数据的推送语义

#### 增强观察者模式的实现

在我们的计算器的实际实现中，除了图 [3-1](#Fig1) 中描述的抽象之外，还添加了几个额外的特性。首先，在图中，每个发布者拥有一个观察者列表，当事件发生时，所有的观察者都会得到通知。然而，这种实现意味着发布者只有一个事件，或者发布者有多个事件，但是无法区分每个事件调用了哪些观察者。一个更好的 publisher 实现将一个关联数组保存到观察者列表中。以这种方式，每个发布者可以有多个不同的事件，每个事件只通知有兴趣观看该特定事件的观察者。虽然关联数组中的键在技术上可以是设计者选择的任何合适的数据类型，但我选择对计算器使用字符串。也就是说，发布者通过名称来区分各个事件。这种选择增强了可读性，并使运行时能够灵活地添加事件(比如说，选择枚举值作为键)。

一旦 publisher 类可以包含多个事件，程序员就需要能够在调用`attach()`或`detach()`时通过名称指定事件。因此，这些方法签名必须根据它们在图 [3-1](#Fig1) 中的显示进行适当的修改，以包含一个事件名称。对于附件，方法签名通过添加事件的名称来完成。调用者只需用具体的观察器实例和该观察器所连接的事件的名称来调用`attach()`方法。然而，将观察者与发布者分离需要稍微复杂一些的机制。由于发布者中的每个事件可以包含多个观察者，程序员需要能够区分观察者以实现分离。自然地，这个需求也导致了对观察者的命名，并且必须修改`detach()`函数签名以适应观察者和事件的名称。

为了便于分离观察器，每个事件上的观察器应该被间接存储，并通过它们的名称来引用。因此，我们没有存储观察器列表的关联数组，而是选择使用观察器关联数组的关联数组。

在现代 C++中，程序员可以选择使用`map`或`unordered_map`作为关联数组的标准库实现。这两种数据结构的规范实现分别是红黑树和哈希表。因为关联数组中元素的顺序并不重要，所以我为 pdCalc 的`Publisher`类选择了`unordered_map`。然而，对于订阅每个事件的少数观察者来说，这两种数据结构都是同样有效的选择。

到目前为止，我们还没有详细说明观察者是如何存储在发布器中的，只知道它们以某种方式存储在关联数组中。因为观察器是以多种形式使用的，所以语言规则要求通过指针或引用来保存它们。那么问题就变成了，发布者应该拥有观察者还是仅仅引用其他类拥有的观察者？如果我们选择引用路径(通过引用或原始指针)，那么除了发布者之外，还需要一个类来拥有观察者的内存。这种情况是有问题的，因为不清楚在任何特定情况下谁应该拥有观察器。因此，每个开发人员可能会选择不同的选项，长期来看，观察者的维护会陷入混乱。更糟糕的是，如果观察器的所有者释放了观察器的内存，而没有将观察器从发布器分离，则触发发布器的事件将导致崩溃，因为发布器将持有对观察器的无效引用。由于这些原因，我更喜欢让发布者拥有观察者的记忆。

避开了引用，我们必须使用所有权语义，并且，由于 C++的多态机制，我们必须通过指针实现所有权。在现代 C++中，指针类型的唯一所有权是通过`unique_ptr`实现的(参见现代 C++关于所有权语义的侧栏，以理解设计含义)。将前面所有的建议放在一起，我们能够为`Publisher`类设计最终的公共接口:

```
// Publisher.m.cpp
export module pdCalc.utilities:Publisher;

import :Observer;

export class Publisher
{
  using ObserversList = unordered_map<string, unique_ptr<Observer>>;
  using Events = unordered_map<string, ObserversList>;
public:
  void attach(const string& eventName,
              unique_ptr<Observer> observer);
  unique_ptr<Observer> detach(const string& eventName,
                              const string& observerName);
  // ...
private:
  Events events_;
};

```

注意，`Publisher`是从`utilities`模块的`Publisher`分区导出的。`utilities`模块的`Observer`分区被导入以提供`Observer`类的定义。乍一看，您可能想知道为什么要导入`Observer`模块分区，而不是简单地向前声明`Observer`类。毕竟，在`Publisher`的声明中，只有不完整的`Observer`类型用于声明`Observer`智能指针。然而，`Publisher.m.cpp`文件包含了分区接口单元及其实现。因此，对于`Publisher`的定义，这个文件中需要`Observer`类的完整定义。如果`Publisher`分区被分割成独立的接口和实现文件，那么接口将只需要一个`Observer`的前向声明。

`Observer`类的接口比`Publisher`类的接口简单得多。然而，因为我们还没有描述如何处理事件数据，我们还没有准备好设计`Observer`的接口。我们将在“处理事件数据”一节中讨论事件数据和`Observer`类的接口。

Modern C++ Design Note: Owning Semantics and `Unique_Ptr`

在 C++中，拥有一个对象的概念意味着当不再需要这个对象时，有责任删除它的内存。在 C++11 之前，尽管任何人都可以实现自己的智能指针(很多人都这样做了)，但该语言本身并没有表达指针所有权的标准语义(除了`auto_ptr`，它在 C++11 中被弃用，在 C++17 中被完全删除)。通过本机指针传递内存更像是一个信任问题。也就是说，如果你“新建”了一个指针，并通过原始指针将它传递给一个库，你希望库在使用完它时删除内存。或者，库的文档可能会通知您在执行某些操作后删除内存。如果没有标准的智能指针，在最坏的情况下，你的程序会泄漏内存。在最好的情况下，您必须使用非标准智能指针连接到库。

C++11 通过标准化一组主要从 boost 库中借用的智能指针纠正了未知指针所有权的问题。`unique_ptr`最终允许程序员正确地实现唯一所有权(因此不赞成使用`auto_ptr`)。从本质上来说，`unique_ptr`确保了在任何时候只有一个指针的实例存在。对于执行这些规则的语言，没有实现对`unique_ptr`的复制和非移动赋值。相反，使用移动语义来确保所有权的转移(显式函数调用也可以用于手动管理内存)。Josuttis [13]对使用`unique_ptr`的机制提供了极好的详细描述。需要记住的重要一点是不要在`unique_ptr`和原始指针之间混合指针类型。

从设计的角度来看，`unique_ptr`意味着我们可以使用标准 C++编写接口，明确表达独特的所有权语义。正如在 observer 模式的讨论中所看到的，在一个类创建内存供另一个类使用的任何设计中，惟一的所有权语义都是非常重要的。例如，在计算器的事件系统中，虽然事件的发布者应该拥有它的观察器，但是发布者很少有足够的信息来创建它的观察器。因此，能够在一个位置为观察者创建内存，但能够将该内存的所有权传递给另一个位置，即发布者，这一点很重要。`unique_ptr`提供这种服务。因为观察者是通过一个`unique_ptr`传递给发布者的，所以所有权转移给了发布者，当发布者不再需要观察者时，智能指针会删除观察者的内存。或者，任何类都可以从发布者那里收回一个观察者。由于`detach()`方法在`unique_ptr`中返回观察者，发布者显然通过将观察者的内存转移回调用者而放弃了它的所有权。

观察者模式的上述实现明确地实施了一种设计，其中`Publisher`拥有它的`Observer`。使用这种实现的最自然的方式是创建小的、专用的、中间的`Observer`类，这些类本身持有指针或对应该响应事件的实际类的引用。比如从第 [2](2.html) 章，我们知道 pdCalc 的用户界面是`Stack`类的观察者。然而，我们真的希望用户界面是如图 [3-2a](#Fig2) 所示的`Stack`所拥有的`Observer`吗？不会。图 [3-2c](#Fig2) 描述了一个更好的解决方案。这里，`Stack`拥有一个栈`ChangeEvent`观察器，当栈改变时，它依次通知`UserInterface`。这种模式使得`Stack`和`UserInterface`能够保持真正的独立。当我们在第 [5](5.html) 章中研究我们的第一个用户界面时，我们会对这个话题进行更多的讨论。

![../images/454125_2_En_3_Chapter/454125_2_En_3_Fig2_HTML.png](../images/454125_2_En_3_Chapter/454125_2_En_3_Fig2_HTML.png)

图 3-2

观察者模式的不同所有权策略

现代 C++确实承认观察者模式的所有权语义的另一个合理的替代方案:共享所有权。正如我们之前所说的，`Stack`拥有用户界面是不合理的。然而，有些人可能认为创建一个额外的`ChangeEvent`中间类而不是直接让用户界面成为观察者同样不合理。唯一的折中选择似乎是让`Stack`引用用户界面。但是，之前我们说过让发布者引用它的观察者是不安全的，因为观察者可能会从发布者下面消失，留下一个悬空的引用。如果我们能解决这个悬而未决的引用问题呢？

幸运的是，现代 C++再一次用共享语义拯救了我们(如图 [3-2b](#Fig2) 所示)。在这个场景中，观察者将使用一个`shared_ptr`(参见关于`shared_ptr` s 的侧栏)来共享，而发布者将保留一个对具有`weak_ptr`(相对于`shared_ptr`)的观察者的引用。`weak_ptr`是专门为减轻对共享对象的悬空引用而设计的。Meyers [24]在第 20 项中描述了发布者共享观察者所有权的设计。就我个人而言，我更喜欢使用拥有语义和轻量级专用观察者类的设计。

##### 处理事件数据

在描述观察者模式时，我们提到了两种不同的处理事件数据的范例:拉和推语义。在拉语义中，观察者被简单地通知事件已经发生。然后，观察者具有获取可能需要的任何额外数据的额外责任。实现非常简单。观察器维护对任何对象的引用，它可能需要从该对象获取状态信息，并且观察器调用成员函数来获取该状态以响应事件。

拉语义有几个优点。首先，观察者可以在处理事件时选择它想要获得的确切状态。其次，在向观察者传递潜在未使用的参数时，不会消耗不必要的资源。第三，拉语义很容易实现，因为事件不需要携带数据。然而，拉语义也有缺点。首先，拉语义增加了耦合性，因为观察者需要引用并理解发布者的状态获取接口。第二，观察者只能访问发布者的公共接口。这种访问限制使得观察者无法从发布者处获得私人数据。

与拉语义相反，推语义是通过让发布者在事件被引发时发送与该事件相关的状态数据来实现的。观察器然后接收这个状态数据作为通知回调的参数。该接口通过在抽象基类`Observer`中使 notify 函数成为纯虚拟的来实施推送语义。

事件处理的推送语义也有优点和缺点。第一个优点是推语义减少了耦合。发布者和观察者都不需要知道彼此的接口。他们只需要服从抽象事件接口。其次，发布者可以在推送状态时向观察者发送私有信息。第三，作为引发事件的对象，发布者可以准确地发送处理事件所需的数据。推送语义的主要缺点是，在观察者不需要发布者推送的状态数据的情况下，实现起来稍微困难一些，并且可能带来不必要的开销。最后，我们注意到，对于特殊情况，使用 push 语义的设计总是可以通过添加对 push 数据的回调引用，用 pull 语义进行简单的扩充。反之则不然，因为推送语义需要事件处理机制中的专用基础设施。

基于前面描述的推和拉语义之间的权衡，我选择为 pdCalc 的事件处理实现推语义。推送语义的主要缺点是实现的潜在计算开销。然而，由于我们的应用程序不是性能密集型的，所以这种模式所表现出的耦合性降低和发布者维护的参数控制超过了轻微的性能开销。我们现在的任务是设计一个实现，通过推送语义传递事件数据。

为了实现事件处理的推语义，必须标准化接口，以便在事件发生时将参数从发布者传递给观察者。理想情况下，每个发布者/观察者对要传递的参数类型达成一致，当事件发生时，发布者将调用观察者上适当的成员函数。然而，在我们的发布者/观察者类层次结构中，这种理想情况实际上是不可能的，因为具体的发布者不知道具体的观察者的接口。具体的发布者只能通过调用`Publisher`基类中的`raise()`函数来引发事件。反过来，`raise()`函数通过`Observer`基类的虚拟`notify()`函数多态地通知一个具体的观察者。因此，我们寻求一种通用的技术，通过抽象的 raise/notify 接口传递定制的数据。

本质上，我们的问题归结为定义一个到`notify(T)`的接口，使得`T`可以包含任何类型的数据，包括数据可能为空的情况。我介绍了完成这项任务的两种类似技术；只有第二个在 pdCalc 中实现。第一种技术更像是基于多态设计的“经典”解决方案。这是我在第一版中展示的唯一设计。第二种解决方案是基于一种更现代的技术，称为类型擦除。如果你愿意写很多锅炉板代码，类型擦除在 C++17 之前是可能的。然而，C++17 中引入的`any`类使得对对象应用这种技术变得微不足道。这种技术被称为类型擦除，因为对象的类型在传递给`any`类时被“擦除”,只有在对象被提取时才被`any_cast`重新创建。让我们依次检查每个解决方案。

为了将多态解决方案应用于事件数据问题，我们为事件数据创建了一个并行对象层次结构，并通过这个抽象状态接口将事件数据从发布者传递给观察者。这个层次结构中的基类`EventData`是一个空类，只包含一个虚析构函数。然后，每个需要参数的事件都会对这个基类进行子类化，并实现任何被认为合适的数据处理方案。当事件被引发时，发布者通过一个`EventData`基类指针将数据传递给观察者。收到数据后，具体的观察器将状态数据向下转换到具体的数据类，然后通过派生类的具体接口提取必要的数据。虽然具体的发布者和具体的观察者必须就数据对象的接口达成一致，但是具体的发布者和具体的观察者都不需要知道对方的接口。因此，我们保持松散耦合。

事件数据问题的类型擦除解决方案在概念上类似于多态方法，除了我们不需要一个`EventData`基类。相反，标准的`any`类代替了接口中的抽象基类(参见讨论`any`、`variant`和`optional`的侧栏)。只要具体的发布者和具体的观察者对这个类中包含的内容达成一致，任何对象，包括内置类型，都可以作为数据传递。发布者通过一个`any`对象传递一个具体类型，观察者通过`any_cast`事件数据有效负载重新创建适当的具体类型，从而执行该协议。和以前一样，虽然在具体的发布者和具体的观察者之间必须存在关于数据的隐式协议，但是他们都不需要知道对方的接口。

Modern C++ Design Note: Using `Std::Any, Std::Variant, Std::Optional`, and Structured Bindings

C++17 标准库引入了三种新的有用的类型:`std::any`、`std::variant`和`std::optional`。`any`设计用于保存任何类型——逻辑上等同于类型安全的 void 指针。它是对象类型擦除的一般实施例。`variant`提供类型安全的联合。`optional`实现可空类型。让我们来看一个简单的例子，看看它们是如何使用的。

`any`的用法和你所想的完全一样。也就是说，`any`是一个可以保存任何值的对象，而无需事先指定所包含值的类型。例如:

```
any a = 7; // assign an int
a = "hello"; // now assign a const char*
cout << any_cast<int>(a); // a not an int; throws std::bad_any_cast
cout << any_cast<const char*>(a); // works as expected

```

正文中展示了一个更实际的例子，使用`any`在事件之间传递任意数据。

当你需要一个容器能够容纳一组特定的预先知道的类型中的任何一个时，就使用一个`union`。`union`的内存效率非常高，因为它们仅拥有足够的内存来保存最大的类型。考虑以下支持的语言`union`:

```
union
{
  int i;
  double d;
} w;

w.i = 102; // ok, assign an int
cout << w.i; // no problem
cout << w.d; // oops, this "works" but results in nonsense
w.d = 107.3; // no problem

```

标准库`variant`是基于相同概念的类型安全改进。使用`variant`，我们可以以类型安全的方式编写与前面描述的代码相同的代码:

```
variant<int, double> v;
v = 102; // ok, assign an int
cout << std::get<int>(v); // no problem
cout << std::get<double>(v); // throws std::bad_variant_access
v = 107.3; // no problem

```

就我个人而言，我很少使用联合。然而，当需要联合时，我强烈倾向于标准库`variant`而不是本地语言`union`。

现在我们来考察一下`optional`是如何使用的。你见过类似下面的代码吗:

```
pair<bool, double> maybeReturnsDouble(); // function declaration

// ok, but tedious:
auto [flag, val] = maybeReturnsDouble();
if(flag) { /* ok to use val */ }

// downright dreadful (and common in computational code!):
const double NullDouble = -999999999.0
double d = maybeReturnsDouble();
if(d != NullDouble) { /* ok to use d */ }

```

前面的攻击是必要的，因为 C++内置类型(除了指针)不能表达空状态，该语言也不支持检查`d`是否未初始化的工具。如果您选择不初始化`d`，`d`肯定是有效的双精度值，但是不能保证它的值是除了编译器分配给`d`的字节中的位模式以外的任何值。这种行为经常会导致难以解释的错误，这些错误出现在发布版本中，但不会出现在调试版本中，因为调试模式通常会将未初始化的数字初始化为`0`，而发布模式不会初始化未初始化的数字。因此，以下代码在发布和调试模式下的行为有所不同:

```
int flag; // uh oh, forgot to initialize
// flag == 0 for debug but probably not 0 for release

if(flag) {/* will likely execute this path for release */}
else {/* will execute this path for debug */}

```

我花了很多时间向初级程序员解释，不，他们不只是发现了一个编译器错误，而是编译器发现了他们的错误。

标准库`optional`类使程序员能够避免前面的问题。考虑以下代码:

```
optional<double> maybeReturnsDouble(); // new function declaration

auto d = maybeReturnsDouble();
if(d) { /* ok to use d */ }

```

啊，好多了！显然，`d`转换为`bool`，如果`d`为非空，则返回`true`。如果你喜欢更详细的语法，你可以调用`has_value()`成员函数。可以通过解引用(即`*d`)或通过`value()`成员函数来访问`d`的值。如果一个`optional`没有被初始化，用空的构造函数初始化(即`{}`)，或者用`nullopt`显式初始化，那么它被认为是空的。

您是否注意到前面的代码中有什么语法上的奇怪之处？让我们重复一句看起来很陌生的台词:

```
auto [flag, val] = maybeReturnsDouble();

```

前面的语法称为结构化绑定。C++17 中引入的结构化绑定为表达式的元素命名提供了语法上的便利。回想一下我们最初版本的`maybeReturnsDouble()`,它返回一个`pair<bool, double>`,首先指示`double`是否被定义，其次指示`double`本身的值。在结构化绑定之前，我们有几个使用返回值的选项:直接使用`pair`的`first`和`second`成员(不透明和混乱)，创建新的变量并将它们分配给`pair`的`first`和`second`成员(清晰，但冗长)，或者使用`std::tie`(现在没有必要)。虽然该示例在绑定到可访问类成员的上下文中显示了结构化绑定，但是结构化绑定也可以用于绑定到类似元组的对象和数组。此外，如果底层元素必须通过绑定名称进行修改，那么可以将结构化绑定声明为`const`或引用类型。虽然结构化绑定从根本上说不允许你做以前不能做的事情，但是它们确实很方便，并且通过紧凑的语法更好地表达了程序员的意图。我发现我经常使用它们。

为了巩固上述观点，让我们来看看计算器的`Stack`是如何实现状态数据的。回想一下第 [2](2.html) 章，其中的`Stack`实现了两个事件:`stackChanged()`事件和`error(string)`事件。在这种情况下，`stackChanged()`事件是没有意义的，因为该事件不携带任何数据。然而，错误事件确实携带数据。考虑下面的代码，它解释了如何为多态或类型擦除技术实现`Stack`的错误条件:

```
// Polymorphic event data strategy:
// Publisher.m.cpp
export class EventData
{
public:
    virtual ~EventData();
};

// Stack.m.cpp
// export to become part of the stack module's interface
export class StackErrorData : public EventData
{
public:
  enum class ErrorConditions { Empty, TooFewArguments };
  StackErrorData(ErrorConditions e) : err_(e) { }

  static const char* Message(ErrorConditions ec);
  const char* message() const;
  ErrorConditions error() const { return err_; }

private:
  ErrorConditions err_;
};

// Type erasure event data strategy:
// Publisher.m.cpp - no code necessary in this file

// Stack.m.cpp
export public StackErrorData
{
  // Same implementation as above, but no inheritance needed
};

```

`StackErrorData`类定义了`Stack`的事件数据如何打包并发送给观察`Stack`的类。当堆栈模块中出现错误时，`Stack`类会引发一个事件，并将有关该事件的信息推送给它的观察者。在这个实例中，`Stack`创建了一个`StackErrorData`的实例，指定了构造函数中的错误类型。这个包含有限错误条件集的枚举类型可以使用`message()`函数转换成一个字符串。当观察者得到事件发生的通知时，他们可以自由地使用或忽略这些信息。如果你注意的话，是的，我巧妙地改变了`error()`接口的签名。

作为一个具体的例子，假设由于弹出一个空堆栈而触发了一个错误。为了引发这个事件，`Stack`调用下面的代码:

```
// Polymorphic strategy:
raise(Stack::StackError(), make_shared<StackErrorData>(
  StackErrorData::ErrorConditions::Empty));

// Type erasure strategy:
raise(Stack::StackError(),
  StackErrorData{StackErrorData::ErrorConditions::Empty});

```

对于这两种策略，`raise()`函数的第一个参数是一个静态函数，它返回一个解析为`"error"`的字符串。回想一下，为了处理多个事件，发布者给每个事件命名。这里，`Stack::StackError()`返回这个事件的名称。使用函数而不是直接使用字符串来防止由于在源代码中错误键入事件名称而导致的运行时错误。`raise()`函数的第二个参数创建了`StackErrorData`实例，并用空堆栈错误条件初始化它。对于多态策略，实现使用`shared_ptr`清楚地传递事件数据。这个决定在关于共享语义的侧栏中讨论。对于类型擦除策略，构造一个`StackErrorData`类，并将其作为构造函数参数隐式传递给`raise()`函数接口中的`any`类。虽然还没有引入`StackObserver`类，但是为了完整起见，我们注意到可以用以下代码来解释事件:

```
// Polymorphic strategy:
void StackObserver::notify(shared_ptr<EventData> d)
{
  shared_ptr<StackErrorData> p = dynamic_pointer_cast<StackErrorData>(d);

  if(p)
  {
    // do something with the data
  }
  else
  {
    // uh oh, what event did we just catch?!
  }
}

// Type erasure strategy:
void StackObserver::notify(const any& d)
{
  try
  {
    const auto& d = any_cast<StackErrorData>(data);
    // do something with the data
  }
  catch(const std::bad_any_cast&)
  {
    // uh oh, what event did we just catch?!
  }
}

```

为什么选择一种策略而不是另一种？就个人而言，我发现类型擦除方法比多态方法更简洁；在许多情况下，它也可能更有效率。首先，使用`any`类比使用多态层次结构需要更少的代码。第二，使用`any`类限制较少。虽然前面提到的例子在两种情况下都显示了使用`StackErrorData`类的实例，但是`any`可以用于存储简单类型，如`double`或`string`，完全不需要用户定义的类。最后，根据`any`的实现，类型擦除方法可能比多态方法更有效。在多态方法总是需要使用`shared_ptr`进行堆分配的情况下，`any`的高质量实现将避免为适合小内存占用的对象进行堆分配。当然，多态方法确实有一个明显的优势。它应该在需要多态的情况下使用(例如，在使用虚函数而不是类型转换的接口中)，或者在需要通过抽象接口实现强制的、一致的接口的情况下使用。如前所述，多态接口是为这本书的第一版实现的。现在 C++17 在标准库中包含了`any`类，本书第二版中 pdCalc 的实现实现了类型擦除策略。

Modern C++ Design Note: Sharing Semantics and `Shared_Ptr`

鉴于`unique_ptr`使程序员能够安全地表达唯一所有权，`shared_ptr`使程序员能够安全地表达共享所有权。在 C++11 标准之前，C++通过原始指针或引用实现数据共享。因为类数据的引用只能在构造期间初始化，所以对于后期绑定数据，只能使用原始指针。因此，通常两个类共享一段数据，每个类都包含一个指向公共对象的原始指针。当然，这种情况的问题是不清楚哪个对象拥有共享对象。特别是，这种模糊性意味着不确定何时可以安全地删除这样的共享对象，以及哪个拥有对象最终应该释放内存。`shared_ptr`让我们在标准库层面纠正这一困境。

`shared_ptr`通过引用计数实现共享语义。当新对象指向一个`shared_ptr`时，内部引用计数增加(通过构造函数和赋值来强制)。当一个`shared_ptr`超出范围时，它的析构函数被调用，这将减少内部引用计数。当计数变为零时，最后一个`shared_ptr`的销毁会触发底层内存的回收。与`unique_ptr`一样，显式成员函数调用也可以用来手动管理内存。Josuttis [13]对使用`shared_ptr`的机制提供了极好的详细描述。与`unique_ptr`一样，必须小心不要混淆指针类型。当然，这个规则的例外是与`weak_ptr`混合使用。此外，引用计数会带来时间和空间开销，因此读者应该在部署共享指针之前熟悉这些权衡。

就设计考虑而言，`shared_ptr`构造使程序员能够共享堆内存，而无需直接跟踪对象的所有权。通过值传递多态类型的对象不是一个选项，因为对于存在于层次结构中的对象，通过值传递对象会导致切片。然而，使用原始指针(或引用)来传递事件数据也是有问题的，因为这些数据对象的生命周期在共享它们的类中是未知的。考虑到 pdCalc 在使用多态事件数据策略时需要使用一个`shared_ptr`。自然，发布者在引发事件时会分配内存。由于观察者可能希望在事件处理完成后保留内存，所以发布者不能在事件被处理后简单地释放内存。此外，因为可以为任何给定的事件调用多个观察者，所以发布者也不能将数据的唯一所有权转移给任何给定的观察者。对于 pdCalc 中的事件数据，我们看到 C++17 允许使用`std::any`的替代设计。然而，类型擦除并不总是能够取代共享所有权。在需要共享所有权的地方，C++11 中标准化的`shared_ptr`提供了理想的语义。

现在我们理解了事件数据，我们终于准备好编写抽象的`Observer`接口了。不出所料，这正是你所期待的。

```
export module pdCalc.utilities:Observer;
export class Observer
{
public:
  explicit Observer(std::string_view name);
  virtual ~Observer();

  virtual void notify(const any& data) = 0;
};

```

也许这个接口并不完全符合您的预期，特别是因为`Observer`类的构造函数使用了 C++17 中引入的 C++标准库的一个新特性`string_view`。我们将暂停一下来讨论下面边栏中的`string_view`。在短暂的转移之后，我们将通过演示`Stack`如何发布事件来结束`Stack`类接口的设计。

Modern C++ Design Note: Referring to `Std::Strings with Std::String_View`

在 C++17 之前，当引用一个不可变的字符串(特别是一个字符序列)时，我们通常使用`const char*`或`const string&`，这取决于底层的类型。为什么我们需要一个新的容器来引用字符串？

使用上述两种类型来引用字符串可能会有问题。首先，要使用一个`const char*`，我们要么需要知道底层类型是一个`char*`，要么我们需要将一个`string`转换成一个`const char*`。另外，`const char*`不存储底层字符串的长度。相反，假设字符序列是空终止的(即以`'\0'`结束)。相反，如果我们改为使用一个`const string&`，如果底层类型已经是一个字符串，这很好，但是如果底层类型是一个`const char*`，我们需要不必要地构造一个临时的`string`。类别解决了这些问题。

`string_view`类本质上是一个容器，它保存一个指向字符类型的常量指针和一个整数，该整数指定组成字符串的连续字符序列的长度。其实施的影响既有其优点，也有其不足之处。先说优势。

`string_view`类最大的优点是非常高效，可以指向大多数用 C++表示的字符串类型。相对于普通的`const char*`，`string_view`更安全，因为`string_view`知道它所代表的嵌入字符串的长度。作为一个类，`string_view`也有更丰富的接口(尽管有人可能会说`const char*`有丰富的库支持)。相对于一个`const string&`，一个`string_view`永远不会隐式地创建一个`const char*`的临时副本，并且因为一个`string_view`是不拥有的，它有非常有效的成员函数来实现像创建子字符串这样的功能。这种效率的提高是因为对`string_view`的`substr()`函数的调用返回一个新的`string_view`，这不需要构造新的`string`，只需要将一个字符指针(新的开始)和一个整数(新的长度)分配给同一个引用的原始字符串。

s 也有一些缺点。虽然`string_view`知道自己的大小是有好处的，但这对于期望空终止字符串的库调用来说是不利的。从一个`string_view`产生一个空终止字符串的最简单的方法是构造一个`string`并使用它的`c_str()`函数。在这一点上，使用一个`const string&`将是更好的选择。另外两种情况下，`const string&`优于`string_view`的情况是已知`string`已经存在，以及现有接口需要`string`或`const char*`。

最后，我们必须小心管理一个`string_view`的生命周期。重要的是，`string_view`是不拥有的，因此只能“查看”一个单独拥有的字符串。如果一个字符串在一个引用的`string_view`之前被销毁，那么`string_view`将处于无效状态(与悬空指针相同)。因此，你必须确保一个字符串的生命周期等于或超过任何指向它的`string_view`的生命周期。

总之，`string_view`是对`const char*`和`const string&`传弦的一个现代的、不为人知的改进。除了在我们需要一个空终止的字符串，我们需要一个`string`用于后续的函数调用，或者我们已经有了一个`string`的情况下，`string_view`通常应该是首选。当使用`string_view`时，要注意对象的寿命，确保底层的字符串存储比`string_view`长。

### 3.3.2 作为事件发布者的堆栈

构建`Stack`的最后一步是简单地将所有的部分放在一起。清单 [3-1](#PC3) 将`Stack`显示为单例。为了实现事件，我们简单地修改代码，从`Publisher`基类继承。我们现在必须问自己，这份遗产应该是公有的还是私有的？

通常，在面向对象编程中，人们使用公共继承来表示*是一个*关系。也就是说，公共继承表达了一种关系，即派生类是基类的一种类型或一种专门化。更准确地说， *is-a* 关系遵循利斯科夫替换原则(LSP) [37]，该原则声明(通过多态)将基类指针(引用)作为参数的函数必须能够在不知道的情况下接受派生类指针(引用)。简而言之，只要基类可以互换使用，派生类就必须是可用的。当人们提到继承时，他们通常是指公共继承。

私有继承用于表达*实现——一种*关系。简单地说，私有继承用于将一个类的实现嵌入到另一个类的私有实现中。它不遵守 LSP，事实上，如果继承关系是私有的，C++语言不允许用派生类替换基类。为了完整性，密切相关的受保护继承在语义上与私有继承相同。唯一的区别是，在私有继承中，基类实现在派生类中变为私有，而在受保护继承中，基类实现在派生类中变为受保护。

我们的问题现在已经细化到，“*是*`Stack`*`Publisher`还是`Stack` *实现了* `Publisher`？答案是肯定的，肯定的。这是无益的，所以我们如何选择？*

 *为了明确在这个实例中我们应该使用公共继承还是私有继承，我们必须更深入地研究`Stack`类的用法。公共继承，或者说*是一种*关系，将表明我们作为发布者多态地使用堆栈的意图。然而，事实并非如此。虽然`Stack`类是一个发布者，但在 LSP 的意义上，它不是一个可以替代`Publisher`的发布者。因此，我们得出结论，我们应该使用私有继承来表明在`Stack`中使用`Publisher`的实现的意图。等价地，我们可以说`Stack`提供了`Publisher`服务。如果您一直关注存储库源代码，您可能会注意到一个很大的提示，即私有继承就是答案。`Publisher`类是用非虚拟的、受保护的析构函数实现的，这使得它不能用于公共继承。

熟悉面向对象设计的读者可能会奇怪，为什么我们没有问无处不在的 *has-a* 问题，这个问题表示所有权或聚合关系。也就是说，为什么`Stack`不应该简单地拥有一个`Publisher`并重用它的实现，而不是从它那里私有地继承？许多设计者几乎只喜欢使用聚合来代替私有继承，他们认为当在这两者之间有一个等价的选择时，人们应该总是更喜欢导致松散耦合的语言特性(继承是比聚合更强的关系)。这个意见有可取之处。不过，就我个人而言，我只是更愿意接受这种用更强的耦合来换取更清晰的技术。我认为私有继承比聚合更清楚地陈述了实现`Publisher`服务的设计意图。这个决定没有正确或错误的答案。在你的代码中，你应该选择适合你口味的风格。

私有继承`Publisher`类的另一个结果是`Publisher`的`attach()`和`detach()`方法变成私有的。然而，如果任何其他类打算订阅`Stack`的事件，它们需要成为`Stack`的公共接口的一部分。因此，实现者必须选择使用语句或转发成员函数来将`attach()`和`detach()`提升到`Stack`的公共接口中。在这种情况下，两种方法都是可以接受的，实现者可以自由地使用他们的个人偏好。

### 3.3.3 完整的堆栈模块接口

我们终于准备好编写完整的`Stack`公共接口，包括`Stack`和`StackErrorData`类。在下面的代码清单中，为了简洁起见，省略了 include 语句、导入、命名空间使用声明以及类的任何私有部分。当然，所有这些实现细节都包含在 GitHub 资源库附带的源代码中。

```
export module pdCalc.stack;

export namespace pdCalc {

class StackErrorData
{
public:
  enum class ErrorConditions { Empty, TooFewArguments };
  explicit StackErrorData(ErrorConditions e);

  static const char* Message(ErrorConditions ec);
  const char* message() const;
  ErrorConditions error() const;
};

class Stack : private Publisher
{
public:
  static Stack& Instance();

  void push(double, bool suppressChangeEvent = false);
  double pop(bool suppressChangeEvent = false);
  void swapTop();

  vector<double> getElements(size_t n) const;

  using Publisher::attach;
  using Publisher::detach;

  static string StackChanged();
  static string StackError();
};

} // namespace pdCalc

```

如本章所述，`Stack`是实现`Publisher`服务的单例类(注意`Instance()`方法)(注意`Publisher`类的私有继承和`attach()`和`detach()`方法到公共接口的提升)。`Stack`类的公共部分与`StackErrorData`类一起，包含了第 [2](2.html) 章表 [2-2](2.html#Tab2) 中介绍的堆栈模块的完整接口。虽然我们还没有为`Stack`描述任何具体的观察者，但是我们已经为 pdCalc 完全定义了我们的事件系统，它是基于可靠的观察者模式。至此，我们已经准备好设计 pdCalc 的下一个组件，命令调度程序模块。

## 3.4 测试的快速说明

在结束介绍 pdCalc 源代码的第一章之前，我们应该暂停一下，说几句关于测试的话。测试绝不是本书的中心探索主题，试图深入涵盖设计和测试肯定会破坏本文的凝聚力。相反，对开发人员测试的彻底探索感兴趣的读者可以参考 Tarlinder 的优秀著作[35]。尽管如此，测试是任何高质量实现不可或缺的一部分。

除了在 GitHub 上找到的计算器的源代码，我还包含了我所有的自动化单元测试代码。因为我选择使用 Qt 作为 pdCalc 的图形用户界面框架(参见第 [6](6.html) 章)，QtTest 框架是构建 pdCalc 的单元测试套件的自然选择。首先，这种选择不会在项目上增加任何额外的库依赖，并且测试框架保证可以在移植了 Qt 的所有平台上工作。也就是说，许多高质量的 C++单元测试框架中的任何一个都足够了。

就我个人而言，我发现即使是对小项目进行编程时，单元测试也是不可或缺的。首先也是最重要的，单元测试提供了一种方法来确保你的代码按预期运行(验证)。第二，单元测试使你能够在开发用户界面之前很久就看到一个模块正确地工作。早期测试能够实现早期的错误检测，软件工程中一个众所周知的事实是，早期的错误检测会导致以指数方式降低的错误修复成本。我还发现，在开发周期的早期看到模块完全工作是一种奇怪的激励。最后，单元测试还能让你知道代码在修改前后的功能是一样的(回归测试)。由于迭代是设计和实现的基本元素，您的代码将会改变无数次，甚至在您认为已经完成之后。在每次构建时自动运行全面的单元测试将确保新的变化不会不可预测地破坏任何现有的功能单元。

因为我非常重视测试(这是我试图教给新的专业开发人员的第一课)，所以我努力确保 pdCalc 代码测试的完整性。虽然我希望测试代码是高质量的，但我承认我的测试术语有时有点草率，在某些情况下，我可能严重混淆了单元、集成和系统测试之间的界限。尽管如此，所有的测试都运行得非常快，而且他们向我保证，我的代码在编写本书的整个代码开发阶段都得到了验证。然而，尽管我尽了最大的努力来编写没有错误的代码，甚至在对源代码进行了不合理的多次审查之后，我确信最终产品中仍然存在缺陷。请随时给我发电子邮件，告诉我你发现的所有错误。我将尽最大努力在 GitHub 资源库和本书的任何未来版本中加入对代码的更正，并对第一个向我报告我的任何错误的读者给予适当的说明。*