# 三、C++ 中的 C

因为 C++ 是基于 C 的，所以你必须熟悉 C 的语法才能用 C++ 编程，就像你必须熟练掌握代数才能处理微积分一样。

如果你以前没见过 C，这一章会以 C++ 中使用的 C 的风格给你一个像样的背景。如果你熟悉 Kernighan 和 Ritchie 描述的 C 风格(通常称为 K & R C ),你会在 C++ 和标准 C 中发现一些新的和不同的特性。如果你熟悉标准 C，你应该浏览本章寻找 C++ 特有的特性。请注意，这里介绍了一些基本的 C++ 特性，它们是类似于 C 中特性的基本思想，或者通常是对 C 做事方式的修改。更复杂的 C++ 特性将在后面的章节中介绍。

本章快速介绍了 C 结构，并介绍了一些基本的 C++ 结构，前提是你已经有了用另一种语言编程的经验。这一章基本上涵盖了 C++ 的特性，这些特性确定了 c++ 的相似之处。

创建函数

在旧的(标准之前的)C 中，你可以用任意数量或类型的参数调用一个函数，编译器不会抱怨。在你运行这个程序之前，一切看起来都很好。你得到了神秘的结果(*或者更糟的*，*程序崩溃了*，没有任何原因的提示。缺少参数传递的帮助以及由此产生的难以理解的错误可能是 C 被称为“高级汇编语言”的一个原因。前标准 C 程序员只是适应了它。

标准 C 和 C++ 使用一个叫做*函数原型*的特性。使用函数原型，在声明和定义函数时，必须使用参数类型的描述。这个描述就是“原型”调用该函数时，编译器使用原型来确保传入了正确的参数，并且正确处理了返回值。如果程序员在调用函数时出错，编译器会捕捉到错误。

基本上，你在前一章已经学习了函数原型(没有这样命名)，因为 C++ 中函数声明的形式需要正确的原型。在函数原型中，参数列表包含必须传递给函数的参数类型以及参数的标识符(对于声明是可选的)。在声明、定义和函数调用中，参数的顺序和类型必须匹配。下面是一个声明中的函数原型示例:

```cpp
int translate(float x, float y, float z);
```

在函数原型中声明变量时，使用的形式与在普通变量定义中不同。就是不能说`float x, y, z`。您必须指出每个参数的*类型。在函数声明中，以下形式也是可接受的:*

```cpp
int translate(float, float, float);
```

因为当调用函数时，编译器除了检查类型之外什么也不做，所以当有人阅读代码时，为了清楚起见才包括标识符。

在函数定义中，名字是必需的，因为参数在函数内部被引用，比如:

```cpp
int translate(float x, float y, float z) {
  x = y = z;
  // ...
}
```

原来这条规则只适用于 C。在 C++ 中，一个参数在函数定义的参数列表中可能是未命名的。因为它是未命名的，所以当然不能在函数体中使用它。允许未命名的参数是为了给程序员一种在参数列表中保留空间的方法。无论是谁使用这个函数，都必须用正确的参数调用它。但是，创建该函数的人以后可以使用该参数，而不必修改调用该函数的代码。如果您保留列表中的参数名，也可以选择忽略列表中的参数，但是每次编译函数时，您都会收到一条恼人的警告消息，提示该值未被使用。如果删除该名称，警告将消失。

C 和 C++ 还有另外两种方法来声明参数列表。如果你有一个空的参数列表，你可以在 C++ 中将它声明为`func( )`,这告诉编译器实际上没有参数。你应该知道在 C++ 中这仅仅意味着一个空的参数列表。在 C 中，这意味着参数的数量不确定(这是 C 中的一个“漏洞”，因为它在这种情况下禁用了类型检查)。在 C 和 C++ 中，声明`func(void);`意味着一个空的参数列表。在这种情况下，`void`关键字的意思是“什么都没有”*(在指针*的情况下，它也可以表示“无类型”*，您将在本章后面看到)。*

参数列表的另一个选项出现在你不知道有多少个参数或者什么类型的参数的时候；这叫做*变量参数列表*。这个不确定的自变量列表用省略号(`...` ) *表示。*定义一个带有可变参数列表的函数比定义一个常规函数要复杂得多。如果(出于某种原因)您想要禁用函数原型的错误检查，您可以为具有固定参数集的函数使用可变参数列表。因此，您应该将变量参数列表的使用限制在 C 中，并避免在 C++ 中使用它们(您将会了解到，在 c++ 中有更好的替代方法)。

函数返回值

C++ 函数原型必须指定函数的返回值类型(在 C 语言中，如果省略返回值类型，它默认为`int`)。返回类型规范位于函数名之前。要指定不返回值，请使用`void`关键字。如果您试图从函数返回值，这将产生一个错误。下面是一些完整的功能原型:

```cpp
int f1(void);                       // Returns an int, takes no arguments
int f2();                           // Like f1() in C++ but not in Standard C!
float f3(float, int, char, double); // Returns a float
void f4(void);                      // Takes no arguments, returns nothing
```

要从函数返回值，可以使用`return`语句。`return`退出函数，回到函数调用后的点。如果`return`有一个参数，这个参数将成为函数的返回值。如果一个函数说它将返回一个特定的类型，那么每个`return`语句都必须返回那个类型。在一个函数定义中可以有多个`return`语句，如清单 3-1 所示。

***清单 3-1*** 。几个退货单

```cpp
//: C03:Return.cpp
// Use of "return"
#include <iostream>

using namespace std;

char cfunc(int i) {
  if(i == 0)
    return 'a';
  if(i == 1)
    return 'g';
  if(i == 5)
    return 'z';
  return 'c';
}

int main() {
  cout << "type an integer: ";
  int val;
  cin >> val;
  cout << cfunc(val) << endl;
} ///:∼
```

在`cfunc( )`中，评估为`true`的第一个`if`通过`return`语句退出函数。注意，函数声明不是必需的，因为函数定义在被用于`main( )`之前就出现了，所以编译器从函数定义中知道了它。

使用 C 函数库

用 C++ 编程时，本地 C 函数库中的所有函数都是可用的。在定义自己的函数之前，你应该好好看看函数库；很有可能有人已经为你解决了你的问题，并且可能对它进行了更多的思考和调试。

不过，需要注意的是:许多编译器包含了许多额外的函数，这些函数使生活变得更加简单，并且很容易使用，但是它们不是标准 C 库的一部分。如果你确定你永远不会想把应用程序转移到另一个平台上(*)，谁又能确定这一点呢*？)，继续吧—使用这些功能，让您的生活更轻松。如果您希望您的应用程序是可移植的，您应该限制自己使用标准的库函数。如果您必须执行特定于平台的活动，请尝试将代码隔离在一个地方，以便在移植到另一个平台时可以很容易地对其进行更改。在 C++ 中，特定于平台的活动通常封装在一个类中，这是理想的解决方案。

使用库函数的公式如下:首先，在您的编程参考中找到该函数(许多编程参考会按类别以及字母顺序对该函数进行索引)。函数的描述应该包括演示代码语法的部分。这一部分的顶部通常至少有一个`#include`行/指令，向您显示包含函数原型的头文件。在您的文件中复制这个`#include`行/指令，以便正确声明函数。现在，您可以按照它在语法部分出现的方式调用该函数。如果你犯了一个错误，编译器会通过比较你的函数调用和头文件中的函数原型来发现它，并告诉你你的错误。默认情况下，链接器会搜索标准库，所以您只需:包含头文件并调用函数。

与图书管理员一起创建自己的图书馆

您可以将自己的函数收集到一个库中。大多数编程包都有一个管理对象模块组的管理员。每个库管理器都有自己的命令，但是总的想法是这样的:如果你想创建一个库，创建一个头文件，包含你的库中所有函数的函数原型。将这个头文件放在预处理器的搜索路径中的某个地方，可以是本地目录(这样就可以被`include "header"`找到)或包含目录(这样就可以被`#include <header>`找到)。现在，将所有的对象模块连同完成的库的名称一起交给图书管理员(大多数图书管理员需要一个通用的扩展名，比如`.lib`或`.a`)。将完成的库放在其他库所在的位置，以便链接器可以找到它。当你使用你的库时，你必须在命令行中添加一些东西，这样链接器就知道在库中搜索你调用的函数。您必须在当地手册中找到所有细节，因为它们因系统而异。

控制执行

本节涵盖 C++ 中的执行控制语句。在读写 C 或 C++ 代码之前，您必须熟悉这些语句。

C++ 使用 C 的所有执行控制语句。其中包括`if-else`、`while`、`do-while`、`for`，以及一个名为`switch`的选择语句。C++ 也允许臭名昭著的`goto`，这在本书中会避免。

真假

所有条件语句都使用条件表达式的真或假来确定执行路径。条件表达式的一个例子是`A == B`。这使用了条件运算符`==`来查看变量`A`是否等价于变量`B.`，表达式产生一个布尔型`true`或`false`(这些只是 C++ 中的关键字；在 C 语言中，如果表达式的值为非零值，则表达式为“真”)。其他条件运算符有`>`、`<`、`>=`等。条件语句将在本章后面更全面地介绍。

使用 if-else

`if-else`语句可以有两种形式:有或者没有`else`。这两种形态分别是

```cpp
if(expression)
    statement
```

或者

```cpp
if(expression)
    statement
else
    statement
```

“表达式”评估为`true`或`false`。“语句”是指以分号结束的简单语句或复合语句，复合语句是用大括号括起来的一组简单语句。任何时候使用“陈述”这个词，它总是暗示这个陈述是简单的或复合的。注意，这个说法也可以是另一个`if`，所以可以串起来；参见清单 3-2 。

***清单 3-2*** 。使用 if 和 if-else

```cpp
//: C03:Ifthen.cpp
// Demonstration of if and if-else conditionals
#include <iostream>
using namespace std;

int main() {
  int i;
  cout << "type a number and 'Enter'" << endl;
  cin >> i;
  if(i > 5)
    cout << "It's greater than 5" << endl;
  else
    if(i < 5)
      cout << "It's less than 5 " << endl;
    else
      cout << "It's equal to 5 " << endl;

  cout << "type a number and 'Enter'" << endl;
  cin >> i;
  if(i < 10)
    if(i > 5)  // "if" is just another statement
      cout << "5 < i < 10" << endl;
    else
      cout << "i <= 5" << endl;
  else         // Matches "if(i < 10)"
    cout << "i >= 10" << endl;
} ///:∼
```

通常缩进控制流语句的主体，以便读者可以容易地确定它的开始和结束位置。

使用 while

您可以通过`while`、`do-while,`和`for`控制循环。重复一个语句，直到控制表达式的计算结果为`false`。`while`循环的形式是

```cpp
while(expression)
    statement
```

表达式在循环开始时计算一次，在语句的每一次迭代之前再计算一次。清单 3-3 中的代码会留在`while`循环的主体中，直到你输入密码或按下 Control-C 键

***清单 3-3*** 。使用 while

```cpp
//: C03:Guess.cpp
// Guess a number (demonstrates "while")
#include <iostream>
using namespace std;

int main() {
  int secret = 15;
  int guess = 0;
  // "!=" is the "not-equal" conditional:
  while(guess != secret) { // Compound statement
    cout << "guess the number: ";
    cin >> guess;
  }
  cout << "You guessed it!" << endl;
} ///:∼
```

`while`的条件表达式不限于简单的测试，如清单 3-3；只要能产生一个`true`或`false`结果，它就可以像你喜欢的那样复杂。您甚至会看到代码中没有循环体，只有一个分号，就像这样:

```cpp
while(/* Do a lot here */)
 ;
```

在这些情况下，程序员编写条件表达式不仅是为了执行测试，也是为了完成工作。

使用 do-while

`do-while`的形式是

```cpp
do
    statement
while(expression);
```

`do-while`不同于`while`,因为语句总是至少执行一次，即使表达式第一次计算结果为假。在常规的`while`中，如果条件第一次为假，语句永远不会执行。

如果在`Guess.cpp`中使用了`do-while`，如清单 3-4 所示，变量`guess`不需要初始虚拟值，因为它在被测试之前已经被`cin`语句初始化了。

***清单 3-4*** 。使用 do-while

```cpp
//: C03:Guess2.cpp
// The guess program using do-while
#include <iostream>
using namespace std;

int main() {
  int secret = 15;
  int guess;      // No initialization needed here
  do {
    cout << "guess the number: ";
    cin >> guess; // Initialization happens
  }   while(guess != secret);
  cout << "You got it!" << endl;
} ///:∼
```

出于某种原因，大多数程序员倾向于避免使用`do-while`，而只使用`while`。

用于

一个`for`循环在第一次迭代前执行初始化。然后，它执行条件测试，并在每次迭代结束时，执行某种形式的*步进*。`for`回路的形式是

```cpp
for(initialization; conditional; step)
 statement
```

任何表达式*初始化*、*条件、*或*步骤*可能为空。*初始化*代码在最开始执行一次。在每次迭代之前测试*条件*(如果它在开始时评估为 false，则该语句永远不会执行)。在每个循环结束时，执行该步骤。

正如你在清单 3-5 中看到的，`for`循环通常用于计数任务。

***清单 3-5*** 。用于

```cpp
//: C03:Charlist.cpp
// Display all the ASCII characters
// Demonstrates "for"

#include <iostream>

using namespace std;

int main() {
  for(int i = 0; i < 128; i = i + 1)
    if (i != 26)      // ANSI Terminal Clear screen
      cout << " value: " << i
           << " character: "
           << char(i) // Type conversion
           << endl;
} ///:∼
```

您可能会注意到，变量`i`是在使用它的地方定义的，而不是在由大括号`{`表示的块的开始处。这与传统的过程语言(包括 C)不同，传统的过程语言要求所有变量都在块的开始定义。这将在本章后面讨论。

中断和继续关键字

在任何循环结构`while`、`do-while,`或`for`的主体内部，您可以使用`break`和`continue`来控制循环的流程。`break`退出循环，不执行循环中的其余语句。`continue`停止当前迭代的执行，并返回到循环的起点，开始新的迭代。

作为`break`和`continue`的例子，清单 3-6 包含了一个非常简单的菜单系统。

***清单 3-6*** 。使用中断和继续关键字

```cpp
//: C03:Menu.cpp
// Simple menu program demonstrating
// the use of "break" and "continue"
#include <iostream>
using namespace std;

int main() {
  char c; // To hold response
  while(true) {
    cout << "MAIN MENU:" << endl;
    cout << "l: left, r: right, q: quit -> ";
    cin >> c;
    if(c == 'q')
      break; // Out of "while(1)"
    if(c == 'l') {
      cout << "LEFT MENU:" << endl;
      cout << "select a or b: ";
      cin >> c;
      if(c == 'a') {
        cout << "you chose 'a'" << endl;
        continue; // Back to main menu
      }
      if(c == 'b') {
        cout << "you chose 'b'" << endl;
        continue; // Back to main menu
      }
      else {
        cout << "you didn't choose a or b!"
             << endl;
        continue; // Back to main menu
      }
    }
    if(c == 'r') {
      cout << "RIGHT MENU:" << endl;
      cout << "select c or d: ";
      cin >> c;
      if(c == 'c') {
        cout << "you chose 'c'" << endl;
        continue; // Back to main menu
      }
      if(c == 'd') {
        cout << "you chose 'd'" << endl;
        continue; // Back to main menu
      }
      else {
        cout << "you didn't choose c or d!"
             << endl;
        continue; // Back to main menu
      }
    }
    cout << "you must type l or r or q!" << endl;
  }
  cout << "quitting menu..." << endl;
} ///:∼
```

如果用户在主菜单中选择“q”，则使用`break`关键字退出；否则程序会无限期地继续执行。在每个子菜单选择之后，`continue`关键字用于弹出回到`while`循环的开始。

`while(true)`语句相当于说“永远做这个循环”当用户键入“q”时，`break`语句允许您打破这个无限的 while 循环

使用开关

一个`switch`语句基于一个整数表达式的值从代码片段中进行选择。其形式是

```cpp
switch(selector) {
    case integral-value1 : statement; break;
    case integral-value2 : statement; break;
    case integral-value3 : statement; break;
    case integral-value4 : statement; break;
    case integral-value5 : statement; break;
    (...)
    default: statement;
}
```

*选择器*是产生整数值的表达式。`switch`将选择器的结果与每个*积分值*进行比较。如果找到匹配项，就会执行相应的语句(简单语句或复合语句)。如果不匹配，则执行`default`语句。

您会注意到在上面的定义中，每个`case`都以一个`break`结束，这导致执行跳转到`switch`体的末尾(结束`switch`的右括号)。这是构建`switch`语句的常规方式，但是`break`是可选的。如果它不见了，你的`case`会跳到它后面的一个；也就是说，下面的`case`语句的代码一直执行到遇到`break`为止。虽然您通常不希望出现这种行为，但是对于一个有经验的程序员来说，这是非常有用的。

`switch`语句是一种实现多路选择(即从多个不同的执行路径中进行选择)的干净方式，但是它需要一个在编译时计算整数值的选择器。例如，如果你想使用一个`string`对象作为选择器，它在`switch`语句中就不起作用。对于一个`string`选择器，你必须使用一系列的`if`语句并比较条件中的`string`。

清单 3-7 中的菜单例子提供了一个特别好的`switch`例子。

***清单 3-7*** 。使用开关

```cpp
//: C03:Menu2.cpp
// A menu using a switch statement
#include <iostream>

using namespace std;

int main() {
  bool quit = false;  // Flag for quitting
  while(quit == false) {
    cout << "Select a, b, c or q to quit: ";
    char response;
    cin >> response;
    switch(response) {
      case 'a' : cout << "you chose 'a'" << endl;
                 break;
      case 'b' : cout << "you chose 'b'" << endl;
                 break;
      case 'c' : cout << "you chose 'c'" << endl;
                 break;
      case 'q' : cout << "quitting menu" << endl;
                 quit = true;
                 break;
      default  : cout << "Please use a,b,c or q!"
                      << endl;
    }
  }
} ///:∼
```

`quit`标志是一个`bool`，是“Boolean”的缩写，这是一种只能在 C++ 中找到的类型。它只能有关键字值`true`或`false`。选择“q”会将`quit`标志设置为`true`。下一次评估选择器时，`quit == false`返回`false`，因此`while`的主体不会执行。

使用和误用 goto

在 C++ 中支持`goto`关键字，因为它存在于 C 中。使用`goto`通常被认为是糟糕的编程风格，大多数时候确实如此。每当你使用`goto`的时候，看看你的代码，看看是否有另外一种方法。在极少数情况下，你可能会发现`goto`可以解决一个用其他方法无法解决的问题，但还是要仔细考虑。清单 3-8 是一个可能成为可信候选人的例子。

***清单 3-8*** 。使用 goto

```cpp
//: C03:gotoKeyword.cpp
// The infamous goto is supported in C++
#include <iostream>
using namespace std;

int main() {
  long val = 0;
  for(int i = 1; i < 1000; i++) {
    for(int j = 1; j < 100; j += 10) {
      val = i * j;
      if(val > 47000)
        goto DOWN;
        // Break would only go to the outer 'for'
    }
  }
  DOWN: // A label
  cout << val << endl;
} ///:∼
```

另一种方法是设置一个在外部`for`循环中测试的布尔值，然后在内部 for 循环中执行一个`break`。然而，如果你有几个级别的`for`或`while`，这可能会变得尴尬。

递归

递归是一种有趣且有时有用的编程技术，通过它你可以调用你所在的函数。当然，如果这就是你所做的全部工作，你会一直调用你所在的函数，直到你耗尽内存，所以必须有一些方法来结束递归调用。在清单 3-9 中，这种触底是通过简单地说递归将只进行到`cat`超过“z”.来完成的

***清单 3-9*** 。使用递归

```cpp
//: C03:CatsInHats.cpp
// Simple demonstration of recursion
#include <iostream>
using namespace std;

void removeHat(char cat) {
  for(char c = 'A'; c < cat; c++)
    cout << "  ";
  if(cat <= 'Z') {
    cout << "cat " << cat << endl;
    removeHat(cat + 1); // Recursive call
  } else
    cout << "VOOM!!!" << endl;
}

int main() {
  removeHat('A');
} ///:∼
```

在`removeHat( )`中可以看到，只要`cat`小于“Z”，就会在 `removeHat( )`内从*调用`removeHat( )`，从而实现递归。每次调用`removeHat( )`时，它的参数都比当前的`cat`大 1，所以参数一直在增加。*

当评估某种任意复杂的问题时，经常使用递归，因为对于解决方案，你并不受限于特定的“大小”;函数可以一直递归，直到问题结束。

操作员简介

您可以将运算符视为一种特殊类型的函数(您将了解到 C++ 运算符重载正是以这种方式处理运算符)。一个运算符接受一个或多个参数并生成一个新值。参数的形式与普通的函数调用不同，但效果是一样的。

根据您以前的编程经验，您应该对目前使用的操作符相当熟悉。加法(`+`)、减法和一元减号(`-`)、乘法(`*`)、除法(`/`)和赋值(`=`)这些概念在任何编程语言中都具有本质上相同的含义。本章后面将列举全部运算符。

优先

运算符优先级定义了当存在多个不同的运算符时，表达式的求值顺序。C 和 C++ 有确定求值顺序的特定规则。最容易记住的是乘法和除法发生在加法和减法之前。之后，如果一个表达式对你来说是不透明的，它可能对任何阅读代码的人来说都是不透明的，所以你应该使用括号来明确求值的顺序。例如，

```cpp
A = X + Y - 2/2 + Z;
```

与带有特定括号组的相同语句有非常不同的含义，如

```cpp
A = X + (Y - 2)/(2 + Z);
```

(试着用 X = 1，Y = 2，Z = 3 来评估结果。)

自动递增和自动递减

C，因此也是 C++，充满了快捷方式。快捷方式可以使代码更容易键入，有时更难阅读。也许 C 语言的设计者认为，如果你的眼睛不必扫描那么大的印刷区域，理解一段复杂的代码会更容易。

两个比较好的快捷方式是自动递增和自动递减操作符。您经常使用这些来改变循环变量，这些变量控制循环执行的次数。

自动减量操作符是`--`，意思是“减少一个单位”自动递增运算符是`++`，意思是“增加一个单位”例如，如果`A`是一个`int`，那么`++A`就相当于(`A = A + 1`)。结果，自动递增和自动递减运算符产生变量的值。如果操作符出现在变量之前，(即`++A`)，则首先执行操作并产生结果值。如果运算符出现在变量之后(即`A++`)，则产生当前值，然后进行运算；参见清单 3-10 。

***清单 3-10*** 。自动递增和自动递减

```cpp
//: C03:AutoIncrement.cpp
// Shows use of auto-increment
// and auto-decrement operators.
#include <iostream>
using namespace std;

int main() {
  int i = 0;
  int j = 0;
  cout << ++i << endl; // Pre-increment
  cout << j++ << endl; // Post-increment
  cout << --i << endl; // Pre-decrement
  cout << j-- << endl; // Post decrement
} ///:∼
```

如果你一直对“C++”这个名字感到疑惑，现在你明白了。它暗示着“超越 c 的一步”

数据类型简介

*数据类型*定义了你在自己编写的程序中使用存储(*内存*)的方式。通过指定数据类型，你可以告诉编译器如何创建一个特定的存储，以及如何操作这个存储。

数据类型可以是内置的，也可以是抽象的。内置数据类型是编译器能够理解的类型，是直接连接到编译器的类型。在 C 和 C++ 中，内置数据的类型几乎是相同的。相比之下，用户定义的数据类型是您或其他程序员作为类创建的数据类型。这些通常被称为抽象数据类型。编译器知道如何在启动时处理内置类型；它通过读取包含类声明的头文件来“学习”如何处理抽象数据类型(您将在后面的章节中了解这一点)。

基本内置类型

内置类型的标准 C 规范(由 C++ 继承)并没有说明每个内置类型必须包含多少位。相反，它规定了内置类型必须能够容纳的最小和最大值。当机器基于二进制时，这个最大值可以直接转换成保存该值所需的最小位数。但是，如果机器使用二进制编码的十进制(BCD)来表示数字，那么机器中保存每种数据类型的最大数字所需的空间量将会不同。可以存储在各种数据类型中的最小值和最大值在系统头文件`limits.h`和`float.h`中定义(在 C++ 中，您通常会用`#include <climits>`和`<cfloat>`来代替)。

C 和 C++ 有四种基本的内置数据类型，这里描述的是基于二进制的机器。一个`char`用于字符存储，使用最少 8 位(1 字节)的存储，尽管它可能更大。一个`int`存储一个整数，最少使用 2 个字节的存储空间。`float`和`double`类型存储浮点数，通常是 IEEE 浮点格式。`float`是单精度浮点，`double`是双精度浮点。

如上所述，您可以在作用域中的任何地方定义变量，并且可以同时定义和初始化它们。清单 3-11 显示了如何使用四种基本数据类型定义变量。

***清单 3-11*** 。基本数据类型

```cpp
//: C03:Basic.cpp
// Defining the four basic data
// types in C and C++

int main() {
  // Definition without initialization:
  char protein;
  int carbohydrates;
  float fiber;
  double fat;
  // Simultaneous definition & initialization:
  char pizza = 'A', pop = 'Z';
  int dongdings = 100, twinkles = 150,
    heehos = 200;
  float chocolate = 3.14159;
  // Exponential notation:
  double fudge_ripple = 6e-4;
} ///:∼
```

程序的第一部分定义了四种基本数据类型的变量，但没有初始化它们。如果你没有初始化一个变量，标准说它的内容是未定义的(通常，这意味着它们包含垃圾)。程序的第二部分同时定义和初始化变量(如果可能，最好在定义时提供一个初始值)。注意常量 6e-4 中指数符号的使用，意思是“6 乘以 10 的负四次方”

使用 bool、true 和 false

在`bool`成为标准 C++ 的一部分之前，每个人都倾向于使用不同的技术来产生类似布尔的行为。这产生了可移植性问题，并可能引入微妙的错误。

标准 C++ `bool`类型可以有两种状态，由内置常量`true`(转换为整数 1)和`false`(转换为整数 0)表示。

三个名字都是关键词。此外，还改编了一些语言元素，如表 3-1 所示。

表 3-1 。C++(附加)语言元素

| 元素 | bool 的用法 |
| --- | --- |
| `&& &#124;&#124; !` | 接受 bool 参数并产生`bool`结果。 |
| `<><= >= == !=` | 产生`bool`结果。 |
| `if, for, while, do` | 条件表达式转换为`bool`值。 |
| `? :` | 第一个操作数转换为`bool`值。 |

因为有很多现有的代码使用一个`int`来表示一个标志，编译器将隐式地从一个`int`转换成一个`bool`(非零值将产生`true`，而零值将产生`false`)。理想情况下，编译器会给你一个警告，作为纠正这种情况的建议。

属于糟糕编程风格的一个习惯用法是使用`++`将标志设置为 true。这仍然是允许的，但是*已经废弃了*，这意味着在未来的某个时候，这将被视为非法。问题是，您正在进行从`bool`到`int`的隐式类型转换，增加值(可能超出了正常的 0 和 1 的`bool`值的范围)，然后再隐式转换回来。

指针(将在本章后面介绍)也会在必要时自动转换成`bool`。

使用说明符

说明符修改了基本内置类型的含义，并将它们扩展到一个更大的集合。有四个说明符:`long`、`short`、`signed`和`unsigned`。

`long`和`short`修改一个数据类型将保存的最大值和最小值。一辆普通的`int`至少要有一辆`short`那么大。整数类型的大小等级为`shortint`、`int`、`longint`。只要满足最小/最大值要求，所有尺寸都可以相同。例如，在 64 位字的机器上，所有的数据类型都可能是 64 位。

浮点数的大小层次是`float`、`double`和`longdouble`。“长浮”不是合法类型。没有`short`浮点数。

`signed`和`unsigned`说明符告诉编译器如何使用整数类型和字符的符号位(浮点数总是包含一个符号)。一个`unsigned`数不跟踪符号，因此有一个额外的位可用，所以它可以存储两倍于一个`signed`数所能存储的正数。`signed`是默认设置，只有`char`才有必要；`char`可能会也可能不会默认为`signed`。通过指定`signed char`，可以强制使用符号位。

清单 3-12 通过使用`sizeof`操作符显示了数据类型的大小，这将在本章后面介绍。

***清单 3-12*** 。使用说明符

```cpp
//: C03:Specify.cpp
// Demonstrates the use of specifiers
#include <iostream>
using namespace std;

int main() {
  char c;
  unsigned char cu;
  int i;
  unsigned int iu;
  short int is;
  short iis; // Same as short int
  unsigned short int isu;
  unsigned short iisu;
  long int il;
  long iil;  // Same as long int
  unsigned long int ilu;
  unsigned long iilu;
  float f;
  double d;
  long double ld;
  cout
    << "\n char = " << sizeof(c)
    << "\n unsigned char = " << sizeof(cu)
    << "\n int = " << sizeof(i)
    << "\n unsigned int = " << sizeof(iu)
    << "\n short = " << sizeof(is)
    << "\n unsigned short = " << sizeof(isu)
    << "\n long = " << sizeof(il)
    << "\n unsigned long = " << sizeof(ilu)
    << "\n float = " << sizeof(f)
    << "\n double = " << sizeof(d)
    << "\n long double = " << sizeof(ld)
    << endl;
} ///:∼
```

请注意，运行这个程序得到的结果可能会因机器/操作系统/编译器的不同而不同，因为(如前所述)唯一必须一致的是，每个不同的类型都包含标准中指定的最小值和最大值。

当你用`short`或`long`修改`int`时，关键字`int`是可选的，如上图所示。

指针简介

每当你运行一个程序，它首先被加载(通常从磁盘)到计算机的内存中。因此，程序的所有元素都位于内存的某个地方。存储器通常被布置成一系列连续的存储器位置；我们通常将这些位置称为 8 位*字节*，但实际上每个空间的大小取决于特定机器的架构，通常称为该机器的*字长*。每个空间都可以通过其*地址*与所有其他空间进行唯一区分。为了讨论的目的，让我们假设所有的机器都使用字节，这些字节有连续的地址，从零开始，一直到你的计算机有多少内存。

因为你的程序在运行时是存在内存中的，所以程序的每个元素都有一个地址。清单 3-13 是一个简单的程序。

***清单 3-13*** 。简单的程序

```cpp
//: C03:YourPets1.cpp
#include <iostream>
using namespace std;

int dog, cat, bird, fish;

void f(int pet) {
  cout << "pet id number: " << pet << endl;
}

int main() {
  int i, j, k;
} ///:∼
```

当程序运行时，程序中的每个元素在存储器中都有一个位置。甚至函数也占用存储。正如您将看到的，原来元素是什么以及您定义它的方式通常决定了该元素所在的内存区域。

在 C 和 C++ 中有一个运算符会告诉你一个元素的地址。这是`&`运算符。您所做的就是在标识符名称前面加上`&`，它将产生该标识符的地址。`YourPets1.cpp`可以被修改以打印出其所有元素的地址，如清单 3-14 所示。

***清单 3-14*** 。修改程序

```cpp
//: C03:YourPets2.cpp
#include <iostream>
using namespace std;

int dog, cat, bird, fish;

void f(int pet) {
  cout << "pet id number: " << pet << endl;
}

int main() {
  int i, j, k;
  cout << "f(): " << (long)&f << endl;
  cout << "dog: " << (long)&dog << endl;
  cout << "cat: " << (long)&cat << endl;
  cout << "bird: " << (long)&bird << endl;
  cout << "fish: " << (long)&fish << endl;
  cout << "i: " << (long)&i << endl;
  cout << "j: " << (long)&j << endl;
  cout << "k: " << (long)&k << endl;
} ///:∼
```

这个`(long)`是一个*剧组的*。上面写着“不要把这个当成正常类型；而是把它当成一个`long`。”这种转换并不重要，但是如果不存在，地址就会以十六进制形式打印出来，所以转换为`long`使得可读性更好一些。

这个程序的结果会因你的电脑、操作系统和其他各种因素而有所不同，但它总会给你一些有趣的见解。在我的电脑上运行一次，结果如下:

```cpp
f(): 4198736
dog: 4323632
cat: 4323636
bird: 4323640
fish: 4323644
i: 6684160
j: 6684156
k: 6684152
```

您可以看到在`main( )`内部定义的变量与在`main( )`外部定义的变量位于不同的区域；随着你对这门语言了解的越来越多，你就会明白为什么了。还有，`f( )`似乎是在它自己的地区；在内存中，代码通常与数据分离。

另一个值得注意的有趣的事情是，一个接一个定义的变量在内存中是连续放置的。它们由数据类型所需的字节数分隔。这里唯一使用的数据类型是`int`，并且`cat`距离`dog`4 个字节，`bird`距离`cat`4 个字节，以此类推。因此，在这台机器上，`int`似乎有 4 个字节长。

除了这个有趣的实验展示了记忆是如何映射出来的，你还能用地址做什么呢？您可以做的最重要的事情是将它存储在另一个变量中以备后用。C 和 C++ 有一种特殊类型的变量来保存地址。这个变量叫做*指针*。

定义指针的操作符和用于乘法的操作符是一样的:`*`。编译器知道它不是乘法，因为它在上下文中被使用，你会看到。

定义指针时，必须指定它所指向的变量的类型。首先给出类型名，然后不是立即给出变量的标识符，而是在类型和标识符之间插入一个星号，说“等等，这是一个指针”。所以一个指向`int`的指针看起来像这样:

```cpp
int* ip; // ip points to an int variable
```

`*`与类型的关联看起来很合理，也很容易阅读，但实际上可能有点欺骗性。你可能倾向于说“intpointer ”,好像它是一个单独的离散类型。然而，对于`int`或其他基本数据类型，可以说

```cpp
int a, b, c;
```

而对于指针，你会*喜欢*说

```cpp
int* ipa, ipb, ipc;
```

C 语法(通过继承，C++ 语法)不允许这样明智的表达式。在上面的定义中，只有`ipa`是指针，而`ipb`和`ipc`是普通的`int`(你可以说“* *与标识符*绑定得更紧)。因此，每行只使用一个定义可以获得最佳结果；您仍然可以获得合理的语法而不会产生混淆，就像这样:

```cpp
int* ipa;
int* ipb;
int* ipc;
```

由于 C++ 编程的一般准则是您应该总是在定义时初始化变量，所以这种形式实际上效果更好。例如，上面的变量没有被初始化为任何特定的值；他们装垃圾。这样说要好得多

```cpp
int a = 47;
int* ipa = &a;
```

现在`a`和`ipa`都已经初始化，`ipa`保存着`a`的地址。

一旦你有了一个初始化的指针，你能用它做的最基本的事情就是用它来修改它所指向的值。要通过一个指针访问一个变量，你需要使用定义它的操作符来解引用这个指针，比如:

```cpp
*ipa = 100;
```

现在`a`包含的值是 100 而不是 47。

这些是指针的基础:你可以保存一个地址，你可以用这个地址来修改原始变量。但是问题仍然存在:为什么要用一个变量作为代理来修改另一个变量呢？

对于指针的这个介绍性观点，我可以将答案分为两大类:

1.  从函数内部改变“外部对象”。这可能是指针最基本的用法，我们将在这里对其进行研究。
2.  来实现许多其他聪明的编程技术，您将在本书的其余部分了解这些技术。

修改外部对象

通常，当您将一个参数传递给一个函数时，会在函数内部创建该参数的副本。这被称为*按值传递*。您可以在清单 3-15 中看到按值传递的效果。

***清单 3-15*** 。按值传递

```cpp
//: C03:PassByValue.cpp
#include <iostream>

using namespace std;

void f(int a) {
  cout << "a = " << a << endl;
  a = 5;
  cout << "a = " << a << endl;
}

int main() {
  int x = 47;
  cout << "x = " << x << endl;
  f(x);
  cout << "x = " << x << endl;
} ///:∼
```

在`f( )`中，`a`是一个*局部变量*，所以它只在对`f( )`的函数调用期间存在。因为是函数参数，`a`的值由调用函数时传递的参数初始化；在`main( )`中，参数是值为 47 的`x,`，所以当调用`f( )`时，这个值被复制到`a`中。

当你运行这个程序时，你会看到

```cpp
x = 47
a = 47
a = 5
x = 47
```

当然，`x`最初是 47。当调用`f( )`时，会创建临时空间来保存函数调用期间的变量`a`，并通过复制`x`的值来初始化`a`，通过打印输出来验证。当然，你可以改变`a`的值，显示它被改变了。但是当`f( )`完成时，为`a`创建的临时空间消失了，您会看到`a`和`x`之间曾经存在的唯一连接发生在`x`的值被复制到`a`时。

当你在`f( )`内部时，`x`是*外部对象*(按照我的术语)，改变局部变量不会影响外部对象，这是很自然的，因为它们是存储中两个独立的位置。但是如果你*做*想修改外部对象呢？这就是指针派上用场的地方。从某种意义上说，指针是另一个变量的别名。因此，如果你将一个*指针*而不是一个普通的值传递给一个函数，你实际上是将一个别名传递给外部对象，使函数能够修改那个外部对象，如清单 3-16 所示。

***清单 3-16*** 。说明别名的传递

```cpp
//: C03:PassAddress.cpp
#include <iostream>
using namespace std;

void f(int* p) {
  cout << "p = " << p << endl;
  cout << "*p = " << *p << endl;

  *p = 5;
  cout << "p = " << p << endl;
}

int main() {
  int x = 47;
  cout << "x = " << x << endl;

  cout << "&x = " << &x << endl;
  f(&x);
  cout << "x = " << x << endl;
} ///:∼
```

现在`f( )`将一个指针作为参数，并在赋值过程中取消对该指针的引用，这将导致外部对象`x`被修改。输出是

```cpp
x = 47
&x = 0065FE00
p = 0065FE00
*p = 47
p = 0065FE00
x = 5
```

请注意，`p`中包含的值与`x`的地址相同；指针`p`确实指向了`x`。如果这还不够令人信服的话，当`p`被解引用来赋值 5 时，您会看到`x`的值现在也变成了 5。

因此，将指针传入函数将允许该函数修改外部对象。稍后您将看到指针的许多其他用途，但这无疑是最基本的，也可能是最常见的用途。

C++ 参考文献介绍

指针在 C 和 C++ 中的工作方式大致相同，但是 C++ 增加了一种将地址传递给函数的方法。这是*按引用传递*，它存在于其他几种编程语言中，所以它不是 C++ 的发明。

您最初对引用的理解可能是它们是不必要的，您可以编写所有没有引用的程序。一般来说，这是真的，除了几个重要的地方，你将在本书的后面了解到。稍后您还将了解更多关于引用的内容，但基本思想与上面的指针使用演示相同:您可以使用引用传递参数的地址。引用和指针的区别在于，从语法上来说，*调用接受引用的函数比调用接受指针的函数更干净(正是这种语法差异使得引用在某些情况下至关重要)。如果`PassAddress.cpp`被修改为使用引用，你可以在清单 3-17 中的`main( )`中看到函数调用的不同。*

***清单 3-17*** 。说明按引用传递

```cpp
//: C03:PassReference.cpp
#include <iostream>
using namespace std;

void f(int& r) {
  cout << "r = " << r << endl;
  cout << "&r = " <<&r << endl;

  r = 5;
  cout << "r = " << r << endl;
}

int main() {
  int x = 47;
  cout << "x = " << x << endl;

  cout << "&x = " << &x << endl;
  f(x); // Looks like pass-by-value,
        // is actually pass by reference
  cout << "x = " << x << endl;
} ///:∼
```

在`f( )`的参数列表中，不是说`int*`来传递指针，而是说`int&`来传递引用。在`f( )`中，如果你只说`r`(如果`r`是指针，就会产生地址)你就会得到*变量中的值* `r` *引用*。如果给`r`赋值，实际上就是给`r`引用的变量赋值。事实上，获取保存在`r`中的地址的唯一方法是使用`&`操作符。

在`main( )`中，你可以看到引用在对`f( )`的调用的语法中的关键作用，它只是`f(x)`。尽管这看起来像普通的传值，但引用的效果是它实际上接受地址并传入，而不是复制值。输出是

```cpp
x = 47
&x = 0065FE00
r = 47
&r = 0065FE00
r = 5
x = 5
```

所以你可以看到按引用传递允许一个函数修改外部对象，就像传递一个指针一样(你也可以观察到引用掩盖了一个地址正在被传递的事实；这将在本书的后面部分进行讨论)。因此，对于这个简单的介绍，您可以假设引用只是一种语法上不同的方式(有时被称为*语法糖*)来完成与指针相同的事情:允许函数改变外部对象。

作为修饰符的指针和引用

到目前为止，您已经看到了基本数据类型`char`、`int`、`float,`和`double`，以及说明符`signed`、`unsigned`、`short,`和`long`，这些说明符几乎可以与基本数据类型以任何组合使用。现在，您已经添加了与基本数据类型和说明符*、*正交的指针和引用，因此可能的组合增加了三倍；参见清单 3-18 。

***清单 3-18*** 。所有可能的组合

```cpp
//: C03:AllDefinitions.cpp
// All possible combinations of basic data types,
// specifiers, pointers and references
#include <iostream>
using namespace std;

void f1(char c, int i, float f, double d);
void f2(short int si, long int li, long double ld);
void f3(unsigned char uc, unsigned int ui,
  unsigned short int usi, unsigned long int uli);
void f4(char* cp, int* ip, float* fp, double* dp);
void f5(short int* sip, long int* lip,
  long double* ldp);
void f6(unsigned char* ucp, unsigned int* uip,
  unsigned short int* usip,
  unsigned long int* ulip);
void f7(char& cr, int& ir, float& fr, double& dr);
void f8(short int& sir, long int& lir,
  long double& ldr);
void f9(unsigned char& ucr, unsigned int& uir,
  unsigned short int& usir,
  unsigned long int& ulir);

int main() {} ///:∼
```

指针和引用在将对象传入和传出函数时也起作用；你将在后面的章节中了解到这一点。

还有一种类型可以使用指针:`void`。如果你声明一个指针是一个`void*`，这意味着任何类型的地址都可以分配给这个指针(然而如果你有一个`int*`，你只能分配一个`int`变量的地址给这个指针)。例如，参见清单 3-19 。

***清单 3-19*** 。空指针

```cpp
//: C03:VoidPointer.cpp

int main() {
  void* vp;
  char c;
  int i;
  float f;
  double d;
  // The address of ANY type can be
  // assigned to a void pointer:
  vp = &c;
  vp = &i;
  vp = &f;
  vp = &d;
} ///:∼
```

一旦你给一个`void*`赋值，你就失去了任何关于它是什么类型的信息。这意味着在你使用指针之前，你必须将它转换成正确的类型，如清单 3-20 所示。

***清单 3-20*** 。从空指针强制转换

```cpp
//: C03:CastFromVoidPointer.cpp
int main() {
  int i = 99;
  void* vp = &i;
  // Can't dereference a void pointer:
  // *vp = 3; // Compile time error
  // Must cast back to int before dereferencing:
  *((int*)vp) = 3;
} ///:∼
```

强制转换`(int*)vp`接受`void*`并告诉编译器把它当作一个`int*`，这样就可以成功地取消引用。您可能会注意到这种语法很难看，的确如此，但比这更糟糕的是—`void*`在语言的类型系统中引入了一个漏洞。也就是说，它允许甚至促进将一种类型作为另一种类型对待。在清单 3-19 中，通过将`vp`强制转换为`int*`，一个`int`被视为一个`int`，但是没有说它不能被强制转换为`char*`或`double*`，这将修改已经为`int`分配的不同数量的存储，可能会使程序崩溃。一般来说，应该避免使用`void`指针，并且只在极少数特殊情况下使用，像这样的情况直到本书的后面部分才会考虑。

你不能有一个`void`参考，原因将在第十一章中解释。

理解范围

作用域规则告诉你变量在哪里有效，在哪里被创建，在哪里被销毁(即超出作用域)。变量的范围从定义该变量的位置延伸到定义该变量之前与最近的左大括号匹配的第一个右大括号。也就是说，作用域是由其“最近的”一组大括号定义的。清单 3-21 说明了这一点。

***清单 3-21*** 。辖域

```cpp
//: C03:Scope.cpp
// How variables are scoped
int main() {
  int scp1;
  // scp1 visible here
  {
    // scp1 still visible here
    //.....
    int scp2;
    // scp2 visible here
    //.....
    {
      // scp1 & scp2 still visible here
      //..
      int scp3;
      // scp1, scp2 & scp3 visible here
      // ...
    } // <-- scp3 destroyed here
    // scp3 not available here
    // scp1 & scp2 still visible here
    // ...
  } // <-- scp2 destroyed here
  // scp3 & scp2 not available here
  // scp1 still visible here
  //..
} // <-- scp1 destroyed here
///:∼
```

代码显示了变量何时可见，何时不可用(也就是说，当它们*超出范围*)。变量只能在其作用域内使用。范围可以嵌套，由匹配的大括号对在其他匹配的大括号对内表示。嵌套意味着您可以在包围您所在作用域的作用域中访问变量。在清单 3-21 中，变量`scp1`在所有其他作用域中都可用，而`scp3`只在最里面的作用域可用。

动态定义变量

正如本章前面提到的，C 和 C++ 在定义变量时有很大的不同。这两种语言都要求在使用变量之前定义它们，但是 C(和许多其他传统的过程语言)强迫你在一个作用域的开始定义所有的变量，这样当编译器创建一个块时，它可以为这些变量分配空间。

阅读 C 代码时，当进入作用域时，通常首先看到的是一组变量定义。由于语言的实现细节，在块的开始声明所有变量需要程序员以特定的方式编写。大多数人在编写代码之前并不知道他们将要使用的所有变量，所以他们必须不断地跳回到代码块的开头来插入新的变量，这很笨拙，并且会导致错误。这些变量定义通常对读者来说意义不大，而且它们实际上容易让人混淆，因为它们出现在使用它们的上下文之外。

C++(但是*不是* C)允许你在作用域的任何地方定义变量，所以你可以在使用变量之前定义它。此外，您可以在定义变量时对其进行初始化，这可以防止某类错误。以这种方式定义变量使代码更容易编写，并减少了被迫在一个范围内来回跳转所导致的错误。它使代码更容易理解，因为您看到的是在其使用上下文中定义的变量。当您同时定义和初始化一个变量时，这一点尤其重要——您可以通过变量的使用方式来了解初始化值的含义。

您还可以在`for`循环和`while`循环的控制表达式内、在`if`语句的条件内以及在`switch`的选择器语句内定义变量。清单 3-22 显示了动态变量定义。

***清单 3-22*** 。动态变量定义

```cpp
//: C03:OnTheFly.cpp
// On-the-fly variable definitions
#include <iostream>
using namespace std;

int main() {
  //..
  { // Begin a new scope
    int q = 0; // C requires definitions here
    //..
    // Define at point of use:
    for(int i = 0; i < 100; i++) {
      q++;     // q comes from a larger scope
      // Definition at the end of the scope:
      int p = 12;
    }
    int p = 1;  // A different p
  } // End scope containing q & outer p
  cout << "Type characters:" << endl;
  while(char c = cin.get() != 'q') {
    cout << c << " wasn't it" << endl;
    if(char x = c == 'a' || c == 'b')
      cout << "You typed a or b" << endl;
    else
      cout << "You typed " << x << endl;
  }
  cout << "Type A, B, or C" << endl;
  switch(int i = cin.get()) {
    case 'A': cout << "Snap" << endl; break;
    case 'B': cout << "Crackle" << endl; break;
    case 'C': cout << "Pop" << endl; break;
    default: cout << "Not A, B or C!" << endl;
  }
} ///:∼
```

在最里面的作用域中，`p`是在作用域结束之前定义的，所以这确实是一个无用的手势(*但是它表明你可以在任何地方定义变量*)。外作用域的`p`也是同样的情况。

在`for`循环的控制表达式中对`i`的定义就是一个例子，它能够在你需要的时候准确地定义变量*(只有在 C++ 中才能做到这一点)。`i`的范围是由`for`循环控制的表达式的范围，所以你可以在下一个`for`循环中调转方向重用`i`。这是 C++ 中一个方便且常用的习惯用法；`i`是循环计数器的经典名称，您不必不断发明新名称。*

 *虽然这个例子也显示了在`while`、`if,`和`switch`语句中定义的变量，但是这种定义比`for`表达式中的定义要少得多，这可能是因为语法受到了很大的限制。例如，不能有任何括号。也就是说，你不能说

```cpp
while((char c = cin.get()) != 'q')
```

添加额外的括号似乎是一件无辜而有用的事情，因为您不能使用它们，所以结果可能不是您想要的。问题的出现是因为`!=`比`=`具有更高的优先级，所以`charc`最终包含一个被转换为`char`的`bool`。打印出来后，在许多终端上你会看到一个笑脸字符。

一般来说，您可以考虑在`while`、`if`和`switch`语句中定义变量的能力，这是为了完整性，但是您可能使用这种变量定义的唯一地方是在`for`循环中(您会经常使用它)。

指定存储分配

创建变量时，您有许多选项来指定变量的生存期、如何为该变量分配存储以及编译器如何处理该变量。

全局变量

全局变量在所有函数体之外定义，可用于程序的所有部分(甚至是其他文件中的代码)。全局变量不受作用域的影响，并且总是可用的(例如，全局变量的生存期一直持续到程序结束)。如果一个文件中全局变量的存在是在另一个文件中使用`extern`关键字声明的，那么该数据可供第二个文件使用。清单 3-23 是使用全局变量的一个例子。

***清单 3-23*** 。使用全局变量

```cpp
//: C03:Global.cpp
//{L} Global2
// Demonstration of global variables
#include <iostream>
using namespace std;

int globe;
void func();
int main() {
  globe = 12;
  cout << globe << endl;
  func(); // Modifies globe
  cout << globe << endl;
} ///:∼
```

清单 3-24 访问`globe`作为`extern`。

***清单 3-24*** 。访问全局变量

```cpp
//: C03:Global2.cpp {O}
// Accessing external global variables
extern int globe;
// (The linker resolves the reference)
void func() {
  globe = 47;
} ///:∼
```

变量`globe`的存储由`Global.cpp` ( 清单 3-23 )中的定义创建，同一变量由`Global2.cpp` ( 清单 3-24 )中的代码访问。由于`Global2.cpp`中的代码与`Global.cpp`中的代码是分开编译的，编译器必须通过声明得知变量存在于别处

```cpp
extern int globe;
```

当您运行程序时，您会看到对`func( )`的调用确实影响了`globe`的单个全局实例。

在`Global.cpp`中，你可以看到特殊的注释标签

```cpp
//{L} Global2
```

这意味着要创建最终的程序，必须链接名为`Global2`的目标文件(没有扩展名，因为不同系统的目标文件的扩展名不同)。在`Global2.cpp`中，第一行有另一个特殊的注释标签`{O},`，上面写着:“不要试图用这个文件创建可执行文件；它正在被编译，以便可以链接到其他可执行文件中。”

局部变量

局部变量出现在一个范围内；它们对于一个功能来说是“局部的”。它们通常被称为*自动*变量，因为它们在作用域进入时自动产生，在作用域关闭时自动消失。关键字`auto`使这变得显式，但是局部变量默认为`auto`，所以没有必要将某个东西声明为`auto`。

寄存器变量

寄存器变量是一种局部变量。关键字`register`告诉编译器尽可能快地访问这个变量。提高访问速度取决于具体实现，但是，顾名思义，这通常是通过将变量放入寄存器中来实现的。不保证变量会被放入寄存器中，甚至不保证访问速度会提高。这是对编译器的一个提示。

使用`register`变量有限制。您不能获取或计算`register`变量的地址。一个`register`变量只能在一个块中声明(不能有全局或`staticregister`变量)。然而，你可以使用一个`register`变量作为函数中的形式参数(例如，在参数列表中)。

一般来说，你不应该去猜测编译器的优化器，因为它可能比你做得更好。因此，最好避免使用`register`关键字。

静态关键字

关键字`static`有几个不同的含义。通常，被定义为函数局部变量的变量会在函数作用域结束时消失。当您再次调用该函数时，将重新创建变量的存储，并重新初始化这些值。如果你想让一个值在程序的整个生命周期中都存在，你可以定义一个函数的局部变量为`static`并给它一个初始值。仅在第一次调用函数时执行初始化，并且数据在函数调用之间保留其值。这样，函数可以在函数调用之间“记住”一些信息。

你可能想知道为什么不用全局变量来代替。一个`static`变量的美妙之处在于，它在函数范围之外是不可用的，所以它不可能被无意中改变。这使错误本地化。清单 3-25 显示了`static`变量的使用。

***清单 3-25*** 。静态变量

```cpp
//: C03:Static.cpp
// Using a static variable in a function
#include <iostream>
using namespace std;

void func() {
  static int i = 0;
  cout << "i = " << ++i << endl;
}

int main() {
  for(int x = 0; x < 10; x++)
    func();
} ///:∼
```

每次在 for 循环中调用`func`()时，它都会打印不同的值。如果不使用关键字`static`，打印的值将总是 1。

`static`的第二个意义与第一个意义相关，即“在一定范围之外不可用”。当`static`被应用于一个函数名或者一个在所有函数之外的变量时，这意味着“这个名字在这个文件之外是不可用的。”函数名或变量是文件的本地变量；我们说它有*文件范围*。作为示范，编译和链接清单 3-26 和清单 3-27 将导致链接器错误。

***清单 3-26*** 。文件范围演示

```cpp
//: C03:FileStatic.cpp
// File scope demonstration. Compiling and
// linking this file with FileStatic2.cpp
// will cause a linker error

// File scope means only available in this file:
static int fs;

int main() {
  fs = 1;
} ///:∼
```

***清单 3-27*** 。更多的演示

```cpp
//: C03:FileStatic2.cpp {O}
// Trying to reference fs
extern int fs;
void func() {
  fs = 100;
} ///:∼
```

即使在清单 3-27 中声称变量`fs`作为`extern`存在，链接器也不会发现它，因为它已经在`FileStatic.cpp` ( 清单 3-26 )中声明了`static`。

`static`说明符也可以在`class`中使用。这个解释将被推迟到你学习创建类的时候，这将在本书的后面发生。

extern 关键字

关键字`extern`已经被简单地描述和演示过了。它告诉编译器一个变量或函数存在，即使编译器还没有在当前编译的文件中看到它。这个变量或函数可以在另一个文件中定义，也可以在当前文件中定义。作为后者的一个例子，参见清单 3-28 。

***清单 3-28*** 。extern 关键字

```cpp
//: C03:Forward.cpp
// Forward function & data declarations
#include <iostream>
using namespace std;

// This is not actually external, but the
// compiler must be told it exists somewhere:
extern int i;
extern void func();

int main() {
  i = 0;
  func();
}
int i; // The data definition
void func() {
  i++;
  cout << i;
} ///:∼
```

当编译器遇到声明`extern int i`时，它知道`i`的定义必须作为全局变量存在于某个地方。当编译器到达`i`的定义时，看不到其他声明，所以它知道已经在文件中找到了前面声明的同一个`i`。如果你将`i`定义为`static`，你会告诉编译器`I`是全局定义的(通过`extern`)，但是它也有文件范围(通过`static`)，所以编译器会产生一个错误。

联动装置

要理解 C 和 C++ 程序的行为，你需要了解*链接*。在一个正在执行的程序中，一个标识符由保存一个变量或一个编译过的函数体的存储器来表示。链接描述了链接器所看到的这种存储。联动有两种:内部联动和外部联动。

*内部链接* 表示创建的存储只代表正在编译的文件的标识符。其他文件可能在内部链接中使用相同的标识符名称，或者对全局变量使用相同的标识符名称，链接器不会发现冲突——为每个标识符创建单独的存储。内部链接在 C 和 C++ 中由关键字`static`指定。

*外部链接* 意味着创建一个单独的存储来代表所有正在编译的文件的标识符。存储创建一次，链接器必须解析对该存储的所有其他引用。全局变量和函数名有外部链接。通过用关键字`extern`声明它们，可以从其他文件中访问它们。在所有函数(除了 C++ 中的`const`之外)和函数定义之外定义的变量默认为外部链接。你可以使用`static`关键字来强制他们进行内部链接。您可以通过用`extern`关键字定义一个标识符来明确声明它具有外部链接。用`extern`定义变量或函数在 C 中没有必要，但在 C++ 中对于`const`有时是必要的。

当函数被调用时，自动(局部)变量只是暂时存在于堆栈中。链接器不知道自动变量，所以这些变量没有链接。

常量

在旧的(标准之前的)C 中，如果你想做一个常量，你必须使用预处理器，就像这样:

```cpp
#define PI 3.14159
```

在所有使用`PI`的地方，值 3.14159 都被预处理器替换了(在 C 和 C++ 中仍然可以使用这个方法)。

当您使用预处理器创建常量时，您将这些常量的控制权置于编译器的范围之外。对名字`PI`不执行类型检查，并且不能获取`PI`的地址(因此不能传递指向`PI`的指针或引用)。`PI`不能是用户自定义类型的变量。`PI`的含义从它被定义的点持续到文件的结尾；预处理器无法识别作用域。

C++ 引入了命名常量的概念，它就像一个变量，只是它的值不能改变。修饰符`const`告诉编译器一个名字代表一个常量。任何数据类型，无论是内置的还是用户定义的，都可以定义为`const`。如果您将某个东西定义为`const`，然后试图修改它，编译器将会产生一个错误。

您必须指定一个`const`的类型，如下所示:

```cpp
const int x = 10;
```

在标准 C 和 C++ 中，您可以在参数列表中使用一个命名的常量，即使它填充的参数是一个指针或引用(也就是说，您可以使用一个`const`的地址)。一个`const`有一个作用域，就像一个常规变量一样，所以你可以在一个函数中“隐藏”一个`const`,并确保这个名字不会影响程序的其余部分。

`const`取自 C++ 并被合并到标准 C 中，尽管差别很大。在 C 语言中，编译器对待`const`就像一个附加了特殊标签的变量，标签上写着“不要改变我”当你在 C 中定义一个`const`时，编译器会为它创建存储，所以如果你在两个不同的文件中定义了不止一个同名的`const`(或者把定义放在头文件中)，链接器会生成关于冲突的错误消息。`const`在 C 中的预期用途与其在 C++ 中的预期用途大相径庭(简而言之，*在 C++ 中更好用*)。

常量值

在 C++ 中，一个`const`必须总是有一个初始化值(在 C 中，这不是真的)。内置类型的常量值可以表示为十进制、八进制、十六进制或浮点数(遗憾的是，二进制数并不重要)，或者表示为字符。

在没有任何其他线索的情况下，编译器假定一个常量值是一个十进制数。数字 47、0 和 1101 都被视为十进制数。

带有前导 0 的常量值被视为八进制数(基数为 8)。基数为 8 的数字只能包含数字 0-7；编译器将其他数字标记为错误。合法的八进制数是 017(以 10 为基数的 15)。

以 0x 开头的常量值被视为十六进制数(基数为 16)。以 16 为基数的数字包含数字 0–9 和 A–f 或 A–f，合法的十六进制数是 0x1fe(以 10 为基数的 510)。

浮点数可以包含小数点和指数幂(用 e 表示，意思是“10 的幂”)。小数点和`e`都是可选的。如果你把一个常量赋给一个浮点变量，编译器会把这个常量值转换成一个浮点数(这个过程是所谓的*隐式类型转换* 的一种形式)。然而，使用小数点或`e`来提醒读者您正在使用浮点数是一个好主意；一些较老的编译器也需要提示。

合法的浮点常量值是 1e4、1.0001、47.0、0.0 和-1.159e-77。可以添加后缀强制浮点数的类型:`f`或`F`强制一个`float`，`L`或`l`强制一个`longdouble`；否则号码将是一个`double`。

字符常量是用单引号括起来的字符，如:'`A`'、'`0`'、'。注意字符'??'(ASCII 96)和值`0`之间有很大的区别。特殊字符用反斜杠转义表示:'`\n`'(换行符)、'`\t`'(制表符)、'`\\`'(反斜杠)、'`\r`'(回车)、'`\"`'(双引号)、'`\'`'(单引号)等。也可以用八进制:'`\17`'或十六进制:'??'来表示字符常量。

易变限定符

限定符`const`告诉编译器“这永远不会改变”(这允许编译器执行额外的优化)，而限定符`volatile`告诉编译器“你永远不知道这何时会改变”，并阻止编译器基于该变量的稳定性执行任何优化。当您读取代码控制范围之外的一些值时，使用这个关键字，例如一个通信硬件中的寄存器。一个`volatile`变量总是在需要它的值的时候被读取，即使它刚刚被读取了一行。

一些存储“在你的代码控制之外”的特殊情况是在多线程程序中。如果你正在观察一个被另一个线程或进程修改的特殊标志，那么这个标志应该是`volatile`，这样编译器就不会假设它可以优化掉这个标志的多次读取。

注意，当编译器没有优化时，`volatile`可能没有任何效果，但当您开始优化代码时(此时编译器将开始寻找冗余读取)，它可能会防止严重的错误。

`const`和`volatile`关键字将在后面的章节中进一步阐述。

运算符 及其用法

本节涵盖了 C 和 C++ 中的所有运算符。所有运算符都从其操作数中产生一个值。除了使用赋值、递增和递减运算符之外，不需要修改操作数就可以生成该值。修改一个操作数叫做*副作用*。修改操作数的运算符最常见的用途是产生副作用，但您应该记住，产生的值可供您使用，就像在没有副作用的运算符中一样。

分配

使用操作员`=`进行分配。它的意思是“把右边(通常称为右值)复制到左边(通常称为左值)。”右值是可以产生值的任何常量、变量或表达式，但左值必须是不同的命名变量(也就是说，必须有存储数据的物理空间)。例如，你可以给一个变量赋值一个常量值(`A = 4;`)，但是你不能给常量值赋值——它不能是一个左值(你不能说`4 = A;`)。

数学运算符

基本的数学运算符与大多数编程语言中的运算符相同:加法(`+`)、减法(`-`)、除法(`/`)、乘法(`*`)和模数(`%`)；这产生整数除法的余数)。整数除法会截断结果(不会舍入)。模数运算符不能用于浮点数。

C 和 C++ 也使用简写符号来同时执行一个操作和一个赋值。这由等号后面的运算符表示，并且与语言中的所有运算符一致(只要有意义)。例如，给变量`x`加 4，给结果赋值`x`，你说:`x += 4;`。

清单 3-29 展示了数学运算符的使用。

***清单 3-29*** 。使用数学运算符

```cpp
//: C03:Mathops.cpp
// Mathematical operators
#include <iostream>
using namespace std;

// A macro to display a string and a value.
#define PRINT(STR, VAR) \
  cout << STR " = " << VAR << endl

int main() {
  int i, j, k;
  float u, v, w;  // Applies to doubles, too
  cout << "enter an integer: ";
  cin >> j;
  cout << "enter another integer: ";
  cin >> k;
  PRINT("j",j);  PRINT("k",k);
  i = j + k; PRINT("j + k",i);
  i = j - k; PRINT("j - k",i);
  i = k / j; PRINT("k / j",i);
  i = k * j; PRINT("k * j",i);
  i = k % j; PRINT("k % j",i);
  // The following only works with integers:
  j %= k; PRINT("j %= k", j);
  cout << "Enter a floating-point number: ";
  cin >> v;
  cout << "Enter another floating-point number:";
  cin >> w;
  PRINT("v",v); PRINT("w",w);
  u = v + w; PRINT("v + w", u);
  u = v - w; PRINT("v - w", u);
  u = v * w; PRINT("v * w", u);
  u = v / w; PRINT("v / w", u);
  // The following works for ints, chars,
  // and doubles too:
  PRINT("u", u); PRINT("v", v);
  u += v; PRINT("u += v", u);
  u -= v; PRINT("u -= v", u);
  u *= v; PRINT("u *= v", u);
  u /= v; PRINT("u /= v", u);
} ///:∼
```

当然，所有赋值的值可以更复杂。

预处理宏简介

注意使用宏`PRINT( )`来保存输入(*和输入错误*！).预处理宏通常都用大写字母来命名，以便突出。稍后您将了解到，宏可能很快变得危险(它们也可能非常有用)。

宏名后面的括号列表中的参数在右括号后面的所有代码中都被替换。预处理器删除名称`PRINT`并在调用宏的地方替换代码，因此编译器不会使用宏名生成任何错误消息，也不会对参数进行任何类型检查。

![image](img/sq.jpg) **注意**后者可能是有益的，详见本章末尾的调试宏。

关系运算符

关系运算符在操作数的值之间建立关系。如果关系为真，它们产生一个布尔值(在 C++ 中用关键字`bool`指定)`true`，如果关系为假，则产生`false`。关系运算符有小于(`<`)、大于(`>`)、小于或等于(`<=`)、大于或等于(`>=`)、等价(`==`)和不等价(`!=`)。它们可以用于 C 和 C++ 中的所有内置数据类型。在 C++ 中，它们可能被赋予用户定义数据类型的特殊定义。

![image](img/sq.jpg) **注意**你会在第十二章的中了解到这一点，其中涵盖了操作符重载。

逻辑运算符

逻辑运算符*和* ( `&&`)和*或* ( `||`)根据其参数的逻辑关系产生一个`true`或`false`。请记住，在 C 和 C++ 中，如果一个语句有非零值，则该语句为`true`，如果该语句的值为零，则该语句为`false`。如果你打印一个`bool`，你通常会看到一个`1`代表`true`，一个`0`代表`false`。

清单 3-30 使用了关系和逻辑运算符。

***清单 3-30*** 。使用关系和逻辑运算符

```cpp
//: C03:Boolean.cpp
// Relational and logical operators.
#include <iostream>
using namespace std;

int main() {
  int i,j;
  cout << "Enter an integer: ";
  cin >> i;
  cout << "Enter another integer: ";
  cin >> j;
  cout << "i > j is " << (i > j) << endl;
  cout << "i < j is " << (i < j) << endl;

  cout << "i >= j is " << (i >= j) << endl;
  cout << "i <= j is " << (i <= j) << endl;
  cout << "i == j is " << (i == j) << endl;

  cout << "i != j is " << (i != j) << endl;
  cout << "i && j is " << (i && j) << endl;
  cout << "i || j is " << (i || j) << endl;

  cout << " (i < 10) && (j < 10) is "
<< ((i < 10) && (j < 10))  << endl;
} ///:∼
```

您可以在清单 3-30 中用`float`或`double`替换`int`的定义。但是，请注意，浮点数与零值的比较是严格的；一个数与另一个数相差极小，仍然是“不相等”比零大一点点的浮点数仍然是正确的。

按位运算符

按位运算符允许您操作数字中的单个位(因为浮点值使用特殊的内部格式，所以按位运算符仅适用于整数类型:`char`、`int`和`long`)。按位运算符对参数中的相应位执行布尔代数运算以产生结果。

如果两个输入位都是 1，按位*和*运算符(`&`)在输出位产生 1；否则它产生一个零。如果任一输入位为 1，按位*或*运算符(`|`)在输出位产生 1，只有当两个输入位都为 0 时才产生 0。如果一个或另一个输入位是 1，按位*异或*或*异或* ( `^`)在输出位产生 1，但不是两个都是 1。按位*非* ( `∼`，也叫*一补码*运算符)是一元运算符；它只接受一个参数(所有其他按位运算符都是二元运算符)。按位*而非*产生与输入位相反的值——如果输入位为零，则为 1；如果输入位为 1，则为 0。

按位运算符可以与`=`符号结合，以统一运算和赋值:`&=`、`|=,`和`^=`都是合法的运算(因为`∼`是一元运算符，所以不能与`=`符号结合)。

移位运算符

移位操作符也操纵比特。左移运算符(`<<`)将运算符左边的操作数向左移动运算符后面指定的位数。右移运算符(`>>`)将运算符左边的操作数向右移动运算符后面指定的位数。如果移位运算符后的值大于左操作数中的位数，则结果是未定义的。如果左边的操作数是无符号的，那么右移位就是逻辑移位，所以高位将用零填充。如果左操作数有符号，右移位可能是也可能不是逻辑移位(即*，*行为未定义)。

移位可以与等号(`<<=`和`>>=`)结合使用。左值被右值移位后的左值代替。

清单 3-31 是一个例子，展示了所有涉及位的操作符的使用。首先，有一个通用函数以二进制格式打印一个字节，这个函数是单独创建的，因此可以很容易地重用。头文件声明了函数。

***清单 3-31*** 。所有涉及位的运算符

```cpp
//: C03:printBinary.h
// Display a byte in binary
void printBinary(const unsigned char val);
///:∼
//Here's the implementation of the function:
//: C03:printBinary.cpp {O}
#include <iostream>
void printBinary(const unsigned char val) {
  for(int i = 7; i >= 0; i--)
    if(val & (1 << i))
      std::cout << "1";
    else
      std::cout << "0";
} ///:∼
```

`printBinary( )`函数获取一个字节并逐位显示。

表情

```cpp
(1 << i)
```

在每个连续的比特位置产生一个 1；以二进制表示:00000001、00000010 等。如果该位与`val`进行逐位*和*运算，结果为非零，则意味着在`val`的该位置有一个 1。

最后，这个函数用在清单 3-32 中，它显示了位操作符。

***清单 3-32*** 。位操作运算符

```cpp
//: C03:Bitwise.cpp
//{L} printBinary
// Demonstration of bit manipulation
#include "printBinary.h"
#include <iostream>
using namespace std;

// A macro to save typing:
#define PR(STR, EXPR) \
  cout << STR; printBinary(EXPR); cout << endl;

int main() {
  unsigned int getval;
  unsigned char a, b;
  cout << "Enter a number between 0 and 255: ";
  cin >> getval; a = getval;
  PR("a in binary: ", a);
  cout << "Enter a number between 0 and 255: ";
  cin >> getval; b = getval;
  PR("b in binary: ", b);
  PR("a | b = ", a | b);
  PR("a & b = ", a & b);
  PR("a ^ b = ", a ^ b);
  PR("∼a = ", ∼a);
  PR("∼b = ", ∼b);
  // An interesting bit pattern:
  unsigned char c = 0x5A;
  PR("c in binary: ", c);
  a |= c;
  PR("a |= c; a = ", a);
  b &= c;
  PR("b &= c; b = ", b);
  b ^= a;
  PR("b ^= a; b = ", b);
} ///:∼
```

再一次，预处理宏被用来保存输入。它打印您选择的字符串，然后是表达式的二进制表示，然后是换行符。

在`main( )`中，变量是`unsigned`。这是因为，一般来说，当你处理字节时，你不想要符号。对于`getval`，必须使用`int`而不是`char`，因为`cin >>`语句会将第一个数字视为一个字符。通过将`getval`分配给`a`和`b`，该值被转换为单个字节(通过截断)。

`<<`和`>>`提供了位移位行为，但是当它们将位移出数字的末尾时，这些位就丢失了(通常说它们落入了神话中的*位桶*，一个被丢弃的位结束的地方，大概是为了它们可以被重用。。。).当操作比特时，你还可以执行*旋转*，这意味着从一端掉下来的比特会被插回到另一端，就像它们在绕着一个环旋转一样。尽管大多数计算机处理器都提供了机器级的 rotate 命令(因此您会在该处理器的汇编语言中看到它)，但在 C 或 C++ 中没有对“rotate”的直接支持。大概 C 语言的设计者觉得关闭“旋转”是有道理的(正如他们所说，是为了一种最小语言)，因为你可以构建自己的旋转命令。

例如，清单 3-33 显示了执行左右旋转的函数。

***清单 3-33*** 。旋转

```cpp
//: C03:Rotation.cpp {O}

// Perform left and right rotations

unsigned char rol(unsigned char val) {
  int highbit;

  if(val & 0x80) // 0x80 is the high bit only
    highbit = 1;
  else
    highbit = 0;

  // Left shift (bottom bit becomes 0):
  val <<= 1;

  // Rotate the high bit onto the bottom:
  val |= highbit;
  return val;
}

unsigned char ror(unsigned char val) {
  int lowbit;
  if(val & 1) // Check the low bit
    lowbit = 1;
  else
    lowbit = 0;
  val >>= 1;  // Right shift by one position

  // Rotate the low bit onto the top:
  val |= (lowbit << 7);
  return val;
} ///:∼
```

尝试在`Bitwise.cpp`中使用这些功能。注意`rol( )`和`ror( )`的定义(或者至少是声明)必须在函数被使用之前被`Bitwise.cpp`中的编译器看到。

按位函数通常使用起来非常有效，因为它们直接翻译成汇编语言语句。有时，一条 C 或 C++ 语句会生成一行汇编代码。

一元运算符

Bitwise *not* 不是唯一接受单个参数的运算符。它的同伴*逻辑非* ( `!`)，将接受一个`true`值并产生一个`false`值。一元减号(`-`)和一元加号(`+`)与二元减号和加号是相同的运算符；编译器通过你写表达式的方式来判断你想要的用法。例如，语句

```cpp
x = -a;
```

有着明显的含义。编译器可以算出

```cpp
x = a * -b;
```

但是读者可能会感到困惑，所以更安全的说法是

```cpp
x = a * (-b);
```

一元减号产生值的负数。一元加号与一元减号一起提供了对称性，尽管它实际上并不做任何事情。

本章前面介绍了递增和递减运算符(`++`和`--`)。除了那些涉及赋值的操作符之外，只有这些操作符有副作用。这些运算符将变量增加或减少一个单位，尽管“单位”根据数据类型可能有不同的含义——对于指针尤其如此。

最后一个一元运算符是 C 和 C++ 中的 address-of ( `&`)、dereference ( `*`和`->`)和 cast 运算符，以及 C++ 中的`new`和`delete`。Address-of 和 dereference 与指针一起使用，如本章所述。铸造在本章后面介绍，`new`和`delete`在第四章 *中介绍。*

三元运算符

三元组`if-else`不常见，因为它有三个操作数。它是一个真正的操作符，因为它产生一个值，不像普通的`if-else`语句。它由三个表达式组成:如果第一个表达式(后跟一个`?`)的计算结果为`true`，那么`?`后面的表达式将被计算，其结果将成为操作符产生的值。如果第一个表达式是`false`，则执行第三个表达式(在 a `:`之后),其结果成为运算符产生的值。

条件运算符可用于其副作用或其产生的值。下面的代码片段演示了这两种情况:

```cpp
a = --b ? b : (b = -99);
```

这里，条件产生右值。如果递减`b`的结果为非零，则将`a`赋给`b`的值。如果`b`变成零，`a`和`b`都被分配到-99。`b`总是递减，但只有当递减导致`b`变为 0 时，它才被赋值为-99。一个类似的陈述可以在没有`a =`的情况下使用，只是为了它的副作用:

```cpp
--b ? b : (b = -99);
```

这里第二个 B 是多余的，因为运算符产生的价值没有被使用。在`?`和`:`之间需要一个表达式。在这种情况下，表达式可以简单地是一个常量，它可能会使代码运行得更快一些。

逗号运算符

逗号不限于在多个定义中分隔变量名，例如

```cpp
int i, j, k;
```

当然，它也用在函数参数列表中。但是，它也可以用作分隔表达式的运算符，在这种情况下，它只产生最后一个表达式的值。逗号分隔列表中的所有其他表达式仅针对其副作用进行评估。

清单 3-34 增加一个变量列表，并使用最后一个作为右值。

***清单 3-34*** 。使用逗号运算符

```cpp
//: C03:CommaOperator.cpp
#include <iostream>
using namespace std;

int main() {
  int a = 0, b = 1, c = 2, d = 3, e = 4;
  a = (b++, c++, d++, e++);
  cout << "a = " << a << endl;
  // The parentheses are critical here. Without
  // then, the statement will evaluate to:
  (a = b++), c++, d++, e++;
  cout << "a = " << a << endl;
} ///:∼
```

一般来说，最好避免使用逗号作为除分隔符之外的任何东西，因为人们不习惯将其视为运算符。

使用运算符时的常见陷阱

如上所述，使用操作符时的一个陷阱是，当你甚至一点也不确定一个表达式将如何求值时，试图摆脱没有括号的情况(关于表达式求值的顺序，请查阅你当地的 C 手册)。清单 3-35 显示了另一个极其常见的错误。

***清单 3-35*** 。常见陷阱

```cpp
//: C03:Pitfall.cpp
// Operator mistakes

int main() {
  int a = 1, b = 1;
  while(a = b) {
    // ....
  }
} ///:∼
```

当`b`不为零时，语句`a = b`将总是评估为真。变量`a`赋给`b`的值，`b`的值也是由运算符`=`产生的。一般来说，您希望在条件语句中使用等价运算符`==`，而不是赋值。这个咬了很多程序员(不过，有些编译器会给你指出问题，这是有帮助的)。

一个类似的问题是使用按位*和*和*或*而不是它们的逻辑对应物。按位*和*和*或*使用其中一个字符(`&`或`|`，而逻辑*和*和*或*使用两个(`&&`和`||`)。就像`=`和`==`一样，很容易只输入一个字符而不是两个。一个有用的助记手段是观察比特更小，所以它们不需要在它们的操作符中有同样多的字符。

铸造操作员

单词 *cast* 用于“铸造成一个模子”的意思如果有意义，编译器会自动将一种数据类型转换成另一种。例如，如果你将一个整数值赋给一个浮点变量，编译器将秘密调用一个函数(或者更有可能是插入代码)将`int`转换成`float`。强制转换允许您显式地进行这种类型转换，或者在通常不会发生的情况下强制进行这种转换。

要执行强制转换，请将所需的数据类型(包括所有修饰符)放在值左侧的括号中。该值可以是变量、常量、表达式产生的值或函数的返回值。清单 3-36 就是一个例子。

***清单 3-36*** 。简单造型

```cpp
//: C03:SimpleCast.cpp
int main() {
  int b = 200;
  unsigned long a = (unsigned long int)b;
} ///:∼
```

强制转换是强大的，但是它会导致令人头疼的问题，因为在某些情况下，它会迫使编译器将数据当作(比如)比实际大的数据来处理，因此它会占用更多的内存空间；这可能会破坏其他数据。这通常发生在对指针进行造型时，而不是像清单 3-36 中的简单造型时。

C++ 有一个附加的转换语法，它遵循函数调用语法。这种语法将圆括号放在参数周围，就像函数调用一样，而不是数据类型周围；参见清单 3-37 。

***清单 3-37*** 。函数调用转换

```cpp
//: C03:FunctionCallCast.cpp
int main() {
  float a = float(200);
  // This is equivalent to:
  float b = (float)200;
} ///:∼
```

当然，在这种情况下，你并不真的需要石膏；你可以只说`200.f`或`200.0f`(实际上，编译器通常会对上面的表达式这么做)。强制转换通常用于变量，而不是常量。

C++ 显式强制转换

应该小心使用强制转换，因为您实际上是在对编译器说“忘记类型检查，而是把它当作另一种类型。”也就是说，你在 C++ 类型系统中引入了一个漏洞，阻止了编译器告诉你你在类型上做错了什么。更糟糕的是，编译器隐式地相信你，并且不执行任何其他检查来捕捉错误。一旦你开始选角，你就会面临各种各样的问题。事实上，任何使用大量类型转换的程序都应该被怀疑，不管你被告知多少次它只是“必须”这样做。一般来说，强制转换应该很少，并且只用于解决非常特殊的问题。

一旦您理解了这一点，并看到一个有缺陷的程序，您的第一反应可能是寻找罪魁祸首。但是如何定位 C 风格的造型呢？它们只是括号内的类型名，如果你开始寻找这样的东西，你会发现通常很难将它们与代码的其他部分区分开来。

标准 C++ 包括一个显式的强制转换语法，可以用来完全取代旧的 C 风格的强制转换(当然，如果不破坏代码，C 风格的强制转换是不合法的，但是编译器的作者可以很容易地为您标记旧风格的强制转换)。显式强制转换语法是这样的，你可以很容易地找到它们，正如你在表 3-2 中看到的它们的名字。

表 3-2 。C++ 显式强制转换语法

| `static_cast` | 对于“行为良好”和“相当行为良好”的强制转换，包括现在不需要强制转换就可以做的事情(比如自动类型转换)。 |
| `const_cast` | 丢弃`const`和/或`volatile`。 |
| `reinterpret_cast` | 赋予完全不同的意义。关键是您需要强制转换回原始类型才能安全地使用它。您强制转换的类型通常只用于位转换或其他神秘目的。这是所有演员中最危险的一个。 |
| `dynamic_cast` | 用于类型安全强制转换。 |

前三个显式强制转换将在接下来的章节中更完整地描述，而最后一个只有在你学得更多一点之后才能演示，比如在第十五章 *中。*

使用静态转换

一个`static_cast`用于所有定义明确的转换。其中包括编译器允许您在不进行强制转换的情况下进行的“安全”转换，以及定义良好的不太安全的转换。`static_cast`涵盖的转换类型包括典型的无强制转换、收缩(信息丢失)转换、从`void*`强制转换、隐式类型转换和类层次结构的静态导航。参见清单 3-38 中的示例。

***清单 3-38*** 。使用静态转换

```cpp
//: C03:static_cast.cpp
void func(int) {}

int main() {
  int i = 0x7fff;            // Max pos value = 32767
  long l;
  float f;
  // (1) Typical castless conversions:
  l = i;
  f = i;
  // Also works:
  l = static_cast<long>(i);
  f = static_cast<float>(i);

  // (2) Narrowing conversions:
  i = l;                     // May lose digits
  i = f;                     // May lose info
  // Says "I know," eliminates warnings:
  i = static_cast<int>(l);
  i = static_cast<int>(f);
  char c = static_cast<char>(i);

  // (3) Forcing a conversion from void* :
  void* vp = &i;
  // Old way produces a dangerous conversion:
  float* fp = (float*)vp;
  // The new way is equally dangerous:
  fp = static_cast<float*>(vp);

  // (4) Implicit type conversions, normally
  // performed by the compiler:
  double d = 0.0;
  int x = d;                 // Automatic type conversion
  x = static_cast<int>(d);   // More explicit
  func(d);                   // Automatic type conversion
  func(static_cast<int>(d)); // More explicit
} ///:∼
```

在第(1)节中，您可以看到在 C 语言中使用的转换类型*、*，无论有无强制转换。从一个`int`提升到一个`long`或`float`不成问题，因为后者总是能够保存一个`int`能够包含的每一个值。虽然没有必要，但你可以使用`static_cast`来突出这些促销活动。

以另一种方式转换回来如(2)所示。在这里，您可能会丢失数据，因为一个`int`没有一个`long`或一个`float`那么“宽”；它不能容纳相同大小的数字。因此这些被称为*收缩转换* 。编译器仍然会执行这些操作，但是通常会给你一个警告。您可以消除此警告，并表明您确实想使用强制转换。

在 C++ 中，如果没有强制转换，就不允许从`void*`赋值(不像 C ),如(3)所示。这很危险，需要程序员知道他们在做什么。当你寻找 bug 时，至少`static_cast`比旧的标准类型更容易定位。

程序的第(4)部分显示了通常由编译器自动执行的隐式类型转换的种类。这些都是自动的，不需要造型，但是再次强调这个动作，以防你想弄清楚发生了什么或者以后寻找它。

使用常量 _ 转换

如果你想从一个`const`转换成一个非*-*-`const`或者从一个`volatile`转换成一个非`volatile`，你可以使用`const_cast`。这是`const_cast`允许的唯一*转换；如果涉及到任何其他转换，必须使用单独的表达式来完成，否则会出现编译时错误；参见清单 3-39 。*

***清单 3-39*** 。使用常量 _ 转换

```cpp
//: C03:const_cast.cpp
int main() {
  const int i = 0;
  int* j = (int*)&i;                 // Deprecated form
  j  = const_cast<int*>(&i);         // Preferred
  // Can't do simultaneous additional casting:
//! long* l = const_cast<long*>(&i); // Error
  volatile int k = 0;
  int* u = const_cast<int*>(&k);
} ///:∼
```

如果获取一个`const`对象的地址，就会产生一个指向`const`的指针，如果不进行强制转换，这个指针就不能赋给非`const`指针。老式演员将完成这一点，但`const_cast`是一个合适的使用。同样的道理也适用于`volatile`。

使用 reinterpret _ cast

这是最不安全的转换机制，也是最容易产生错误的。一个`reinterpret_cast`假装一个对象只是一个位模式，可以被当作一个完全不同类型的对象来对待(为了一些不可告人的目的)。这是 C 语言恶名昭彰的低级位旋转。在对变量做任何其他事情之前，你实际上总是需要将变量返回到原始类型(或者将变量视为原始类型);参见清单 3-40 。

***清单 3-40*** 。使用 reinterpret _ cast

```cpp
//: C03:reinterpret_cast.cpp
#include <iostream>
using namespace std;
const int sz = 100;

struct X { int a[sz]; };

void print(X* x) {
  for(int i = 0; i < sz; i++)
    cout << x->a[i] << ' ';
  cout << endl << "--------------------" << endl;
}

int main() {
  X x;
  print(&x);
  int* xp = reinterpret_cast<int*>(&x);
  for(int* i = xp; i < xp + sz; i++)
    *i = 0;
  // Can't use xp as an X* at this point
  // unless you cast it back:
  print(reinterpret_cast<X*>(xp));
  // In this example, you can also just use
  // the original identifier:
  print(&x);
} ///:∼
```

在这个简单的例子中，`struct X`只包含一个`int`的数组，但是当你像在`X x`中那样在堆栈上创建一个数组时，每个`int`的值都是无用的(使用`( )`函数来显示`struct`的内容就可以看出这一点)。为了初始化它们，获取`X`的地址并将其转换为`int`指针，然后遍历数组将每个`int`设置为零。注意`i`的上限是如何通过将`sz`与`xp`相加计算出来的；编译器知道您实际上希望`sz`的指针位置大于`xp`，它会为您执行正确的指针算法。

`reinterpret_cast`的意思是，当你使用它时，你得到的东西是如此的陌生，以至于它不能被用于该类型的最初目的，除非你把它强制转换回去。这里，您可以看到在 print 调用中强制转换回一个`X*`,但是当然，因为您仍然拥有原始的标识符，所以您也可以使用它。但是`xp`只是作为一个`int*`有用，这是真正的“重新解释”原来的`X`。

一个`reinterpret_cast`通常表示不可取和/或不可移植的程序，但是当你决定必须使用它时，它是可用的。

sizeof—一个单独的运算符

操作符是独立的，因为它满足了一个不寻常的需求。`sizeof`提供有关为数据项分配的内存量的信息。正如本章前面所描述的，`sizeof`告诉你任何特定变量所使用的字节数。它还可以给出数据类型的大小(没有变量名)；参见清单 3-41 。

***清单 3-41*** 。使用 sizeof

```cpp
//: C03:sizeof.cpp
#include <iostream>
using namespace std;
int main() {
  cout << "sizeof(double) = " << sizeof(double);
  cout << ", sizeof(char) = " << sizeof(char);
} ///:∼
```

根据定义，任何类型的`char` ( `signed`、`unsigned,`或*普通*)的`sizeof`总是 1，而不管`char`的底层存储实际上是否是 1 字节。对于所有其他类型，结果是以字节为单位的大小。

注意`sizeof`是运算符，不是函数。如果将它应用于类型，则必须与上面所示的带括号的形式一起使用，但如果将它应用于变量，则可以不使用括号；参见清单 3-42 。

***清单 3-42*** 。对变量使用 sizeof

```cpp
//: C03:sizeofOperator.cpp
int main() {
  int x;
  int i = sizeof x;
} ///:∼
```

`sizeof`还可以给你自定义数据类型的大小。这在本书后面会用到。

asm 关键字

关键字`asm`是一种转义机制，允许你在 C++ 程序中为你的硬件编写汇编代码。通常，您可以在汇编代码中引用 C++ 变量，这意味着您可以轻松地与 C++ 代码通信，并将汇编代码限制在效率调整或使用特殊处理器指令所必需的范围内。编写汇编语言时必须使用的确切语法取决于编译器，可以在编译器的文档中找到。

显式运算符

显式运算符是位和逻辑运算符的关键字。没有`&`、`|`、`^`等键盘字符的程序员，被迫使用 C 的恐怖*三字母*，不仅打字烦，读起来也晦涩难懂。这在 C++ 中用表 3-3 中显示的附加关键字进行了修复。

表 3-3 。C++(附加)关键字

| 关键字 | 意义 |
| --- | --- |
| 和 | `&&`(逻辑*和*) |
| 或者 | `&#124;&#124;`(逻辑*或*) |
| 不 | `!`(逻辑非) |
| 非 eq | `!=`(逻辑不等价) |
| 比特和 | `&`(按位*和*) |
| and_eq | `&=`(按位*和*-赋值) |
| 比多 | `&#124;`(按位*或*) |
| or_eq | `&#124;=`(按位或分配) |
| 异或运算 | `^`(按位异或) |
| 异或等式 | `^=`(按位异或赋值) |
| 完成 | `∼`(补数) |

如果你的编译器符合标准 C *++，*它将支持这些关键字。

复合类型创建

基本数据类型及其变体是必不可少的，但是相当原始。C 和 C++ 提供了一些工具，允许您从基本数据类型中组合出更复杂的数据类型。正如你将看到的，其中最重要的是`struct`，它是 C++ 中`class`的基础。然而，创建更复杂类型的最简单的方法就是通过`typedef`将一个名字替换成另一个名字。

typedef 的别名

这个关键字承诺的要比它提供的多:`typedef`暗示了“类型定义”，而“别名”可能是一个更准确的描述，因为它确实是这样做的。下面是语法 *:*

```cpp
typedef existing-type-description alias-name

```

当数据类型变得稍微复杂时，人们经常使用`typedef`，只是为了防止额外的击键。下面是一个常用的`typedef`:

```cpp
typedef unsigned long ulong;
```

现在，如果你说`ulong`，编译器知道你指的是`unsigned long`。你可能认为使用预处理器替换可以很容易地实现这一点，但是在一些关键的情况下，编译器必须意识到你正在把一个名字当作一个类型来处理，所以`typedef`是必不可少的。

`typedef`派上用场的一个地方是指针类型。如前所述，如果你说

```cpp
int* x, y;
```

这实际上产生了一个`int*`，也就是`x,`和一个`int` ( *不是* `int*`)，也就是`y`。也就是说，`*`绑定到右边，而不是左边。然而，如果你使用一个`typedef`

```cpp
typedef int* IntPtr;
IntPtr x, y;
```

那么`x`和`y`都属于`int*`类型。

你可以争辩说，避免使用原始类型的`typedef`更显式，因此可读性更好，事实上，当使用了许多`typedef`时，程序很快变得难以阅读。然而，`typedef` s 在 C 中与`struct`一起使用时变得尤其重要。

用结构组合变量

一个`struct`是一种将一组变量收集到一个结构中的方法。一旦你创建了一个`struct`，那么你就可以创建这个你发明的“新”类型变量的许多实例。例如，参见清单 3-43 。

***清单 3-43*** 。简单的结构

```cpp
//: C03:SimpleStruct.cpp
struct Structure1 {
  char c;
  int i;
  float f;
  double d;
};

int main() {
  struct Structure1 s1, s2;
  s1.c = 'a'; // Select an element using a '.'
  s1.i = 1;
  s1.f = 3.14;
  s1.d = 0.00093;
  s2.c = 'a';
  s2.i = 1;
  s2.f = 3.14;
  s2.d = 0.00093;
} ///:∼
```

`struct`声明必须以分号结束。在`main( )`中，创建了`Structure1`的两个实例:`s1`和`s2`。这些都有自己单独的版本`c`、`i`、`f`和`d`。所以`s1`和`s2`代表完全独立变量的集合。要选择`s1`或`s2`中的一个元素，您可以使用一个`.`，这是您在上一章使用 C++ `class`对象时看到的语法；因为 es 是从 s 演变而来的，所以这就是语法的来源。

您将注意到的一件事是使用`Structure1`的笨拙之处(事实证明，这只是 C 所需要的，而不是 C++)。在 C 语言中，当你定义变量时，你不能只说`Structure1`，你必须说`struct Structure1`。这就是在 C 语言中`typedef`变得特别方便的地方；参见清单 3-44 。

***清单 3-44*** 。另一个简单的结构

```cpp
//: C03:SimpleStruct2.cpp
// Using typedef with struct
typedef struct {
  char c;
  int i;
  float f;
  double d;
} Structure2;

int main() {
  Structure2 s1, s2;
  s1.c = 'a';
  s1.i = 1;
  s1.f = 3.14;
  s1.d = 0.00093;
  s2.c = 'a';
  s2.i = 1;
  s2.f = 3.14;
  s2.d = 0.00093;
} ///:∼
```

通过这样使用`typedef`，可以假装(在 C；在定义`s1`和`s2`时，尝试移除 C++ 的`typedef`),因为`Structure2`是一个内置类型，就像`int` o `float`(但注意它只有数据特征 *—* ，不包括行为，这是我们在 C++ 中使用真实对象得到的)。您会注意到`struct`标识符在开始时被省略了，因为目标是创建`typedef`。然而，有时您可能需要在定义过程中引用`struct`。在这些情况下，您实际上可以将`struct`的名称重复为`struct`名称和`typedef`。

***清单 3-45*** 。允许结构引用自身

```cpp
//: C03:SelfReferential.cpp
// Allowing a struct to refer to itself

typedef struct SelfReferential {
  int i;
  SelfReferential* sr; // Head spinning yet?
} SelfReferential;

int main() {
  SelfReferential sr1, sr2;
  sr1.sr = &sr2;
  sr2.sr = &sr1;
  sr1.i = 47;
  sr2.i = 1024;
} ///:∼
```

如果你观察一会儿，你会看到`sr1`和`sr2`指向对方，并且各自持有一段数据。

实际上，`struct`名称不必与`typedef`名称相同，但通常这样做是为了使事情更简单。

指针和支柱

在上面的例子中，所有的`struct`都被当作对象来操作。然而，像任何存储一样，你可以获取一个`struct`对象的地址(如`SelfReferential.cpp`所示)。要选择一个特定的`struct`对象的元素，您可以使用一个`.`，如上所示。然而，如果你有一个指向`struct`对象的指针，你必须使用不同的操作符`->`选择该对象的一个元素，如清单 3-46 所示。

***清单 3-46*** 。使用指向结构的指针

```cpp
//: C03:SimpleStruct3.cpp
// Using pointers to structs
typedef struct Structure3 {
  char c;
  int i;
  float f;
  double d;
} Structure3;

int main() {
  Structure3 s1, s2;
  Structure3* sp = &s1;
  sp->c = 'a';
  sp->i = 1;
  sp->f = 3.14;
  sp->d = 0.00093;
  sp = &s2; // Point to a different struct object
  sp->c = 'a';
  sp->i = 1;
  sp->f = 3.14;
  sp->d = 0.00093;
} ///:∼
```

在`main( )`中，`struct`指针`sp`最初指向`s1`，并且`s1`的成员通过用`->`选择它们而被初始化(并且你使用相同的操作符来读取那些成员)。但是然后`sp`被指向`s2`，那些变量以同样的方式被初始化。所以你可以看到指针的另一个好处是可以动态重定向指向不同的对象；您将会了解到，这为您的编程提供了更多的灵活性。

目前，这就是你需要知道的关于`struct` s 的全部内容，但是随着这本书的进展，你会对它们(尤其是它们更有力的继承者`class` es ),变得更加熟悉。

用 enum 阐明程序

枚举数据类型是一种将名称附加到数字上的方式，从而赋予阅读代码的人更多的意义。关键字`enum`(来自 C)通过给标识符赋值 0、1、2 等，自动枚举你给它的任何标识符列表。可以声明`enum`变量(总是用整数值表示)。一个`enum`的声明看起来类似于一个`struct`声明。当你想跟踪某种特征时，枚举数据类型是有用的，如清单 3-47 所示。

***清单 3-47*** 。使用枚举

```cpp
//: C03:Enum.cpp
// Keeping track of shapes

enum ShapeType {
  circle,
  square,
  rectangle
};  // Must end with a semicolon like a struct

int main() {
  ShapeType shape = circle;
  // Activities here....
  // Now do something based on what the shape is:
  switch(shape) {
    case circle:     /* circle stuff    */ break;
    case square:     /* square stuff    */ break;
    case rectangle:  /* rectangle stuff */ break;
  }
} ///:∼
```

`shape`是`ShapeType`枚举数据类型的变量，其值与枚举中的值进行比较。因为`shape`实际上只是一个`int`，然而，它可以是一个`int`能持有的任何值(包括负数)。您还可以将一个`int`变量与枚举中的一个值进行比较。

你应该意识到清单 3-47 中的打开类型的例子是一种有问题的编程方式。C++ 有一个更好的方法来编码这种东西，对它的解释必须推迟到本书的后面。

如果你不喜欢编译器赋值的方式，你可以自己来，就像这样:

```cpp
enum ShapeType {
  circle = 10, square = 20, rectangle = 50
};
```

如果你给一些名字赋值，而不给另一些名字赋值，编译器将使用下一个整数值。例如，与

```cpp
enum snap { crackle = 25, pop };
```

编译器给`pop`的值是 26。

您可以看到当您使用枚举数据类型时，代码的可读性提高了多少。然而，在某种程度上，这仍然是一种尝试(在 C 中)来完成你在 C++ 中可以用`class`来做的事情，所以你会看到`enum`在 C++ 中用得更少。

枚举的类型检查

c 的枚举相当简单，只是将整数值与名字相关联，但是它们不提供类型检查。在 C++ 中，正如您现在可能已经预料到的，类型的概念是最基本的，对于枚举来说也是如此。当您创建命名枚举时，您实际上创建了一个新类型，就像您对类所做的那样；在翻译单元的持续时间内，枚举的名称成为保留字。

此外，C++ 中对枚举的类型检查比 C 中更严格。如果您有一个名为`a`的枚举`color`实例，您会特别注意到这一点。在 C 中，你可以说`a++,`，但在 C++ 中，你不能。这是因为递增枚举执行两次类型转换，其中一次在 C++ 中是合法的，另一次是非法的。首先，枚举的值从一个`color`隐式转换为一个`int`，然后值递增，然后`int`被转换回一个`color`。在 C++ 中，这是不允许的，因为`color`是一个独特的类型，不等同于`int`。这很有意义，因为你怎么知道`blue`的增量会出现在颜色列表中呢？如果你想增加一个`color`，那么它应该是一个类(带有一个增量操作)而不是一个`enum`，因为这个类可以变得更加安全。任何时候你写代码假设隐式转换为一个`enum`类型，编译器会标记这个固有的危险行为。

在 C++ 中，联合(下面描述)有类似的附加类型检查。

通过联合节省内存

有时一个程序会用同一个变量处理不同类型的数据。在这种情况下，您有两种选择:您可以创建一个包含所有可能需要存储的不同类型的`struct`，或者您可以使用一个`union`。一个`union`把所有的数据堆到一个空间里；它会计算出你放入`union`的最大物品所需的空间大小，并计算出`union`的大小。使用`union`节省内存。

每当您在`union`中放置一个值时，该值总是从`union`开始的相同位置开始，但是只使用必要的空间。因此，您创建了一个能够保存任何`union`变量的“超级变量”。所有`union`变量的地址都是相同的(在一个类或`struct`中，地址是不同的)。

清单 3-48 是一个`union`的简单使用。尝试移除各种元素，看看它对`union`的大小有什么影响。请注意，在一个`union`中声明一个数据类型的多个实例是没有意义的(除非您只是为了使用不同的名称)。

***清单 3-48*** 。联合的大小和简单用途

```cpp
//: C03:Union.cpp
// The size and simple use of a union
#include <iostream>
using namespace std;

union Packed { // Declaration similar to a class
  char i;
  short j;
  int k;
  long l;
  float f;
  double d;
  // The union will be the size of a
  // double, since that's the largest element
};  // Semicolon ends a union, like a struct

int main() {
  cout << "sizeof(Packed) = "
       << sizeof(Packed) << endl;
  Packed x;
  x.i = 'c';
  cout << x.i << endl;
  x.d = 3.14159;
  cout << x.d << endl;
} ///:∼
```

编译器根据您选择的联合成员执行适当的赋值。

一旦你执行了一个赋值，编译器不会关心你如何处理这个联合。在上面的例子中，你可以给`x,`赋值一个浮点值，比如

```cpp
x.f = 2.222;
```

然后将它发送到输出，就好像它是一个`int,` like

```cpp
cout << x.i;
```

这会产生垃圾。

使用数组

数组是一种复合类型，因为它们允许您将许多变量一个接一个地聚集在一个标识符名称下。如果你说

```cpp
int a[10];
```

您为 10 个相互堆叠的`int`变量创建存储，但是没有每个变量的唯一标识符名称。而是都集中在`a`这个名字下。

要访问这些*数组元素*中的一个，可以使用与定义数组相同的方括号语法，如下所示:

```cpp
a[5] = 47;

```

但是，你必须记住，即使`a`的大小是 10，你选择的数组元素从零开始(这有时被称为*零索引* )，所以你只能选择数组元素 0-9，如清单 3-49 所示。

***清单 3-49*** 。数组

```cpp
//: C03:Arrays.cpp
#include <iostream>
using namespace std;

int main() {
  int a[10];
  for(int i = 0; i < 10; i++) {
    a[i] = i * 10;
    cout << "a[" << i << "] = " << a[i] << endl;
  }
} ///:∼
```

数组访问速度极快。但是，如果索引超过了数组的末尾，就没有安全网了——您会踩到其他变量。另一个缺点是，您必须在编译时定义数组的大小；如果你想在运行时改变数组的大小，你不能用上面的语法来实现(C 有一种方法可以动态地创建数组，但是它要复杂得多)。上一章介绍的 C++ `vector`，提供了一个类似数组的对象，它可以自动调整自身的大小，所以如果在编译时无法知道数组的大小，这通常是一个更好的解决方案。

你可以创建任何类型的数组，甚至是`struct`的数组，如清单 3-50 所示。

***清单 3-50*** 。结构数组

```cpp
//: C03:StructArray.cpp
// An array of struct

typedef struct {

  int i, j, k;
}
ThreeDpoint;

int main() {

  ThreeDpoint p[10];

  for(int i = 0; i < 10; i++) {

        p[i].i = i + 1;
        p[i].j = i + 2;
        p[i].k = i + 3;
  }
} ///:∼
```

注意`struct`标识符`i`是如何独立于`for`循环的`i`的。

为了查看数组中的每个元素与下一个元素是连续的，你可以打印出地址，如清单 3-51 所示。

***清单 3-51*** 。数组地址

```cpp
//: C03:ArrayAddresses.cpp
#include <iostream>
using namespace std;

int main() {
  int a[10];
  cout << "sizeof(int) = " << sizeof(int) << endl;
  for(int i = 0; i < 10; i++)
    cout << "&a[" << i << "] = "
         << (long)&a[i] << endl;
} ///:∼
```

当您运行这个程序时，您会看到每个元素都与前一个元素相差一个`int`大小。也就是说，它们一个堆叠在另一个之上。

指针和数组

数组的标识符不同于普通变量的标识符。首先，数组标识符不是左值；您不能分配给它。它实际上只是一个方括号语法的钩子，当你给出一个数组的名字，没有方括号，你得到的是数组的起始地址；参见清单 3-52 。

***清单 3-52*** 。数组标识符

```cpp
//: C03:ArrayIdentifier.cpp

#include <iostream>

using namespace std;

int main() {

  int a[10];
  cout << "a = " << a << endl;
  cout << "&a[0] =" <<&a[0] << endl;
} ///:∼
```

当您运行这个程序时，您会看到这两个地址(将以十六进制打印，因为没有强制转换为`long`)是相同的。

因此，查看数组标识符的一种方式是作为一个指向数组开头的只读指针；而且，尽管你不能改变数组标识符来指向别的地方，你*可以*创建另一个指针并使用它在数组中移动。

事实上，方括号语法也适用于常规指针，正如你在清单 3-53 中看到的。

***清单 3-53*** 。方括号语法

```cpp
//: C03:PointersAndBrackets.cpp
int main() {
  int a[10];
  int* ip = a;
  for(int i = 0; i < 10; i++)
    ip[i] = i * 10;
} ///:∼
```

当你想把一个数组传递给一个函数时，命名一个数组产生它的起始地址的事实证明是非常重要的。如果你声明一个数组作为一个函数参数，你真正声明的是一个指针。所以在清单 3-54 中、`func1( )`、、`func2( )`实际上有相同的参数列表。

***清单 3-54*** 。数组参数

```cpp
//: C03:ArrayArguments.cpp
#include <iostream>
#include <string>
using namespace std;

void func1(int a[], int size) {
  for(int i = 0; i < size; i++)
    a[i] = i * i - i;
}

void func2(int* a, int size) {
  for(int i = 0; i < size; i++)
    a[i] = i * i + i;
}

void print(int a[], string name, int size) {
  for(int i = 0; i < size; i++)
    cout << name << "[" << i << "] = "
         << a[i] << endl;
}

int main() {
  int a[5], b[5];
  // Probably garbage values:
  print(a, "a", 5);
  print(b, "b", 5);
  // Initialize the arrays:
  func1(a, 5);
  func1(b, 5);
  print(a, "a", 5);
  print(b, "b", 5);
  // Notice the arrays are always modified:
  func2(a, 5);
  func2(b, 5);
  print(a, "a", 5);
  print(b, "b", 5);
} ///:∼
```

尽管`func1( )`和`func2( )`声明它们的参数不同，但在函数内部的用法是相同的。这个例子还揭示了其他一些问题:数组不能通过值传递；也就是说，您永远不会自动获得传递给函数的数组的本地副本。因此，当你修改一个数组时，你总是在修改外部对象。如果您期待普通参数提供的传值，这一开始可能会有点混乱。

您会注意到`print( )`对数组参数使用方括号语法。尽管在将数组作为参数传递时，指针语法和方括号语法实际上是相同的，但是方括号语法让读者更清楚地知道您的意思是该参数是一个数组。

还要注意，在每种情况下都传递了`size`参数。仅仅传递数组的地址是不够的；你必须知道函数中的数组有多大，这样你就不会超出数组的范围。

数组可以是任何类型，包括指针数组。事实上，当您想要将命令行参数传递到您的程序中时，C 和 C++ 有一个针对`main( )`的特殊参数列表，如下所示:

```cpp
int main(int argc, char* argv[]) { // ...
```

第一个参数是数组中元素的数量，这是第二个参数。第二个参数总是一个`char*`的数组，因为参数是作为字符数组从命令行传递的(记住，数组只能作为指针传递)。命令行上每个空格分隔的字符簇都被转换成一个单独的数组参数。

清单 3-55 通过遍历数组打印出所有的命令行参数。

***清单 3-55*** 。命令行参数

```cpp
//: C03:CommandLineArgs.cpp
#include <iostream>
using namespace std;

int main(int argc, char* argv[]) {
  cout << "argc = " << argc << endl;
  for(int i = 0; i < argc; i++)
    cout << "argv[" << i << "] = "
<< argv[i] << endl;
} ///:∼
```

您会注意到`argv[0]`是程序本身的路径和名称。这允许程序发现关于它自己的信息。它还在程序参数数组中增加了一个参数，因此获取命令行参数时的一个常见错误是在需要`argv[1]`时获取`argv[0]`。

在`main( )`中，不强制使用`argc`和`argv`作为标识符；那些标识符只是约定俗成的(但是如果不使用的话会让人很困惑)。此外，还有另一种方法来声明`argv`:

```cpp
int main(int argc, char** argv) { // ...
```

这两种形式是等价的，但是我发现本书中使用的版本在阅读代码时是最直观的，因为它直接说，“这是一个字符指针数组。”

从命令行得到的只是字符数组；如果你想把一个参数当作另一种类型，你需要负责在你的程序中进行转换。为了便于转换成数字，标准 C 库中有一些 helper 函数，在`<cstdlib>`中声明。最简单的方法是使用`atoi( )`、`atol( ),`和`atof( )`将 ASCII 字符数组分别转换为`int`、`long,`和`double`浮点值。清单 3-56 使用`atoi( );`其他两个函数的调用方式相同。

***清单 3-56*** 。使用 atoi()

```cpp
//: C03:ArgsToInts.cpp
// Converting command-line arguments to ints
#include <iostream>
#include <cstdlib>
using namespace std;

int main(int argc, char* argv[]) {
  for(int i = 1; i < argc; i++)
    cout << atoi(argv[i]) << endl;
} ///:∼
```

在这个程序中，您可以在命令行中输入任意数量的参数。你会注意到`for`循环从值`1`开始，跳过`argv[0]`处的程序名。此外，如果在命令行中输入一个包含小数点的浮点数，`atoi( )`只取小数点之前的数字。如果你在命令行中输入非数字，这些从`atoi( )`返回为零。

探索浮点格式

本章前面介绍的`printBinary( )`函数对于深入研究各种数据类型的内部结构非常方便。其中最有趣的是浮点格式，它允许 C 和 C++ 在有限的空间内存储代表非常大和非常小的值的数字。虽然这里不能完全暴露细节，但是`float` s 和`double` s 内部的位分为三个区域:指数、尾数、符号位；因此，它使用科学记数法存储这些值。清单 3-57 允许你打印出各种浮点数的二进制模式，这样你就可以自己推导出你的编译器的浮点数格式中使用的模式(通常这是浮点数的 IEEE 标准，但你的编译器可能不遵循)。

***清单 3-57*** 。二进制浮点型

```cpp
//: C03:FloatingAsBinary.cpp

//{L} printBinary

//{T} 3.14159

#include "printBinary.h"
#include <cstdlib>
#include <iostream>

using namespace std;

int main(int argc, char* argv[]) {
  if(argc != 2) {
    cout << "Must provide a number" << endl;
    exit(1);
  }
  double d = atof(argv[1]);
  unsigned char* cp =
    reinterpret_cast<unsigned char*> (&d);
  for(int i = sizeof(double)-1; i >= 0 ; i -= 2) {
    printBinary(cp[i-1]);
    printBinary(cp[i]);
  }
} ///:∼
```

首先，程序通过检查`argc`的值来保证你已经给了它一个参数，如果只有一个参数，这个值就是 2(如果没有参数，这个值就是 1，因为程序名总是`argv`的第一个元素)。如果失败，则打印一条消息，并调用标准 C 库函数`exit( )`来终止程序。

程序从命令行获取参数，并使用`atof( )`将字符转换为`double`。然后，通过获取地址并将其转换为一个`unsigned char*`，double 被视为一个字节数组。这些字节中的每一个都被传送到`printBinary( )`进行显示。

这个例子已经被设置为按照符号位首先出现的顺序打印字节——在我的机器上；你的可能会有所不同，所以你可能要重新安排打印的方式。您还应该意识到，浮点格式并不容易理解；例如，指数和尾数通常不排列在字节边界上，而是为每一个保留多个位，并且尽可能紧密地将它们打包到存储器中。要真正了解发生了什么，您需要找出数的每个部分的大小(符号位总是一位，但指数和尾数的大小不同)，并分别打印出每个部分的位。

指针算法

如果你对指向一个数组的指针所能做的就是把它当作该数组的别名，那么指向数组的指针就没有什么意思了。然而，指针比这更灵活，因为它们可以被修改以指向其他地方(但是记住，*数组标识符不能被修改以指向其他地方*)。

*指针算术*指的是将一些算术运算符应用于指针。指针算法之所以是一个与普通算法不同的主题，是因为指针必须符合特殊的约束，才能使它们正常工作。例如，与指针一起使用的一个常见操作符是`++`，它给指针加 1。这实际上意味着指针被更改为移动到“下一个值”，不管这意味着什么。参见清单 3-58 中的示例。

***清单 3-58*** 。指针增量

```cpp
//: C03:PointerIncrement.cpp
#include <iostream>
using namespace std;

int main() {
  int i[10];
  double d[10];
  int* ip = i;
  double* dp = d;
  cout << "ip = " << (long)ip << endl;
  ip++;
  cout << "ip = " << (long)ip << endl;
  cout << "dp = " << (long)dp << endl;
  dp++;
  cout << "dp = " << (long)dp << endl;
} ///:∼
```

在计算机上运行一次，输出如下

```cpp
ip = 6684124
ip = 6684128
dp = 6684044
dp = 6684052
```

这里有趣的是，尽管操作`++`对`int*`和`double*`来说看起来是相同的操作，但是你可以看到指针对`int*`只改变了 4 个字节，而对`double*`改变了 8 个字节。不是巧合，这是我机器上`int`和`double`的尺寸。这就是指针算法的诀窍:编译器计算出正确的数量来改变指针，使它指向数组中的下一个元素(*指针算法只在数组*中有意义)。这甚至适用于`struct`的数组，正如你在清单 3-59 中看到的。

***清单 3-59*** 。指针增量和结构数组

```cpp
//: C03:PointerIncrement2.cpp
#include <iostream>
using namespace std;

typedef struct {
  char c;
  short s;
  int i;
  long l;
  float f;
  double d;
  long double ld;
} Primitives;

int main() {
  Primitives p[10];
  Primitives* pp = p;
  cout << "sizeof(Primitives) = "
       << sizeof(Primitives) << endl;
  cout << "pp = " << (long)pp << endl;
  pp++;
  cout << "pp = " << (long)pp << endl;
} ///:∼
```

在计算机上运行一次的输出是

```cpp
sizeof(Primitives) = 40
pp = 6683764
pp = 6683804
```

所以你可以看到编译器也为指向`struct` s(和`clas` ses 和`union` s)的指针做了正确的事情。

指针算术也适用于操作符`--`、`+,`和`-`，但后两个操作符有局限性:不能将两个指针相加，如果减去指针，结果是两个指针之间的元素数。但是，您可以添加或减去一个整数值和一个指针。

清单 3-60 展示了指针算法的使用。

***清单 3-60*** 。指针算法

```cpp
//: C03:PointerArithmetic.cpp
#include <iostream>
using namespace std;

#define P(EX) cout << #EX << ": " << EX << endl;

int main() {
  int a[10];
  for(int i = 0; i < 10; i++)
    a[i] = i; // Give it index values
  int* ip = a;
  P(*ip);
  P(*++ip);
  P(*(ip + 5));
  int* ip2 = ip + 5;
  P(*ip2);
  P(*(ip2 - 4));
  P(*--ip2);
  P(ip2 - ip); // Yields number of elements
} ///:∼
```

它从另一个宏开始，但是这个宏使用了一个名为*的预处理特性，字符串化*(在表达式前用`#`符号实现)接受任何表达式并将其转换成一个字符数组。这非常方便，因为它允许打印表达式，后跟一个冒号，然后是表达式的值。在`main( )`中，你可以看到有用的简写。

尽管前缀和后缀版本的`++`和`--`对于指针是有效的，但是在这个例子中只使用了前缀版本，因为它们是在上面的表达式中指针被解引用之前应用的，所以它们允许我们看到操作的效果。注意，只有整数值被加和减；如果两个指针以这种方式组合，编译器是不允许的。

下面是程序的输出:

```cpp
*ip: 0
*++ip: 1
*(ip + 5): 6
*ip2: 6
*(ip2 - 4): 2
*--ip2: 5
```

在所有情况下，指针算法都会根据所指向元素的大小调整指针，使其指向“正确的位置”。

如果指针算法一开始看起来有点让人不知所措，不要担心。大多数时候你只需要创建数组并用`[ ]`索引它们，你通常需要的最复杂的指针算法是`++`和`--`。指针算法通常是为更聪明和复杂的程序保留的，标准 C++ 库中的许多容器隐藏了这些聪明的细节，所以你不必担心它们。

调试提示

在理想的环境中，您有一个优秀的调试器，可以轻松地使程序的行为透明，这样您就可以快速发现错误。然而，大多数调试器都有盲点，这就需要你在程序中嵌入代码片段来帮助你理解发生了什么。此外，您可能正在一个没有调试器可用的环境(比如嵌入式系统，我在那里度过了成长的岁月)中进行开发，并且可能有非常有限的反馈(比如单行 LED 显示器)。在这些情况下，您在发现和显示程序执行信息的方式上变得富有创造性。本节给出了一些实现这一点的技巧。

调试标志

如果将调试代码硬连接到程序中，可能会遇到问题。你开始得到太多的信息，这使得错误很难隔离。当你认为你已经找到了错误，你开始撕掉调试代码，却发现你需要再把它放回去。您可以使用两种类型的标志来解决这些问题:预处理器调试标志和运行时调试标志。

预处理器调试标志

通过使用预处理器来`#define`一个或多个调试标志(最好在头文件中)，您可以使用`#ifdef`语句测试标志，并有条件地包含调试代码。当您认为您的调试已经完成时，您可以简单地`#undef`这些标志，代码将自动被删除(并且您将减少可执行文件的大小和运行时开销)。

在开始构建项目之前，最好确定调试标志的名称，这样名称就会一致。传统上，预处理器标志通过全部大写来区别于变量。一个常见的标志名就是`DEBUG`(但是注意不要使用`NDEBUG`，它在 C 语言中是保留的)。语句的顺序可能是

```cpp
#define DEBUG // Probably in a header file
//...
#ifdef DEBUG  // Check to see if flag is defined
/* debugging code here */
#endif        // DEBUG
```

大多数 C 和 C++ 实现还会让您从编译器命令行使用`#define`和`#undef`标志，这样您就可以用一个命令重新编译代码并插入调试信息(最好是通过`makefile`，一个稍后将描述的工具)。有关详细信息，请查看您的本地文档。

运行时调试标志

在某些情况下，在程序执行期间打开和关闭调试标志会更方便，尤其是在程序启动时使用命令行设置它们。仅仅为了插入调试代码而重新编译大型程序是乏味的。

要动态地打开和关闭调试代码，创建`bool`标志，如清单 3-61 所示。

***清单 3-61*** 。动态调试标志

```cpp
//: C03:DynamicDebugFlags.cpp
#include <iostream>
#include <string>
using namespace std;
// Debug flags aren't necessarily global:
bool debug = false;

int main(int argc, char* argv[]) {
  for(int i = 0; i < argc; i++)
    if(string(argv[i]) == "--debug=on")
      debug = true;
  bool go = true;
  while(go) {
    if(debug) {
      // Debugging code here
      cout << "Debugger is now on!" << endl;
    } else {
      cout << "Debugger is now off." << endl;
    }
    cout << "Turn debugger [on/off/quit]: ";
    string reply;
    cin >> reply;
    if(reply == "on") debug = true;   // Turn it on
    if(reply == "off") debug = false; // Off
    if(reply == "quit") break;        // Out of 'while'
  }
} ///:∼
```

这个程序继续允许你打开和关闭调试标志，直到你键入“quit”告诉它你想退出。请注意，它要求输入完整的单词，而不仅仅是字母(如果您愿意，可以将其缩短为字母)。此外，可以选择使用命令行参数在启动时打开调试；这个参数可以出现在命令行的任何地方，因为`main( )`中的启动代码会查看所有的参数。测试非常简单，因为表达式

```cpp
string(argv[i])
```

这将获取`argv[i]`字符数组并创建一个`string`，然后可以很容易地将其与右侧的`==`进行比较。清单 3-61 中的程序搜索整个字符串`--debug=on`。你也可以寻找`--debug=`，然后看看之后是什么，提供更多的选择。尽管调试标志是相对较少的使用全局变量有意义的领域之一，但没有任何东西说它必须如此。请注意，变量是小写字母，提醒读者它不是预处理器标志。

将变量和表达式转换成字符串

编写调试代码时，编写由包含变量名的字符数组后跟变量组成的打印表达式是很乏味的。幸运的是，标准 C 包含了 *stringize* 操作符`#`，这在本章前面已经使用过。当您在预处理器宏中的参数前放置一个`#`时，预处理器会将该参数转换成一个字符数组。这一点，再加上没有插入标点的字符数组被连接成一个字符数组的事实，允许您在调试期间创建一个非常方便的宏来打印变量值，例如:

```cpp
#define PR(x) cout << #x " = " << x << "\n";
```

如果通过调用宏`PR(a)`来打印变量`a`，它将具有与代码相同的效果

```cpp
cout << "a = " << a << "\n";
```

同样的过程也适用于整个表达式。清单 3-62 使用一个宏创建一个速记来打印字符串化的表达式，然后计算表达式并打印结果。

***清单 3-62*** 。字符串表达式

```cpp
//: C03:StringizingExpressions.cpp
#include <iostream>
using namespace std;

#define P(A) cout << #A << ": " << (A) << endl;

int main() {
  int a = 1, b = 2, c = 3;
  P(a); P(b); P(c);
  P(a + b);
  P((c - a)/b);
} ///:∼
```

您可以看到像这样的技术是如何迅速变得不可或缺的，尤其是如果您没有调试器(或者必须使用多个开发环境)。当您想要去除调试时，您也可以插入一个`#ifdef`来使`P(A)`被定义为“无”。

C assert()宏

在标准头文件`<cassert>`中你会找到`assert( )`，这是一个方便的调试宏。当你使用`assert( )`时，你给它一个论点，这是一个你“断言为真”的表达式预处理器生成测试断言的代码。如果断言不是真的，程序将在发出一个错误消息告诉你断言是什么以及它失败后停止。参见清单 3-63 中一个简单的例子。

***清单 3-63*** 。使用断言

```cpp
//: C03:Assert.cpp
// Use of the assert() debugging macro
#include <cassert>  // Contains the macro
using namespace std;

int main() {
  int i = 100;
  assert(i != 100); // Fails
} ///:∼
```

宏起源于标准 C，所以它也可以在头文件`assert.h`中找到。

完成调试后，可以通过放置以下代码行来移除宏生成的代码

```cpp
#define NDEBUG
```

在程序中包含`<cassert>`之前，或者通过在编译器命令行上定义 NDEBUG。NDEBUG 是在`<cassert>`中使用的一个标志，用来改变宏生成代码的方式。

在本书的后面，你会看到一些更复杂的替代方法。

功能地址

一旦一个函数被编译并加载到计算机中执行，它就会占用一大块内存。这个内存，也就是这个函数，有一个地址。

c 语言从来都不是一门禁止他人涉足的语言。可以像使用变量地址一样，将函数地址与指针一起使用。函数指针的声明和使用起初看起来有点不透明，但它遵循了语言其余部分的格式。

定义函数指针

要定义一个指向没有参数和返回值的函数的指针，你可以说

```cpp
void (*funcPtr)();

```

当你在看这样一个复杂的定义时，最好的方法是从中间开始，然后逐步解决。“从中间开始”就是从变量名开始，也就是`funcPtr`。*“*”意思是向右寻找最近的物品(本例中没有；右括号让您停下来)，然后向左看(星号表示的指针)，然后向右看(空参数列表表示没有参数的函数)，然后向左看(`void,`表示该函数没有返回值)。这种左右运动适用于大多数声明。

要复习，中间开始(`funcPtr` *是一个*)。。。)，往右走(那里什么都没有——你被右括号挡住了)，往左走找到`*`(。。。指向一个。。)，向右走，找到空参数列表(。。。不接受参数的函数。。。)，向左走找到`void` ( `funcPtr`是一个不带参数返回`void`的函数的指针)。

你可能想知道为什么`*funcPtr`需要括号。如果你不使用它们，编译器会看到

```cpp
void *funcPtr();
```

您将声明一个函数(返回一个`void*`)而不是定义一个变量。你可以把编译器想成是在经历和你一样的过程，当它发现一个声明或者定义应该是什么的时候。它需要碰到那些括号，所以它返回到左边找到`*`，而不是继续到右边找到空的参数列表。

复杂的声明和定义

顺便说一下，一旦你弄清楚了 C 和 C++ 声明语法是如何工作的，你就可以创建更复杂的项目。例如，考虑清单 3-64 中的。

***清单 3-64*** 。复杂的定义

```cpp
//: C03:ComplicatedDefinitions.cpp

/* 1\. */     void * (*(*fp1)(int))[10];

/* 2\. */     float (*(*fp2)(int,int,float))(int);

/* 3\. */     typedef double (*(*(*fp3)())[10])();
             fp3 a;

/* 4\. */     int (*(*f4())[10])();

int main() {} ///:∼
```

浏览每一个并使用左右方向的指引来找出答案。数字 1 表示，“`fp1`是一个函数的指针，该函数接受一个整数参数，并返回一个由 10 个`void`指针组成的数组的指针。”

数字 2 表示，“`fp2`是一个指向带三个参数(`int`、`int,`和`float`)的函数的指针，返回一个指向带整数参数并返回一个`float`的函数的指针。”

如果你正在创建许多复杂的定义，你可能想要使用一个`typedef`。数字 3 显示了一个`typedef`如何节省每次输入复杂描述的时间。它说，“一个`fp3`是一个没有参数的函数的指针，返回一个由 10 个指针组成的数组，这些指针指向没有参数并返回双精度值的函数。”然后它说，“`a`是这些`fp3`类型中的一种。”`typedef`通常用于从简单的描述构建复杂的描述。

数字 4 是函数声明，而不是变量定义。它说，“`f4`是一个函数，返回一个指针，指向一个由 10 个指针组成的数组，这些指针指向返回整数的函数。”

你很少需要像这样复杂的声明和定义。然而，如果你把它们搞清楚，你甚至不会对现实生活中可能遇到的稍微复杂的问题感到不安。

使用函数指针

一旦你定义了一个指向函数的指针，你必须在使用它之前把它分配给一个函数地址。正如数组`arr[10]`的地址是由不带括号的数组名(`arr`)产生的一样，函数`func()`的地址是由不带参数列表的函数名(`func`)产生的。你也可以使用更明确的语法`&func()`。要调用这个函数，你要用声明指针的同样方式去引用它(记住 C 和 C++ 总是试图让定义看起来和它们被使用的方式一样)。清单 3-65 展示了一个指向函数的指针是如何定义和使用的。

***清单 3-65*** 。指向函数的指针

```cpp
//: C03:PointerToFunction.cpp
// Defining and using a pointer to a function
#include <iostream>
using namespace std;

void func() {
  cout << "func() called..." << endl;
}

int main() {
  void (*fp)();          // Define a function pointer
  fp = func;             // Initialize it
  (*fp)();               // Dereferencing calls the function
  void (*fp2)() = func;  // Define and initialize
  (*fp2)();
} ///:∼
```

定义了指向函数`fp`的指针后，使用`fp = func`将它分配给函数`func()`的地址(注意*函数名*上缺少参数列表)。第二种情况显示了同时定义和初始化。

指向函数的指针数组

您可以创建的一个更有趣的构造是指向函数的指针数组。要选择一个函数，你只需进入数组并取消对指针的引用。这支持了*表驱动代码*的概念；不使用条件语句或 case 语句，而是根据状态变量(或状态变量的组合)选择要执行的函数。如果您经常在表中添加或删除函数(或者如果您想要动态地创建或更改这样的表)，这种设计会很有用。

清单 3-66 使用预处理器宏创建一些虚拟函数，然后使用自动聚集初始化创建指向这些函数的指针数组。如您所见，通过更改少量代码，很容易在表中添加或删除函数(从而从程序中删除功能)。

***清单 3-66*** 。使用指向函数的指针数组

```cpp
//: C03:FunctionTable.cpp
// Using an array of pointers to functions
#include <iostream>
using namespace std;

// A macro to define dummy functions:
#define DF(N) void N() { \
   cout << "function " #N " called..." << endl; }

DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);

void (*func_table[])() = { a, b, c, d, e, f, g };

int main() {
  while(1) {
    cout << "press a key from 'a' to 'g' "
      "or q to quit" << endl;
    char c, cr;
    cin.get(c); cin.get(cr); // second one for CR
    if ( c == 'q' )
      break;                 // ... out of while(1)
    if ( c < 'a' || c > 'g' )
      continue;
    (*func_table[c - 'a'])();
  }
} ///:∼
```

在这一点上，您可能能够想象这种技术在创建某种解释器或列表处理程序时是如何有用的。

make:管理单独编译

当使用单独编译(将代码分解成许多翻译单元)时，您需要某种方法来自动编译每个文件，并告诉链接器将所有部分(连同适当的库和启动代码)构建到一个可执行文件中。大多数编译器允许您用一条命令行语句来完成这项工作。例如，对于 GNU C++ 编译器，你可能会说

```cpp
g++ SourceFile1.cpp SourceFile2.cpp
```

这种方法的问题是编译器将首先编译每个单独的文件，而不管文件*是否需要*重新构建。由于一个项目中有许多文件，如果您只更改了一个文件，那么重新编译所有文件会变得非常困难。

这个问题的解决方案是一个名为`make`的程序，它是在 Unix 上开发的，但以某种形式随处可见。`make`实用程序通过遵循一个名为`makefile`的文本文件中的指令来管理项目中的所有单个文件。当您编辑项目中的一些文件并键入`make`时，`make`程序会遵循`makefile`中的指导方针，将源代码文件上的日期与相应目标文件上的日期进行比较，如果源代码文件的日期比其目标文件的日期更新，`make`会调用源代码文件上的编译器。`make`仅重新编译被更改的源代码文件和受修改文件影响的任何其他源代码文件。通过使用`make`，您不必在每次做出更改时都重新编译项目中的所有文件，也不必检查是否所有文件都构建正确。`makefile`包含了将你的项目放在一起的所有命令。学会使用`make`会节省你很多时间和挫败感。您还会发现`make`是您在 Linux/Unix 平台上安装新软件的典型方式(尽管这些`makefile`往往比本书中介绍的要复杂得多，并且您通常会在安装过程中为您的特定机器自动生成一个`makefile`)。

因为几乎所有的 C++ 编译器都以某种形式提供了`make`(即使没有，你也可以在任何编译器上使用免费提供的`make`)，所以它将成为贯穿本书的工具。然而，编译器供应商也创造了他们自己的项目构建工具。这些工具会询问您项目中有哪些文件，并自行确定所有关系。这些工具使用类似于`makefile`的东西，通常称为*项目文件*，但是编程环境维护这个文件，所以你不必担心它。项目文件的配置和使用因开发环境的不同而不同，因此您必须找到关于如何使用它们的适当文档(尽管编译器供应商提供的项目文件工具通常使用起来非常简单，您可以通过试验来学习它们，这是最好的教育形式)。

本书中使用的`makefile`应该可以工作，即使你也在使用特定供应商的项目构建工具。

开展活动

当你输入`make`(或者不管你的“make”程序的名字是什么)，`make`程序在当前目录中查找一个名为`makefile`的文件，如果这是你的项目，你已经创建了这个文件。这个文件列出了源代码文件之间的依赖关系。`make`查看文件上的日期。如果一个依赖文件的日期比它所依赖的文件的日期早，`make`执行在依赖关系之后给出的规则。

所有在`makefile`中的注释都以一个`#`开始，并延续到行尾。举个简单的例子，名为“hello”的程序的`makefile`可能包含

```cpp
# A comment
hello.exe: hello.cpp
        mycompiler hello.cpp
```

这表示`hello.exe`(目标)依赖于`hello.cpp`。当`hello.cpp`的日期比`hello.exe`新时，`make`执行“规则”`mycompiler hello.cpp`。可能有多个依赖关系和多个规则。许多`make`程序要求所有的规则都以制表符开始。除此之外，空白通常会被忽略，因此您可以设置可读性格式。

规则不限于对编译器的调用；你可以从`make`内调用任何你想要的程序。通过创建相互依赖的依赖规则集组，您可以修改您的源代码文件，键入`make`，并确保所有受影响的文件都将被正确地重建。

宏指令

一个`makefile`可能包含*宏*(注意*这些和* C/C++ *预处理器宏* 完全不同)。宏允许方便的字符串替换。

本书中的`makefile`使用宏来调用 C++ 编译器。举个例子，

```cpp
CPP = mycompiler
hello.exe: hello.cpp
        $(CPP) hello.cpp
```

`=`用于将`CPP`标识为宏，`$`和括号用于扩展宏。在这种情况下，扩展意味着宏调用`$(CPP)`将被替换为字符串`mycompiler`。有了上面的宏，如果你想换到另一个名为`cpp`的编译器，你只需要把宏改成

```cpp
CPP = cpp
```

还可以添加编译器标志等。，或者使用单独的宏来添加编译器标志。

后缀规则

当你知道每次都是相同的基本过程时，告诉`make`如何为项目中的每一个`cpp`文件调用编译器就变得乏味了。由于`make`被设计成一个省时器，它也有一种方法来缩短动作，只要它们依赖于文件名后缀。这些缩写叫做*后缀规则*。后缀规则是教`make`如何将一种扩展名类型的文件(例如`.cpp`)转换成另一种扩展名类型的文件(`.obj`或`.exe`)的方法。一旦你教了`make`从一种文件生成另一种文件的规则，你所要做的就是告诉`make`哪些文件依赖于哪些其他文件。当`make`发现一个文件的日期早于它所依赖的文件时，它使用该规则创建一个新文件。

后缀规则告诉`make`它不需要显式的规则来构建一切，而是可以根据文件扩展名来决定如何构建。在这种情况下，它说，“要从一个以`cpp`结尾的文件构建一个以`exe`结尾的文件，调用下面的命令。”上面的例子看起来是这样的:

```cpp
CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $<
```

`.SUFFIXES`指令告诉`make`它应该注意以下任何文件扩展名，因为它们对这个特定的`makefile`有特殊的意义。接下来你会看到后缀规则`.cpp.exe,`，它说，“这是如何将任何扩展名为`cpp`的文件转换为扩展名为`exe`的文件”(当`cpp`文件比`exe`文件更新时)。和之前一样，使用了`$(CPP)`宏，但是之后你会看到一些新的东西:`$<`。因为这是以`$`开头的宏，但这是`make`的特殊内置宏之一。`$<`只能在后缀规则中使用，它表示“触发规则的任何先决条件”(有时称为*依赖*)，在这种情况下，它翻译为“需要编译的`cpp`文件”

一旦建立了后缀规则，您可以简单地说，例如，“`make Union.exe`”，后缀规则就会生效，即使在`makefile`中没有提到“Union”。

默认目标

在宏和后缀规则之后，`make`寻找文件中的第一个“目标”,并编译它，除非您另外指定。所以对于下面的`makefile`

```cpp
CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $<
target1.exe:
target2.exe:
```

如果你只输入'`make`'，那么`target1.exe`将被构建(使用默认后缀规则)，因为那是`make`遇到的第一个目标。要构建`target2.exe`，你必须明确地说出“`make target2.exe`”。这变得很乏味，所以您通常创建一个依赖于所有其他目标的默认虚拟目标，如下所示:

```cpp
CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $<
all: target1.exe target2.exe
```

这里，`all`不存在，也没有名为`all`的文件，所以每次你键入“`make’`，程序将`all`视为列表中的第一个目标(因此是默认目标)，然后它会看到`all`不存在，所以它最好通过检查所有的依赖项来创建它。因此，它查看`target1.exe`，并(使用后缀规则)查看(1) `target1.exe`是否存在，以及(2)`target1.cpp`是否比`target1.exe`更新，如果是，则运行后缀规则(如果您为特定目标提供了显式规则，则使用该规则)。然后，它移动到默认目标列表中的下一个文件。因此，通过创建一个默认的目标列表(习惯上通常被称为'`all` ' *，但是你可以称它为任何东西)你可以简单地通过键入''来创建你的项目中的每个可执行文件。此外，你可以有其他非默认的目标列表做其他事情；例如，你可以设置输入''来重建你所有的文件，并进行调试。*

makefile 示例

清单 3-67 中的给出了示例`makefile`。你会在每个子目录中发现不止一个`makefile`(它们有不同的名字；你用“`make -f`”调用一个特定的。这个是 GNU C++ 的。

***清单 3-67*** 。makefile 示例

```cpp
CPP = g++
OFLAG = -o
.SUFFIXES : .o .cpp .c
.cpp.o :
  $(CPP) $(CPPFLAGS) -c $<
.c.o :
  $(CPP) $(CPPFLAGS) -c $<

all: \
  Return \
  Declare \
  Ifthen \
  Guess \
  Guess2
# Rest of the files for this chapter not shown

Return: Return.o
  $(CPP) $(OFLAG)Return Return.o

Declare: Declare.o
  $(CPP) $(OFLAG)Declare Declare.o

Ifthen: Ifthen.o
  $(CPP) $(OFLAG)Ifthen Ifthen.o

Guess: Guess.o
  $(CPP) $(OFLAG)Guess Guess.o

Guess2: Guess2.o
  $(CPP) $(OFLAG)Guess2 Guess2.o

Return.o: Return.cpp
Declare.o: Declare.cpp
Ifthen.o: Ifthen.cpp
Guess.o: Guess.cpp
Guess2.o: Guess2.cpp
```

宏 CPP 被设置为编译器的名称。要使用不同的编译器，您可以编辑`makefile`或在命令行上更改宏的值，如下所示:

```cpp
make CPP=cpp
```

然而，请注意，`ExtractCode.cpp`有一个自动的方案来为额外的编译器自动构建`makefile`。

第二个宏`OFLAG`是用来表示输出文件名称的标志。尽管许多编译器会自动假设输出文件与输入文件具有相同的基名，但其他编译器则不会(比如 Linux/Unix 编译器，默认情况下会创建一个名为`a.out`的文件)。

你可以看到这里有两个后缀规则，一个用于`cpp`文件，一个用于`.c`文件(以防任何 C 源代码需要编译)。默认目标是`all`，这个目标的每一行都用反斜杠“继续”，直到`Guess2`，它是列表中的最后一行，因此没有反斜杠。这一章中还有很多文件，但为了简洁起见，这里只显示了这些文件。

后缀规则负责从`cpp`文件创建目标文件(扩展名为`.o`*),但是通常你需要明确地声明创建可执行文件的规则，因为通常一个可执行文件是通过链接许多不同的目标文件而创建的，而`make`无法猜测这些是什么。此外，在这种情况下(Linux/Unix ),可执行文件没有标准的扩展名，因此后缀规则不适用于这些简单的情况。因此，您会看到构建最终可执行文件的所有规则都已明确说明。*

 *这个`makefile`采取了使用尽可能少的`make`特征的绝对安全的路线；它只使用了目标和依赖的基本`make`概念，以及宏。通过这种方式，几乎可以保证与尽可能多的`make`程序一起工作。它往往会产生一个更大的`makefile`，但这并不坏，因为它是由`ExtractCode.cpp`自动生成的。

还有很多其他的`make`功能是这本书不会用到的，还有更新更聪明的版本和带有高级快捷方式的`make`变体，可以节省很多时间。您当地的文档可能会描述您特定的`make`的更多特征。同样，如果你的编译器供应商没有提供一个`make`或者它使用了一个非标准的`make`，你可以通过在互联网上搜索 GNU 档案(有很多)来找到几乎任何平台的 GNU make。

输入输出系统

C++ 支持两个完整的 I/O 系统:继承自 C 的 I/O 系统(使用类似`printf()`和`scanf()`的函数)和 C++ 定义的面向对象 I/O 系统(使用类似`cout`和`cin`的`iostreams`)。由于从 C 继承的 I/O 系统极其丰富、灵活和强大，您可能想知道为什么 C++ 还要定义另一个系统。答案在于 C 的 I/O 系统对对象一无所知。

因此，为了让 C++ 为面向对象编程提供完整的支持，C++ 必须创建一个 I/O 系统，它可以在用户定义的对象上操作。除了对对象的支持，使用 C++ 的 I/O 系统还有几个好处，你会在第十九章中看到。

头文件

清单 3-68 中的头文件包含了构建后面章节中的一些例子所需的代码。

***清单 3-68*** 。头文件< require.h >

```cpp
//: :require.h
// Test for error conditions in programs
// Local "using namespace std" for old compilers
#ifndef REQUIRE_H
#define REQUIRE_H
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <string>

inline void require(bool requirement,
const std::string &msg = "Requirement failed"){
using namespace std;
if (!requirement) {
fputs(msg.c_str(), stderr);
fputs("\n", stderr);
exit(1);
  }
}

inline void requireArgs(int argc, int args,
const std::string&msg =
    "Must use %d arguments") {
using namespace std;
if (argc != args + 1) {
fprintf(stderr, msg.c_str(), args);
fputs("\n", stderr);
exit(1);
   }
}

inline void requireMinArgs(int argc, int minArgs,
const std::string&msg =
    "Must use at least %d arguments") {
using namespace std;
if(argc < minArgs + 1) {
fprintf(stderr, msg.c_str(), minArgs);
fputs("\n", stderr);
exit(1);
  }
}

inline void assure(std::ifstream& in,
const std::string& filename = "") {
using namespace std;
if(!in) {
fprintf(stderr, "Could not open file %s\n",
filename.c_str());
exit(1);
  }
}

inline void assure(std::ofstream& out,
const std::string& filename = "") {
using namespace std;
if(!out) {
fprintf(stderr, "Could not open file %s\n",
filename.c_str());
exit(1);
  }
}
#endif // REQUIRE_H ///:∼

```

审查会议

1.  这一章是对 C++ 语法的所有基本特性的一次相当紧张的旅行，其中大部分是继承自 C 并与 C 共有的(并导致了 C++ 引以为豪的与 C 的向后兼容性。
2.  虽然这里介绍了一些 C++ 的特性，但是这篇文章主要是为那些精通编程并且只需要了解 C 和 C++ 的*语法基础*的人准备的。
3.  如果你已经是一个 C 程序员，除了对你来说很可能是新的 C++ 特性之外，你甚至可能在这里看到过一两件关于 C 的不熟悉的东西。
4.  C++ 既允许使用自己的基于对象的 I/O 系统，也允许使用从 C 继承的 I/O 系统，这反过来又允许向后兼容。
5.  注意本章末尾的头文件`require.h`。这个文件中的一些特性，比如内联函数，现在可能还不太容易理解。我建议您使用这个文件，直到第七章的开始，然后再转到第九章的中的的概念，这个文件已经在“改进的错误检查”一节中重复了，它所有的*细微差别都已经得到了充分的阐述和详细的解释*。**