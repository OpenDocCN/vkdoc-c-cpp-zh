## 十八、附录 B：容器、类型和宏

**Qt** 提供了一系列宏、类型和容器，让开发人员的生活更加轻松。在比较和使用这些功能时，您可以将本章作为参考。

### 容器

有许多可用的容器，我把它们分成三组:序列、专用容器和关联容器。*序列*只是保存对象的普通列表。*专用容器*为保存某种内容类型或特定使用场景而优化。*关联容器*用于将每个数据项关联到一个键值。

以下每个部分都包含每种类型的优点和缺点—优点用加号(+)标出；弊标有减号()。

#### 序列

`QList`

> +开始时快速插入
> 
> +结尾快速插入
> 
> +快速索引访问
> 
> +快速迭代器访问
> 
> —在大型列表中间缓慢插入

`QLinkedList`

> +开始时快速插入
> 
> +结尾快速插入
> 
> +在中间快速插入
> 
> +快速迭代器访问
> 
> —无索引访问

`QVector`

> +结尾快速插入
> 
> +快速索引访问
> 
> +快速迭代器访问
> 
> +使用连续内存
> 
> 开始时缓慢插入
> 
> —在中间缓慢插入

#### 专用容器

`QStringList`

一个`QStringList`是一个`QList<QString>`，内置了字符串处理成员函数。下面的列表涵盖了其中的一些:

*   `join`:将所有包含的字符串连接在一起，用给定的分隔符字符串分隔它们。
*   `split`:使用给定的分隔符字符串将一个`QString`拆分成一个`QStringList`。这个方法是`QString`类的成员。
*   `replaceInStrings`:对所有包含的字符串执行搜索和替换操作。

`QStack`

一个`QStack`是实现堆栈的列表。您使用`push`方法将新项目放在堆栈的顶部。您可以使用`top`方法查看顶部项目，也可以使用`pop`方法获取顶部项目。

`QQueue`

一个`QQueue`是实现队列的列表。您可以使用`enqueue`方法将新项目放在队列的末尾。您使用`dequeue`方法从队列的开始获取项目。您可以查看队列中的第一个项目，而不用使用`head`方法将它从列表中删除。

`QSet`

集合是没有任何顺序或计数的键的集合。您可以使用`insert`方法或`<<`操作符插入新的键。然后，您可以使用`contains`方法查看给定的键在集合中是否可用。要移除钥匙，使用`remove`方法。

#### 关联容器

关联容器将给定的键关联到一个值或一组值。哈希和映射的区别在于,*哈希*使用哈希函数对键进行排序，而*映射*保持键的顺序。哈希函数获取键值，并从中计算出一个称为*哈希值*的整数。结果是，散列可以更快地查找键，因为整数比较很快，而映射在遍历它们时更容易预测(因为它们根据键值而不是哈希值对内容进行排序)。

散列中使用的值和键必须是可赋值的(它们必须提供一个`operator=`)。还必须有一个`qHash`函数重载返回用作键的类型的`uint`哈希值。

映射中使用的值和键必须是可赋值的，就像散列中使用的值和键一样。不是为键类型提供一个`qHash`函数，而是必须有一个`operator<`可用。

`QHash`

要将值插入到`QHash`中，可以使用`hash[ key ] = value`方法或调用`insert( key, value )`方法。要确定散列是否包含给定的键，可以使用`contains`方法。要获得给定键的值，使用`value( key )`方法。

您可以使用`keys`方法获得所有键的列表，使用`values`方法获得所有值的列表。这两种方法都以任意顺序返回数据。通过一个`QHashIterator`，你可以遍历散列中保存的所有键值对。

`QMultiHash`

`QMultiHash`是为每个键分配几个值的散列。使用`insert( key, value )`方法插入值。虽然键和值可以通过与使用`QHash`相同的方法获得，但是通常使用`values( key )`方法来获得与给定键相关的值的列表。

`QMap/QMultiMap`

`QMap`和`QMultiMap`的用法与`QHash`和`QMultiMap`完全相同。关联容器部分的介绍中描述了这些差异。

### 类型

Qt 提供了一系列以跨平台方式定义的类型。这意味着在所有平台上，无符号 16 位整数就是无符号 16 位整数。

Qt 还提供了一个 variant 对象，可以用来表示数据并在几种类型之间进行转换。

#### 按大小分类

以下类型保证其内容的大小。通过在读写 Qt 流时使用它们，它们的字节序也可以跨平台边界保留。

*   `quint8`:8 位无符号整数，范围 0–255
*   `quint16`:16 位无符号整数，范围 0–65535
*   `quint32`:32 位无符号整数，范围 0–4294967295
*   `quint64`:64 位无符号整数，范围 0–1.844674407 e19
*   `qint8`:8 位有符号整数，范围 128–127
*   `qint16`:16 位有符号整数，范围 32768–32767
*   `qint32`:32 位有符号整数，范围 2147483648–2147483647
*   `qint64`:64 位有符号整数，范围为 9.223372036 e18–9.272036 e18

不保证它的大小，`qreal`仍然有用，因为它在除 ARM 之外的所有平台上都代表一个`double`值。在 ARM 平台上，类型代表一个`float`，因为 ARM 在双精度上有性能问题。

#### 变体类型

`QVariant`类型可以用来保存 Qt 应用程序中使用的大多数值类型。当给一个`QVariant`对象赋值时，该值会自动转换成一个`QVariant`。要将一个`QVariant`转换成给定的类型，您必须指定您期望的类型。`QtCore`模块中所有可用的类型都可以通过使用`to` *类型*方法进行转换，其中*类型*是类型名。这样支持的类型有`bool`、`QByteArray`、`QChar`、`QDate`、`QDateTime`、`double`、`int`、`QLine`、`QLineF`、`QList<QVariant>`、`QLocale`、`qlonglong`、`QMap<QString, QVariant>`、`QPoint`、`QPointF`、`QRect`、`QRectF`、`QRegExp`、`QSize`、`QSizeF`、`QString`、`QStringList`、`QTime`、`uint`、

在`QtGui`模块中使用的大多数其他 Qt 类型也可以和`QVariant`类一起使用。要将这样的类型转换成一个`QVariant`，只需将它分配给`QVariant`对象。要将它们从`QVariant`转换，请使用`value<type>`方法。

* * *

**注意**如果你用的是 MSVC 6.0，需要用`qvariant_cast`而不是`value<type>`。

* * *

**使用变体**支持自定义类型

为了支持您自己的类型与`QVariant`类的组合，您需要将它注册为一个`QMetaType`。你可以通过使用`Q_DECLARE_METATYPE(type)`宏来完成。您可以将此宏与您的类一起放在头文件中。

为了能够在所有使用`QVariant`类的情况下使用您的类，您需要通过调用`qRegisterMetaType<type>( const char *typeName )`的函数调用来注册它。类型名应该是类的名称；例如:

`qRegisterMetaType<MySpecialType>( "MySpecialType" );`

您打算以这种方式使用的所有类型都必须支持不需要任何参数的公共构造器，以及公共复制构造器和公共析构函数。

### 宏和功能

Qt 附带了许多宏和函数，以方便的方式提供了常见的操作。函数和宏分为三个部分:值处理函数、随机数函数和宏迭代。

#### 对待价值观

在处理值的时候，你经常会发现自己在寻找最大值、最小值等等。所有这些比较都可以作为函数使用:

*   `qMin( a, b )`:返回`a`和`b`中的较小值。
*   `qMax( a, b )`:返回`a`和`b`中的较大值。
*   `qBound( min, v, max )`:如果在`min`和`max`之间，返回值`v`；否则，小于`min`则返回`min`，大于`max`则返回`max`。如果`min`大于`max`，则结果未定义。

`qAbs`函数用于查找给定参数的绝对值。

您可以使用`qRound`和`qRound64`函数将`qreal`值四舍五入为整数。`qRound`函数返回一个`int`值，这意味着不同平台的结果可能不同，因为`int`的大小可能不同。这个潜在的平台相关问题由`qRound64`解决，因为它返回一个在所有平台上大小相同的`qint64`值。

#### 随机值

伪随机数通过`qrand`和`qsrand`函数处理。随机数只是伪随机的，因为相同的种子给出相同的数字序列。这意味着使用可变值作为种子非常重要。一个常用的值是当前系统时间。

`qrand`函数返回数字序列中的下一个整数，而`qsrand`用于播种序列。如果你想得到一个可预测的数字序列，确保在`qrand`前使用`qsrand`。

从`qrand`返回的值属于`int`类型。这意味着它的大小会因平台而异。限制给定随机数范围的一个简单方法是结合使用模数运算符和偏移量。例如，要生成一个介于 15 和 30 之间的随机数，可以使用下面一行代码:

`int value = 15 + qrand()%16;`

这段代码使用`%16`操作创建一个 0 到 15 之间的随机数。然后加上 15，将范围移动到 15 到 30。

#### 迭代

当遍历一个列表时，`foreach( variable, container )`宏非常方便。该宏适用于所有 Qt 容器。例如，要迭代一个`QStringList`，使用下面的代码行:

`foreach( QString value, valueList )
  doSomething( value );`

当你想永远迭代的时候，通常使用空的`for`循环(`for(;;)..`)。)或者一个永恒的`while`循环(`while(true)..`)。).为了让你的代码更容易阅读，请使用`forever`宏。下面一行显示了它在实践中的样子:

`forever
  doSomething();`

如果您不希望 Qt 将`foreach`和`forever`关键字添加到您的全局名称空间中，请将`no_keywords`值添加到项目文件中的`CONFIG`变量中。您仍然可以通过`Q_FOREACH`名称使用`foreach`宏。`foreach`宏作为`Q_FOREVER`可用。