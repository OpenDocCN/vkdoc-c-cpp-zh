# 72.重载的函数和运算符

探索 [25](25.html) 引入了重载函数的概念。探索号 [31](31.html) 带着超载的操作员继续旅程。从那以后，我们设法对重载有了一个常识性的理解。如果我没有更深入地研究这个主题，那将是我的失职，所以让我们通过更深入地研究重载函数和操作符的规则来结束重载的故事。(运算符和函数遵循相同的规则，因此在此探索中，理解*函数*同样适用于函数和用户定义的运算符。)

## 类型变换

在跳入重载池的深水区之前，我需要填补一些关于类型转换的缺失部分。回想一下 Exploration [26](26.html) 中，编译器将某些类型提升为其他类型，比如`short`到`int`。它还可以将一种类型(如`int`)转换为另一种类型(如`long`)。

将一种类型转换为另一种类型的另一种方法是使用单参数构造器。您可以将`rational{1}`视为将`int`文字`1`转换为`rational`类型的一种方式。当您声明一个单参数构造器时，您可以告诉编译器您是希望它隐式执行这种类型转换，还是需要显式类型转换。也就是说，如果构造器是隐式的(默认)，那么声明其参数类型为`rational`的函数可以接受一个整数参数，编译器自动从`int`构造一个`rational`对象，如下所示:

```cpp
rational reciprocal(rational const& r)
{
  return rational{r.denominator(), r.numerator()};
}
rational half{ reciprocal(2) };

```

要禁止这种隐式构造，请在构造器上使用`explicit`说明符。这迫使用户显式命名该类型，以便调用构造器。例如，`std::vector`有一个构造器，它将一个整数作为唯一的参数，用默认初始化的元素初始化 vector。构造器是`explicit`以避免如下语句:

```cpp
std::vector<int> v;
v = 42;

```

如果构造器不是`explicit`，编译器会自动从整数 42 构造一个`vector`，并将这个`vector`赋给`v`。因为构造器是`explicit`，编译器停止并报告一个错误。

将一种类型转换为另一种类型的另一种方法是使用类型转换运算符。编写这样一个带有关键字`operator`的操作符，后跟目的地类型。像单参数构造器一样，您可以将类型转换操作符声明为`explicit`。代替`rational`中的`convert`或`as_float`函数，您也可以编写类型转换操作符，如下所示:

```cpp
explicit operator float() const {
  return float(numerator()) / float(denominator());
}

```

编译器自动调用类型转换操作符的一个上下文是循环或`if`-语句条件。因为您在条件中使用表达式，并且条件必须是布尔型的，所以编译器认为这种使用是到类型`bool`的显式转换。如果你为类型`bool`实现一个类型转换操作符，总是使用`explicit`说明符。您将能够在一个条件中测试您的类型的对象，并且您将避免一个令人讨厌的问题，即编译器将您的类型转换为`bool`，然后将`bool`提升为`int`。你不会真的想写，比如:

```cpp
int i;
i = std::cin; // if conversion to bool were not explicit, i would get 0 or 1

```

在下面关于重载决策的讨论中，类型转换起着重要的作用。编译器不关心如何将一种类型转换为另一种类型，只关心是否必须执行转换，以及转换是内置在语言中还是用户定义的。构造器相当于类型转换运算符。

## 重载函数综述

让我们回忆一下。当两个或更多的函数声明在同一个作用域中声明相同的名字时，函数名*被重载*。C++ 对何时允许重载函数名施加了一些限制。

主要限制是重载函数必须有不同的参数列表。这意味着参数的数量必须不同，或者至少一个参数的类型必须不同。

```cpp
void print(int value);
void print(double value);         // valid overload: different argument type
void print(int value, int width); // valid overload: different number of arguments

```

当两个函数仅在返回类型上不同时，不允许在同一范围内定义两个函数。

```cpp
void print(int);
int print(int);  // illegal

```

成员函数也可以因有无`const`限定符而不同。

```cpp
class demo {
   void print();
   void print() const; // valid: const qualifier is different
};

```

成员函数不能与同一类中的静态成员函数重载。

```cpp
class demo {
   void print();
   static void print(); // illegal
};

```

关键的一点是重载发生在单个作用域内。一个作用域中的名称对另一个作用域中的名称没有影响。记住一个代码块就是一个作用域(Exploration [13](13.html) )，一个类就是一个作用域(Exploration [41](41.html) )，一个命名空间就是一个作用域(Exploration [56](56.html) )。

因此，基类中的成员函数在该类的作用域内，不会影响派生类中的名称重载，派生类有自己的作用域，与基类的作用域分开且不同。

当您在派生类中定义函数时，它会隐藏基类或外部范围中具有相同名称的所有函数，即使这些函数采用不同的参数。该规则是内部作用域中的名称隐藏外部作用域中的名称这一一般规则的一个具体示例。因此，派生类中的任何名称都隐藏了基类和命名空间范围中的名称。块中的任何名称都会隐藏外部块中的名称，依此类推。从派生类中调用隐藏函数的唯一方法是限定函数名，如清单 [72-1](#PC9) 所示。

```cpp
import <iostream>;

class base {
public:
   void print(int x) { std::cout << "int: " << x << '\n'; }
};
class derived : public base {
public:
   void print(double x) { std::cout << "double: " << x << '\n'; }
};
int main()
{
   derived d{};
   d.print(3);           // prints double: 3
   d.print(3.0);         // prints double: 3
   d.base::print(3);     // prints int: 3
   d.base::print(3.0);   // prints int: 3
}

Listing 72-1.Qualifying a Member Function with the Base Class Name

```

但是，有时您希望重载考虑派生类中的函数以及基类中的函数。解决方案是将基类名称注入派生类范围。使用声明(探索 [52](52.html) )通过*来实现这一点。**修改清单**[**72-1**](#PC9)**所以** `derived` **既可以看到** **的打印功能。**改变`main`,这样它用一个`int`参数和一个`double`参数调用`d.print`,没有限定名。**你期望什么产出？***

*   ____________________________________________________________

*   ____________________________________________________________

尝试一下，并将您的结果与清单 [72-2](#PC10) 中的结果进行比较。

```cpp
import <iostream>;

class base {
public:
   void print(int x) { std::cout << "int: " << x << '\n'; }
};
class derived : public base {
public:
   void print(double x) { std::cout << "double: " << x << '\n'; }
   using base::print;
};
int main()
{
   derived d{};
   d.print(3);            // prints int: 3
   d.print(3.0);          // prints double: 3
}

Listing 72-2.Overloading Named with a using Declaration

```

一个`using`声明导入了所有同名的重载函数。为了看到这一点，**将** `print(long)` **添加到基类中，并对** `main` **进行相应的函数调用。现在你的例子应该看起来类似于清单 [72-3](#PC11) 。**

```cpp
import <iostream>;

class base {
public:
   void print(int x) { std::cout << "int: " << x << '\n'; }
   void print(long x) { std::cout << "long: " << x << '\n'; }
};
class derived : public base {
public:
   void print(double x) { std::cout << "double: " << x << '\n'; }
   using base::print;
};
int main()
{
   derived d{};
   d.print(3);           // prints int: 3
   d.print(3.0);         // prints double: 3
   d.print(3L);          // prints long: 3
}

Listing 72-3.Adding a Base Class Overload

```

过载规则通常运行良好。你可以清楚地看到，对于`main`中的每个函数调用，编译器选择了哪个`print`函数。然而，有时规则变得更加模糊。

例如，假设您要将行`d.print(3.0f);`添加到`main`。**你希望程序打印出什么？**

*   ____________________________________________________________

编译器将`float 3.0f`提升为类型`double`并调用`print(double)`，因此输出如下:

```cpp
double: 3

```

那太容易了。来个`short`怎么样？**试试** `d.print(short(3))` **。会发生什么？**

*   ____________________________________________________________

编译器将`short`提升为类型`int`,并产生以下输出:

```cpp
int: 3

```

这还是太容易了。现在试试`unsigned`。**加** `d.print(3u)`。**会发生什么？**

*   ____________________________________________________________

那根本不管用，是吗？错误消息可能说了一些关于不明确的重载或函数调用的事情。要理解哪里出了问题，您需要更好地理解重载在 C++ 中是如何工作的，这也是本文余下部分的全部内容。

## 霸王决议

编译器应用其正常的查找规则(Exploration [71](71.html) )来查找函数名的声明。当编译器找到所需名称的第一个匹配项时，它将停止搜索，但是该范围可能有多个同名的声明。对于类型或变量，这将是一个错误，但函数可能有多个或重载的同名声明。

在编译器为它正在查找的函数名找到一个声明后，它会在同一作用域中找到该名称的所有函数声明，并应用其重载规则来选择它认为最匹配函数参数的一个声明。这个过程叫做*解析*重载的名字。

为了解决重载问题，编译器会考虑参数及其类型、函数声明中函数参数的类型，以及转换参数类型以匹配参数类型所需的类型转换和提升。像姓名查找一样，详细的规则是复杂的，微妙的，有时令人惊讶。但是如果你避免编写病态重载，你通常可以通过一些常识性的指导方针。

编译器找到函数名声明后，重载决策开始。编译器收集同一范围内同名的所有声明。这意味着编译器不包含来自任何基类或祖先类的同名函数。一个`using`声明可以将这样的名字带入派生类范围，从而让它们参与重载解析。如果函数名是非限定的，编译器会寻找成员函数和非成员函数。另一方面，`using`指令对重载解析没有影响，因为它不改变名称空间中的任何名称。

如果函数是构造器，并且有一个参数，编译器还会考虑返回所需类或派生类的类型转换运算符。

然后，编译器会丢弃任何参数个数错误的函数，或者那些函数参数无法转换为相应的参数类型的函数。它检查约束，并且不考虑任何约束检查失败的函数。当匹配成员函数时，编译器会添加一个隐式参数，这是一个指向对象的指针，就像`this`是一个函数参数一样。

最后，编译器通过测量将每个实参转换为相应的形参类型需要做什么来对所有剩余的函数进行排序，这将在下一节中解释。如果有一个具有最佳排名的唯一获胜者，则编译器已经成功地解决了重载。如果没有，编译器会应用一些平局决胜规则来尝试选择排名最好的函数。如果编译器不能选出一个获胜者，它将报告一个模糊错误。如果它有一个获胜者，它将继续下一个编译步骤，即检查成员函数的访问级别。排名最佳的重载可能不可访问，但这并不影响编译器解决重载的方式。

### 排名功能

为了对函数进行排序，编译器确定如何将每个参数转换为相应的参数类型。执行摘要是，排名最好的函数是需要最少的工作来将所有参数转换为所需的参数类型的函数。

编译器有几个工具可以将一种类型转换成另一种类型。其中许多你已经在本书前面看到过，比如提升算术类型(探索 [26](26.html) )，将派生类引用转换为基类引用(探索 [37](37.html) )，或者调用类型转换操作符。编译器将一系列转换组合成一个*隐式转换序列* (ICS)。ICS 是一系列小的转换步骤，编译器可以将这些步骤应用于函数调用参数，最终结果是将参数转换为相应函数参数的类型。

编译器有排序规则来决定一个 ICS 是否比另一个更好。编译器试图找到一个函数，对于该函数，每个参数的 ICS 是所有重载名称中最好的(或并列最好的)ICS，并且至少有一个 ICS 无疑是最好的。如果是这样的话，它会选择排名最高的函数。否则，如果它有一组函数都与最佳 ICSes 集相匹配，它将进入加时赛，如下一节所述。本节的剩余部分将讨论编译器如何对 ICSes 进行排序。

首先，一些术语。ICS 可能涉及标准转换或用户定义的转换。标准转换是 C++ 语言所固有的，比如算术转换。一个*用户定义的*转换涉及类和枚举类型上的构造器和类型转换操作符。*标准 IC*是只包含标准转换的 IC。一个*用户定义的 IC*由一系列标准转换组成，序列中任何地方都有一个用户定义的转换。(因此，任何需要两次用户派生转换才能将实参转换为形参类型的重载都不会达到这一步，因为编译器无法将实参转换为形参类型，因此不再考虑该函数签名。)

例如，将`short`转换为`const int`是一个标准的 ICS，有两个步骤:将`short`提升为`int`并添加`const`限定符。将字符串文字转换为`std::string`是一个用户定义的 ICS，它包含一个标准转换(将`const char`的数组转换为指向`const char`的指针)，后面是一个用户定义的转换(`std::string`构造器)。

一个例外是，调用复制构造器将相同的源和目标类型或派生类源复制到基类类型是标准转换，而不是用户定义的转换，即使这些转换调用用户定义的复制构造器。

编译器必须选择仍在考虑中的函数的最佳集成电路。作为这一决定的一部分，它必须能够在一个 ICS 中比较标准转换。标准转换分为三类。按照从最好到最差的顺序，类别是精确匹配、推广和其他转换。

*精确匹配*是指实参类型与形参类型相同。精确匹配转换的示例如下:

*   只改变限定条件，例如，自变量是类型`int`，参数是`const int`(但不是指向`const`的指针或对`const`的引用)

*   将数组转换为指针(探索 [59](59.html) ，例如`char[10]`到`char*`

*   将左值转换为右值，例如，`int&`到`int`

一个*提升*(探索 [26](26.html) )是从较小的算术类型(如`short`)到较大类型(如`int`)的隐式转换。编译器认为提升比转换更好，因为提升不会丢失任何信息，但转换可能会。

所有其他隐式类型转换—例如，丢弃信息的算术转换(如`long`到`int`)和基类指针的派生类指针—属于杂项转换的最后一类。

序列的类别是序列中最差转换步骤的类别。例如，将`short`转换为`const int`涉及一个*精确匹配* ( `const`)和一个*提升* ( `short`到`int`)，因此 ICS 作为一个整体的类别是*提升*。

如果一个参数是隐式对象参数(用于成员函数调用)，编译器也会比较它所需的任何转换。

现在您知道了编译器如何按类别对标准转换进行排序，您可以看到它如何使用这些信息来比较 ICSes。编译器应用以下规则来确定两个 ICSes 中哪一个更好:

*   标准 ICS 比用户定义的 ICS 更好。

*   类别更好的 ICS 比类别更差的 ICS 更好。

*   作为另一个 ICS 的真子集的 ICS 更好。

*   如果一个用户定义的 ICS1 比另一个用户定义的 ICS2 具有相同的用户转换，并且 ICS1 中的第二个标准转换优于 ICS2 中的第二个标准转换，则 ICS 1 优于 ICS 2。

*   限制较少的类型比限制较多的类型更好。这意味着目标类型为 T1 的 ICS 比目标类型为 T2 的 ICS 更好，如果 T1 和 T2 具有相同的基本类型，但 T2 是 const 而 T1 不是。

*   标准转换序列 ICS1 比 ICS2 更好，如果它们具有相同的等级，但是
    *   ICS1 将指针转换为`bool`。

    *   ICS1 和 ICS2 将指针转换为通过继承相关的类，ICS1 是一个“更小”的转换。较小的转换是跳过较少中间基类的转换。举个例子，如果`A`是从`B`派生出来的，`B`是从`C`派生出来的，那么把`B*`转换成`C*`比把`A*`转换成`C*`好，把`C*`转换成`void*`比把`A*`转换成`void*`好。

### 列表初始化

一个复杂的情况是函数参数可能没有类型，因为它不是表达式。相反，参数是一个用花括号括起来的值列表，例如用于通用初始化的花括号括起来的列表。编译器有一些特殊的规则来决定一个列表的转换顺序。

如果参数类型是一个具有构造器的类，该构造器采用类型为`std::initializer_list<T>`的单个参数，并且大括号括起来的列表中的每个成员都可以转换为`T`，编译器会将该参数视为用户定义的到`std::initializer_list<T>`的转换。例如，所有的容器类都有这样的构造器。

否则，编译器会尝试为该参数类型找到一个构造器，使得大括号括起来的列表中的每个元素都是该构造器的一个参数。如果成功，编译器认为该列表是用户定义的到参数类型的转换。请注意，每个构造器参数都允许另一个用户定义的转换序列。

编译器认为`std::initializer_list`初始化比其他构造器列表初始化更好。这就是为什么`std::string{42, 'x'}`不调用`std::string(42, 'x')`构造器的原因:编译器更喜欢将`{42, 'x'}`视为`std::initializer_list`，这将产生一个包含两个字符的字符串，一个包含代码点 42 和字母 *x* ，而不是创建包含 42 个重复字母 *x* 的字符串的构造器。

如果参数类型不是类，并且大括号括起来的列表包含单个元素，则编译器会从大括号中解开值，并应用由括起来的值产生的普通 ICS。

### 决胜局

如果编译器找不到一个比其他函数排名更高的函数，它会应用一些最终规则来选择一个胜出者。编译器按顺序检查下列规则。如果一个规则产生一个获胜者，编译器就在那个点停止，并使用获胜的函数。否则，它将继续下一个加时赛:

*   尽管返回类型不被视为重载决策的一部分，但如果重载的函数调用用于用户定义的初始化，则调用更好的标准转换序列的函数返回类型将胜出。

*   非模板函数胜过函数模板。

*   更专门化的函数模板胜过不那么专门化的函数模板。(引用或指针模板参数比非引用或非指针参数更加专门化。一个`const`参数比非`const`参数更加专门化。)

*   否则，编译器会报告一个模糊错误。

清单 [72-4](#PC14) 展示了一些重载的例子以及 C++ 如何对函数进行排序。

```cpp
import <iostream>;
import <string>;

void print(std::string_view str) { std::cout << str; }
void print(int x)                { std::cout << "int: " << x; }
void print(double x)             { std::cout << "double: " << x; }

class base {
public:
  void print(std::string_view str) const { ::print(str); ::print("\n"); }
  void print(std::string_view s1, std::string_view s2)
  {
    print(s1); print(s2);
  }
};

class convert : public base {
public:
  convert()              { print("convert()"); }
  convert(double)        { print("convert(double)"); }
  operator int() const   { print("convert::operator int()"); return 42; }
  operator float() const { print("convert::operator float()"); return 3.14159f; }
};

class demo : public base {
public:
  demo(int)      { print("demo(int)"); }
  demo(long)     { print("demo(long)"); }
  demo(convert)  { print("demo(convert)"); }
  demo(int, int) { print("demo(int, int)"); }
};

class other {
public:
  other()        { std::cout << "other::other()\n"; }
  other(int,int) { std::cout << "other::other(int, int)\n"; }
  operator convert() const
  {
    std::cout << "other::operator convert()\n"; return convert();
  }
};

int operator+(demo const&, demo const&)
{
  print("operator+(demo,demo)\n"); return 42;
}

int operator+(int, demo const&) { print("operator+(int,demo)\n"); return 42; }

int main()

{
  other x{};
  demo d{x};
  3L + d;
  short s{2};
  d + s;
}

Listing 72-4.Ranking Functions for Overload Resolution

```

**你期望清单** [**69-4**](64.html#PC8) **中的程序输出什么？**

*   ________________________________________________________________________________________________________________________

*   ____________________________________________________________

*   ____________________________________________________________

*   ____________________________________________________________

大多数时候，常识性的规则可以帮助你理解 C++ 是如何解决重载的。然而，有时您会发现编译器报告了一个您并不期望的歧义。其他时候，当您期望编译器成功时，它却无法解析重载。真正糟糕的情况是，当你犯了一个错误，编译器能够找到一个独特的函数，但这个函数与你期望的不同。您的测试失败了，但是在读取代码时，您找错了地方，因为您期望编译器抱怨糟糕的代码。

有时，你的编译器会帮助你识别那些排名最好的函数。然而，有时你可能不得不坐下来仔细检查规则，找出编译器不满意的原因。为了帮助你为那天做好准备，清单 [72-5](#PC15) 给出了一些重载错误。**看看你能否找到并解决问题。**

```cpp
import <iostream>;
import <string>;

void easy(long) {}
void easy(double) {}
void call_easy() {
   easy(42);
}

void pointer(double*) {}
void pointer(void*) {}
const int zero = 0;
void call_pointer() {
   pointer(&zero);
}

int add(int a) { return a; }
int add(int a, int b) { return a + b; }
int add(int a, int b, int c) { return a + b + c; }
int add(int a, int b, int c, int d) { return a + b + c + d; }
int add(int a, int b, int c, int d, int e) { return a + b + c + d + e; }
void call_add() {
   add(1, 2, 3L, 4.0);
}

void ref(int const&) {}
void ref(int) {}
void call_ref() {
   int x;
   ref(x);
}

class base {};
class derived : public base {};
class sibling : public base {};
class most_derived : public derived {};

void tree(derived&, sibling&) {}
void tree(most_derived&, base&) {}
void call_tree() {
   sibling s;
   most_derived md;
   tree(md, s);
}

Listing 72-5.Fix the Overloading Errors

```

`easy()`的参数是一个`int`，但是重载是针对`long`和`double`的。这两种转换都有转换秩，并且没有一个比另一个更好，因此编译器会发出一个模糊错误。

`pointer()`的问题是这两种超载都不可行。如果`zero`不是`const`，转换成`void*`将是唯一可行的选择。

`add()`函数有所有的`int`参数，但是一个参数是`long`，另一个是`double`。没问题，编译器可以把`long`转换成`int`，把`double`转换成`int`。你可能不喜欢这个结果，但是它能够做到，所以它做到了。换句话说，这里的问题是编译器没有这个函数的问题。这不是一个真正的超载问题，但是如果你在工作中遇到这个问题，你可能不会这么看。

你看到第二个`ref()`函数中缺少的`&`了吗？编译器认为两个`ref()`函数一样好。如果你声明第二个是`ref(int&)`，它就成为最佳可行候选。确切原因是`x`的类型是`int&`，不是`int`，也就是说`x`是一个`int`左值，一个程序可以修改的对象。这种微妙的区别以前并不重要，但是对于重载，这种区别是至关重要的。从左值到右值的转换具有等级精确匹配，但这是一个转换步骤。从`int&`到`int const&`的转换也完全匹配。面对两个各有一个精确匹配转换的候选者，编译器无法决定哪一个更好。将`int`更改为`int&`取消了转换步骤，该功能成为明确的最佳功能。

两个`tree()`函数都需要一次从派生类引用到基类引用的转换，所以编译器无法决定哪一个更好。对`tree`的第一次调用需要将第一个参数从`most_derived&`转换为`derived&`。第二个调用需要将第二个参数从`sibling&`转换为`base&`。

请记住，重载的目的是允许跨多种类型的单个逻辑操作，或者允许以多种方式调用单个逻辑操作(如构造字符串)。当你决定重载一个函数时，这些规则将帮助你做出正确的选择。

Tip

当您编写重载函数时，您应该确保特定函数名的每个实现都具有相同的逻辑行为。例如，当您使用一个输出操作符`cout << x`时，您只需让编译器为`operator<<`选择正确的重载，您不必关心本研究中列出的详细规则。所有的规则都适用，但是标准声明了一组合理的重载，这些重载与内置类型和关键库类型一起工作，比如`std::string`。

## 默认参数

既然你认为重载是如此的复杂，以至于你永远也不想重载一个函数，我将增加另一个复杂性。C++ 让你为一个参数定义一个默认的参数，这让一个函数调用省略相应的参数。您可以为任意数量的参数定义默认参数，只要您省略最右边的参数并且不跳过任何参数。如果愿意，您可以为每个参数提供默认参数。默认参数通常很容易理解。阅读清单 [72-6](#PC16) 中的示例。

```cpp
import <iostream>;

int add(int x = 0, int y = 0)
{
  return x + y;
}

int main()
{
  std::cout << add() << '\n';
  std::cout << add(5) << '\n';
  std::cout << add(32, add(4, add(6))) << '\n';
}

Listing 72-6.Default Arguments

```

**清单** [**72-6**](#PC16) **中的程序打印什么？**

*   ____________________________________________________________

*   ____________________________________________________________

*   ____________________________________________________________

不难预测结果，如下图所示:

```cpp
0
5
42

```

默认参数提供了替代重载的捷径。例如，您可以使用一个构造器和默认参数，而不是为`rational`类型编写几个构造器，如下所示:

```cpp
template<class T> class rational {
public:
  rational(T const& num = T{0}, T const& den = T{1})
  : numerator_{num}, denominator_{den}
  {
    reduce();
  }
  ...omitted for brevity...
};

```

我们对默认构造器的定义必须有所改变。默认构造器不是不声明参数的构造器，而是可以不带参数调用的构造器。这个`rational`构造器符合这个要求。

正如您可能已经猜到的，默认参数使重载决策变得复杂。当编译器搜索重载函数时，它会检查函数调用中显式出现的每个参数，但不会根据默认的参数类型来检查默认的参数类型。因此，使用默认参数会更容易陷入不明确的情况。例如，假设您将示例`rational`构造器添加到现有的类模板中，而没有删除旧的构造器。以下定义都会导致模糊错误:

```cpp
rational<int> zero{};
rational<int> one{1};

```

默认参数有其用途，但重载通常会给你更多的控制权。例如，通过重载 rational 构造器，当我们知道分母是 1 时，我们避免调用`reduce()`。使用内联函数，一个重载函数可以调用另一个重载函数，这通常完全消除了对默认参数的需要。如果你不确定是使用默认参数还是重载，我推荐重载。

虽然你可能不相信我，但我的意图并不是吓你不要重载函数。你很少会去探究超载的微妙之处。大多数时候，你可以依靠常识。但是有时候，编译器和你的常识不一致。当编译器抱怨不明确的重载或其他问题时，了解编译器的规则可以帮助您摆脱困境。

下一篇文章探讨了 C++ 编程的另一个方面，它的规则可能复杂而可怕:元编程，或者编写在编译时运行的程序。