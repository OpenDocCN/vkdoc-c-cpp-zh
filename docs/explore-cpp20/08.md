# 8.格式化输出

在 Exploration [4](04.html) 中，您使用制表符整齐地排列输出。标签有用，但很粗糙。本文介绍了 C++提供的一些特性，可以很好地格式化输出，比如设置输出字段的对齐、填充和宽度。C++ 20 提供了两种非常不同的格式化输出的方法。本章介绍了这两种方式，您可以选择自己喜欢的方式。

## 问题

这种探索开始有点不同。你必须编写自己的程序来解决问题，而不是阅读一个程序并回答关于它的问题。任务是打印从 1 到 20 的整数的正方形和立方体(算术变体，而不是几何形状)的表格。程序的输出应该如下所示:

```
 N   N^2    N^3
 1     1      1
 2     4      8
 3     9     27
 4    16     64
 5    25    125
 6    36    216
 7    49    343
 8    64    512
 9    81    729
10   100   1000
11   121   1331
12   144   1728
13   169   2197
14   196   2744
15   225   3375
16   256   4096
17   289   4913
18   324   5832
19   361   6859
20   400   8000

```

为了帮助你开始，清单 [8-1](#PC2) 给出了一个框架程序。你只需要填充循环体。

```
import <iomanip>;
import <iostream>;

int main()
{
  std::cout << " N   N^2    N^3\n";
  for (int i{1}; i != 21; ++i)
  {
    // write the loop body here
  }
}

Listing 8-1.Print a Table of Squares and Cubes

```

这是一个棘手的问题，所以如果你有困难，不要担心。这个练习的目的是演示格式化输出实际上有多难。如果你已经学到了那么多，即使你没有完成程序，你也成功地完成了这个练习。也许你一开始尝试过使用制表符，但那会使数字在左边对齐。

```
 N   N^2   N^3
 1   1     1
 2   4     8
 3   9     27
 4   16    64
 5   25    125
 6   36    216
 7   49    343
 8   64    512
 9   81    729
 10  100   1000

```

左对齐不是我们平时写数字的方式。传统上，数字应该右对齐(或者在小数点上对齐，如果适用的话——在本文后面的相关部分“对齐”中有更多的介绍)。右对齐的数字更容易阅读。

C++提供了一些简单但强大的技术来格式化输出。要格式化乘幂表，必须为每一列定义一个字段。字段具有宽度、填充字符和对齐方式。以下部分深入解释了这些概念。

## 字段宽度

在探索如何指定对齐方式之前，首先您必须知道如何设置输出字段的宽度。我在清单 [8-1](#PC2) 中给了你提示。**有什么暗示？**

*   _____________________________________________________________

节目第一行是`import <iomanip>;`，你没见过。这个头声明了一些有用的工具，包括`std::setw()`，它设置输出字段的最小宽度。例如，要打印一个至少占据三个字符位置的数字，调用`std::setw(3)`。如果这个数字需要更多的空间，比如说 314159，那么实际的输出将会占用更多的空间。在这种情况下，间距变成了六个字符位置。

要使用`setw`，调用函数作为输出语句的一部分。该语句看起来像是在试图打印`setw`，但实际上什么都没有打印出来，您所做的只是操纵输出流的状态。这就是为什么`setw`被称为 *I/O 机械手*的原因。`<iomanip>`头声明了几个操纵器，您将在适当的时候了解到。

清单 [8-2](#PC4) 显示了功率表程序，使用`setw`设置表中每个字段的宽度。

```
import <iomanip>;
import <iostream>;

int main()
{
  std::cout << " N   N^2    N^3\n";
  for (int i{1}; i != 21; ++i)
    std::cout << std::setw(2) << i
              << std::setw(6) << i*i
              << std::setw(7) << i*i*i
              << '\n';
}

Listing 8-2.Printing a Table of Powers the Right Way

```

表格的第一列需要两个位置，以容纳多达 20 的数字。第二列需要一些列与列之间的空间，以及最多容纳 400 个数字的空间；`setw(6)`在`N`和`N^2`列之间使用三个空格，数字使用三个字符位置。最后一列也使用列间三个空格和四个字符位置，允许最多 8000 个数字。

默认的字段宽度是零，这意味着您打印的所有内容都会占用它所需的确切空间，不多也不少。

打印一个项目后，字段宽度自动重置为零。例如，如果您想对整个表使用统一的六列宽度，您不能调用一次`setw(6)`就让它保持不变。相反，您必须在每次输出操作之前调用`setw(6)`，如下所示:

```
    std::cout << std::setw(6) << i
              << std::setw(6) << i*i
              << std::setw(6) << i*i*i
              << '\n';

```

## 填充字符

默认情况下，值用空格字符(`' '`)填充。您可以将填充字符设置为您选择的任何字符，例如零(`'0'`)或星号(`'*'`)。清单 [8-3](#PC6) 展示了在打印支票的程序中两个填充字符的奇特用法。

```
import <iomanip>;
import <iostream>;

int main()
{
  using namespace std;

  int day{14};
  int month{3};
  int year{2006};
  int dollars{42};
  int cents{7};

  // Print date in USA order. Later in the book, you will learn how to
  // handle internationalization.
  cout << "Date: " << setfill('0') << setw(2) << month
                            << '/' << setw(2) << day
                            << '/' << setw(2) << year << '\n';
  cout << "Pay to the order of: CASH\n";
  cout << "The amount of $" << setfill('*') << setw(8) << dollars << '.'
                            << setfill('0') << setw(2) << cents << '\n';
}

Listing 8-3.Using Alternative Fill Characters

```

注意，与`setw`不同的是，`setfill`是粘性的。也就是说，输出流会记住填充字符，并将该字符用于所有输出字段，直到您设置了不同的填充字符。

## 标准前缀

清单 [8-3](#PC6) 中的另一个新特性是声明`using namespace std;`。所有这些前缀有时会使代码难以阅读。名字的重要部分在混乱中消失了。通过用`using namespace std;`开始你的程序，你是在指示编译器把它不能识别的名字当作是以`std::`开始的。

如关键字所示，`std`被称为*名称空间*。几乎标准库中的每个名字都是`std`名称空间的一部分。不允许向`std`名称空间添加任何东西，任何第三方库供应商也不允许。因此，如果你看到`std::`，你就知道接下来的是标准库的一部分(所以你可以在任何可靠的参考资料中查找)。更重要的是，您知道您在自己的程序中发明的大多数名称不会与标准库中的任何名称冲突，反之亦然。名称空间将您的名字与标准库名分开。在本书的后面，您将学习创建自己的名称空间，这有助于组织库和管理大型应用程序。

另一方面，`using namespace std;`是一个危险的声明，我很少使用。如果没有在每个标准库名前面加上`std::`限定符，就会导致混乱。例如，想象一下，如果你的程序定义了一个名为`cout`或`setw`的变量。编译器有解释名字的严格规则，一点也不会混淆，但是人类读者肯定会混淆。不管有没有`using namespace std;`，最好避免与标准库中的名字冲突。

## 对齐

C++允许您将输出字段向左或向右对齐。如果你想集中一个数字，你只能靠自己。要强制向左或向右对齐，请使用`left`和`right`操纵器，包括`<iostream>`后可免费获得。(唯一需要`<iomanip>`的时候是当你想使用需要额外信息的操纵器，比如`setw`和`setfill`。)

默认的对齐方式是向右，这可能会让你觉得奇怪。毕竟，第一次尝试使用制表符来对齐表列会产生左对齐的值。然而，就 C++而言，它对你的表一无所知。对齐在字段内。`setw`操纵器指定宽度，对齐方式决定填充字符是添加在值之后(左对齐)还是值之前(右对齐)。输出流没有它之前可能打印过的其他值的记忆(比如在前一行)。因此，例如，如果您想要将一列数字按小数点对齐，您必须手动完成(或者确保列中的每个值在小数点后都有相同的位数)。

## 探索格式

现在您已经了解了格式化输出字段的基本知识，是时候稍微探索一下，帮助您全面理解字段宽度、填充字符和对齐方式是如何相互作用的。**读取清单** [**8-4**](#PC7) **中的程序并预测其输出。**

```
import <iomanip>;
import <iostream>;

int main()
{
  using namespace std;
  cout << '|' << setfill('*') << setw(6) <<  1234 << '|' << '\n';
  cout << '|' << left <<         setw(6) <<  1234 << '|' << '\n';
  cout << '|' <<                 setw(6) << -1234 << '|' << '\n';
  cout << '|' << right <<        setw(6) << -1234 << '|' << '\n';
}

Listing 8-4.Exploring Field Width, Fill Character, and Alignment

```

**您期望清单** [**8-4**](#PC7) **的输出是什么？**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

现在编写一个程序，它将产生以下输出。不作弊，简单打印一长串。相反，只打印整数和换行符，并加入字段宽度、填充字符和对齐操作符，以获得期望的输出。

```
000042
420000
42
-42-

```

许多不同的程序可以实现相同的目标。我的程序，如清单 [8-5](#PC9) 所示，只是许多可能性中的一种。

```
import <iomanip>;
import <iostream>;

int main()
{
  using namespace std;

  cout << setfill('0') << setw(6) << 42 << '\n';
  cout << left         << setw(6) << 42 << '\n';
  cout << 42 << '\n';
  cout << setfill('-') << setw(4) << -42 << '\n';
}

Listing 8-5.Program to Produce Formatted Output

```

接受参数的操纵器，如`setw`和`setfill`，在`<iomanip>`中声明。没有参数的操纵器，如`left`和`right`，在`<iostream>`中声明。如果你不记得了，把两个模块都包括进去。如果你包含一个你并不真正需要的模块，你不会注意到任何不同。

I’M LYING TO YOU

`left`和`boolalpha`机械手是`<iostream>`中声明的*而不是*。我骗了你。它们实际上是在`<ios>`中声明的。但是`<iostream>`包含`<ios>`，所以当你包含`<iostream>`时，你会自动获得`<ios>`中的所有内容。

我对你撒谎已经有一段时间了。输入运算符(`>>`)实际上是在`<istream>`中声明的，输出运算符(`<<`)是在`<ostream>`中声明的。与`<ios>`一样，`<iostream>`割台始终包括`<istream>`和`<ostream>`。因此，您可以包含`<iostream>`并获得典型输入和输出所需的所有头文件。其他的头，比如`<iomanip>`，不太常用，所以不是`<iostream>`的一部分。

所以我并没有真的对你撒谎，只是在等你接受事实。

## 替代语法

我喜欢使用操纵器，因为它们简洁、清晰、易于使用。您也可以使用点运算符(`.`)将函数应用于输出流对象。比如设置填充字符，可以调用`std::cout.fill('*')`。`fill`函数被称为*成员函数*，因为它是输出流类型的成员。您不能将其应用于任何其他类型的对象。只有一些类型有成员函数，并且每个类型都定义了它所允许的成员函数。任何 C++库参考的很大一部分都与各种类型及其成员函数有关。(输出流的成员函数与输出操作符一起在`<ostream>`中声明。输入流的成员函数在`<istream>`中声明。当您导入`<iostream>`时，这两个模块都会自动导入。)

当设置粘性属性时，如填充字符或对齐，您可能更喜欢使用成员函数而不是操纵器。您还可以使用成员函数来查询当前填充字符、对齐和其他标志以及字段宽度，这是您无法使用操纵器完成的事情。

成员函数语法使用流对象、点(`.`)和函数调用，例如`cout.fill('0')`。设置对齐稍微复杂一点。清单 [8-6](#PC10) 显示了与清单 [8-5](#PC9) 相同的程序，但是使用了成员函数而不是操纵器。

```
import <iostream>;

int main()
{
  using namespace std;

  cout.fill('0');
  cout.width(6);
  cout << 42 << '\n';
  cout.setf(ios_base::left, ios_base::adjustfield);
  cout.width(6);
  cout << 42 << '\n';
  cout << 42 << '\n';
  cout.fill('-');
  cout.width(4);
  cout << -42 << '\n';
}

Listing 8-6.A Copy of Listing 8-5, but Using Member Functions

```

要查询当前填充字符，调用`cout.fill()`。这与您用来设置填充字符的函数名相同，但是当您不带参数调用该函数时，它会返回当前的填充字符。类似地，`cout.width()`返回当前字段宽度。获取标志略有不同。您调用`setf`来设置标志，例如对齐，但是您调用`flags()`来返回当前标志。此时细节并不重要，但是如果你很好奇，可以参考任何相关的图书馆参考资料。

## 独立地

现在是你从头开始写程序的时候了。请随意查看其他程序，以确保您拥有所有必要的部分。编写这个程序来生成一个从 1 到 10(包括 1 和 10)的乘法表，如下所示:

```
   *|   1   2   3   4   5   6   7   8   9  10
----+----------------------------------------
   1|   1   2   3   4   5   6   7   8   9  10
   2|   2   4   6   8  10  12  14  16  18  20
   3|   3   6   9  12  15  18  21  24  27  30
   4|   4   8  12  16  20  24  28  32  36  40
   5|   5  10  15  20  25  30  35  40  45  50
   6|   6  12  18  24  30  36  42  48  54  60
   7|   7  14  21  28  35  42  49  56  63  70
   8|   8  16  24  32  40  48  56  64  72  80
   9|   9  18  27  36  45  54  63  72  81  90
  10|  10  20  30  40  50  60  70  80  90 100

```

在您完成您的程序并确保它产生正确的输出后，将您的程序与我的程序进行比较，如清单 [8-7](#PC12) 所示。

```
import <iomanip>;
import <iostream>;

int main()
{
  using namespace std;

  int constexpr low{1};        ///< Minimum value for the table
  int constexpr high{10};      ///< Maximum value for the table
  int constexpr colwidth{4};   ///< Fixed width for all columns

  // All numbers must be right-aligned.
  cout << right;

  // First print the header.
  cout << setw(colwidth) << '*'
       << '|';
  for (int i{low}; i <= high; i = i + 1)
    cout << setw(colwidth) << i;
  cout << '\n';

  // Print the table rule by using the fill character.
  cout << setfill('-')
       << setw(colwidth) << ""                    // one column's worth of "-"
       << '+'                                     // the vert. & horz. intersection
       << setw((high-low+1) * colwidth) << ""     // the rest of the line
       << '\n';

  // Reset the fill character.
  cout << setfill(' ');

  // For each row...
  for (int row{low}; row <= high; row = row + 1)
  {
    cout << setw(colwidth) << row << '|';
    // Print all the columns.
    for (int col{low}; col <= high; col = col + 1)
      cout << setw(colwidth) << row * col;
    cout << '\n';
  }
}

Listing 8-7.Printing a Multiplication Table

```

我猜你写的程序和我写的有一点不同，或者你写的很不一样。没关系。最有可能的是，您为表格规则使用了一个硬编码的字符串(分隔标题和表格的线)，或者您使用了一个`for`循环。我使用了 I/O 格式，只是为了向您展示什么是可能的。打印具有非零字段宽度的空字符串是打印单个字符的重复的一种快速而简单的方法。

另一个我额外增加的新特性是`constexpr`关键字。在定义中使用该关键字将对象定义为常量而不是变量。编译器确保您不会意外地将任何内容赋给该对象。如你所知，命名常量比在源代码中添加数字更容易阅读和理解。

## `format`功能

C++ 20 中的新功能是`format()`函数，它的工作方式类似于 Python 的`format()`函数。第一个参数是格式字符串，后续参数是要格式化的值。该函数知道如何格式化所有内置类型，以及标准库中的类型，并且您可以为您的自定义类型定义格式化程序。

在格式字符串中，每个要格式化的值或字段由一组花括号指定。大括号外的文本被逐字复制。格式字符串后跟要作为附加函数参数打印的值。例如，

```
std::format("x: {}, y: {}, z: {}\n", 10, 20, 30)

```

返回以下字符串:

```
x: 10, y: 20, z: 30

```

您也可以从零开始给字段编号。如果格式字符串中的顺序与参数的顺序不匹配，这将非常有用。例如，

```
std::format("x: {2}, y: {1}, z: {0}\n", 10, 20, 30)

```

返回以下字符串:

```
x: 30, y: 20, z: 10

```

不要在一个格式字符串中混合编号和未编号的字段。

为了更好地控制格式，请在冒号后指定格式细节。细节取决于参数的类型。对于标准类型，格式说明符由以下部分组成。所有部分都是可选的，但如果有，必须按以下顺序排列:

```
fill-and-align sign # 0 width type

```

说明符(如果有)以可选的填充和对齐开始。开始调整时对准为`'<'`，居中调整时对准为`'^'`，结束调整时对准为`'>'`。填充字符可以是除`'{'`或`'}'`之外的任何字符。如果指定填充字符，还必须指定对齐字符。默认情况下，数字是结束调整的，其他类型是开始调整的。

从左向右阅读的语言将开始调整的字段在左边对齐，结束调整的字段在右边对齐。从右向左阅读的语言会颠倒顺序，因此开始调整的字段靠右对齐，结束调整的字段靠左对齐。

在填充和对齐之后是一个可选符号:`'+'`为所有数字发出一个符号，`'-'`只为负数发出一个符号，或者一个空格为负数发出一个符号，一个空格为其他值发出一个空白。默认是`'-'`。

接下来是一个可选的`'#'`字符，用于请求另一种形式，比如一个基本前缀(`0x`表示十六进制，`0b`表示二进制，等等。).

接下来是字段宽度。如果不使用填充和对齐方式，可以使用“0”字符开始字段宽度，这将使用默认对齐方式，并在符号和基线后填充“0”字符。还可以通过嵌套一组花括号和一个可选的参数编号来代替字段宽度，从而将参数用作字段宽度。

最后，可选的类型字母进一步控制格式。对于整数，可以用`'b'`表示二进制输出，`'d'`表示十进制，`'o'`表示八进制，`'x'`表示十六进制，或者`'c'`将值格式化为等价字符。字符的默认值是`'c'`，整数的默认值是`'d'`。举个例子，

```
std::format("'{0:c}': {0:#04x} {0:0>#10b} |{0:{1}d}| {2:s}\n", '*', 4, "str")

```

返回以下字符串:

```
'*': 0x2a 0b00101010 |  42| str

```

完整的规则稍微复杂一些，但是这应该足够让你开始了。**使用** `std::format()` **功能**重写清单[](#PC12)****。务必将`<iomanip>`模块更改为`<format>`。在清单 [8-8](#PC20) 中比较你的程序和我的程序。****

 **```
import <format>;
import <iostream>;

int main()
{
  int constexpr low{1};        ///< Minimum value for the table
  int constexpr high{10};      ///< Maximum value for the table
  int constexpr colwidth{4};   ///< Fixed width for all columns

  // First print the header.
  std::cout << std::format("{1:>{0}c}|", colwidth, '*');
  for (int i{low}; i <= high; i = i + 1)
    std::cout << std::format("{1:{0}}", colwidth, i);
  std::cout << '\n';

  // Print the table rule by using the fill character.
  std::cout << std::format("{2:->{0}}+{2:->{1}}\n",
       colwidth, (high-low+1) * colwidth, "");

  // For each row...
  for (int row{low}; row <= high; row = row + 1)
  {
    std::cout << std::format("{1:{0}}|", colwidth, row);
    // Print all the columns.
    for (int col{low}; col <= high; col = col + 1)
      std::cout << std::format("{1:{0}}", colwidth, row * col);
    std::cout << '\n';
  }
}

Listing 8-8.Printing a Multiplication Table Using the format Function

```

格式字符串是紧凑的，但也可能是隐晦的。选择你喜欢的风格，并在你的代码中统一使用。即使你更喜欢`format()`，也要准备好阅读你那部分使用更冗长风格的代码，因为那是出现在数百万行现有 C++代码中的内容。

无论你如何格式化输出，循环都是你的朋友。想到循环，你首先想到的是什么数据结构？我希望您选择了数组，因为这是下一篇文章的主题。**