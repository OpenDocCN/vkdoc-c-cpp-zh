# 59.国际角色

探索 17-19 讨论了角色，但只是暗示了更大的事情即将到来。Exploration [58](58.html) 开始从地区和方面来研究这些更大的问题。下一个要探讨的主题是如何在国际环境中讨论字符集和字符编码。

这个探索引入了宽字符，它类似于普通的(或*窄*)字符，除了它们通常占用更多的内存。这意味着宽字符类型可能比普通的`char`表示更多的字符。在探索宽字符的过程中，您还会对 Unicode 有更多的了解。

## 为什么宽？

正如您在 Exploration [18](18.html) 中看到的，特定字符值的含义取决于地区和字符集。例如，在一个语言环境中，您可以处理希腊语字符，而在另一个语言环境中，根据字符集，您可以处理西里尔语字符。你的程序需要知道区域设置和字符集，以便确定哪些字符是字母，哪些是标点，哪些是大写或小写，以及如何将大写字母转换成小写字母和将 T2 转换成小写字母。

如果你的程序必须处理西里尔文和希腊文怎么办？如果这个程序需要同时处理它们呢？亚洲语言呢？中文不使用西方风格的字母表，而是使用成千上万种不同的表意文字。一些亚洲语言已经采用了一些中国的表意文字。典型的`char`类型的实现达到了 256 个不同字符的极限，这远远不能满足国际需求。

换句话说，如果你想支持世界上大多数人和他们的语言，你不能使用普通的`char`和`string`类型。C++用*宽字符*解决了这个问题，它用几种类型来表示:`wchar_t`、`char16_t`和`char32_t`。(与 C 对`wchar_t`的定义不同，C++中的类型名是保留关键字和内置类型，而不是 typedefs。)其意图是`wchar_t`是一个原生类型，可以表示不适合`char`的字符。例如，对于较大的字符，程序可以支持亚洲字符集。`char16_t`和`char32_t`是 Unicode 类型。类型`char8_t`也适用于 Unicode，但它是一种窄字符类型。探索从检查`wchar_t`开始。

## 使用宽字符

在真正的 C++风格中，`wchar_t`的大小和其他特征留给了实现。唯一的保证是`wchar_t`至少和`char`一样大，并且`wchar_t`和一个内置的整数类型一样大。`<cwchar>`头为这个内置类型声明了一个 typedef，`std::wint_t`。在一些实现中，`wchar_t`可能与`char`相同，但是大多数桌面和工作站环境使用 16 或 32 位作为`wchar_t`。

挖掘清单 [26-2](26.html#PC5) 并修改它，以揭示在您的 C++环境中`wchar_t`和`wint_t`的大小。**`wchar_t`**中有多少位？**_ _ _ _ _ _ _ _ _ _ _ _ _**`wint_t`**中有多少？**_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 他们应该是同一个号码。**`char`**中有多少位？**_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _******

 ****宽字符串对象使用`std::wstring`类型(在`<string>`中声明)。宽字符串是由宽字符组成的字符串。在所有其他方面，宽弦和窄弦的行为类似；它们具有相同的成员函数，并且您以相同的方式使用它们。例如，`size()`成员函数返回字符串中的字符数，而不管每个字符的大小。

宽字符和字符串文字看起来像它们的窄对等物，除了它们以大写字母`L`开始并且包含宽字符。在字符或字符串文字中表达宽字符的最佳方式是用`\x`转义符指定字符的十六进制值(在探索 [17](17.html) 中介绍)。因此，您必须知道您的 C++环境使用的宽字符集，并且您必须知道该字符集中所需字符的数值。如果您的编辑器和编译器允许，您可以直接在宽字符文本中编写宽字符，但是您的源代码不能移植到其他环境中。您也可以在宽字符或字符串文字中写入窄字符，编译器会自动将窄字符转换为宽字符，如下所示:

```
wchar_t capital_a{'A'};        // the compiler automatically widens narrow characters
std::wstring ray{L"Ray"};
wchar_t pi{L'π'};              // if your tools let you type π as a character
wchar_t pi_unicode{L'\x03c0'}; // if wchar_t uses a Unicode encoding, such as UTF-32
std::wstring price{L"\x20ac" L"12345"};           // Unicode Euro symbol: €12345

```

请注意，在示例的最后一行，我是如何将字符串分成两部分的。回想一下 Exploration [17](17.html) 中的内容，`\x`转义开始一个转义序列，该序列通过十六进制(基数为 16)的值来指定一个字符。编译器收集尽可能多的字符来形成一个有效的十六进制数，即数字和字母`A`到`F`(大写或小写)。然后，它使用该数值作为单个字符的表示。如果最后一行是一个字符串，编译器会试图将整个字符串解释为`\x`转义。这意味着编译器会认为字符值是十六进制值 20AC12345 <sub>16</sub> 。通过分隔字符串，编译器知道什么时候`\x`转义结束，它编译字符值 20AC <sub>16</sub> ，后面是字符`1`、`2`、`3`、`4`和`5`。就像窄字符串一样，编译器将相邻的宽字符串组装成一个宽字符串。(但是，不允许将窄弦和宽弦放在一起。使用全宽字符串或全窄字符串，而不是两者的混合。)

## 宽弦

你所知道的关于`string`的一切也适用于`wstring`。他们只是一个普通模板的实例，`basic_string`。`<string>`头声明`string`是`basic_string<char>`的 typedef，而`wstring`是`basic_string<wchar_t>`的 typedef。模板的魔力在于关注细节。

因为`string`和`wstring`的底层实现实际上是一个模板，任何时候你写一些使用字符串的实用程序代码，你都应该考虑把这些代码也做成一个模板。例如，假设您想要重写`is_palindrome`函数(来自清单 [22-5](22.html#PC5) ),以便它可以处理宽字符。与其把`char`换成`wchar_t`，不如把它变成一个函数模板。首先将支持函数重写为函数模板，将字符类型作为模板参数。**重写** `is_palindrome` **的支持函数，使其适用于窄和宽的字符串和字符。清单 [59-1](#PC2) 给出了我的解决方案。**

```
import <locale>;

template<class Char>
auto const& ctype{ std::use_facet<std::ctype<Char>>(std::locale()) };

/** Test for non-letter.
 * @param ch the character to test
 * @return true if @p ch is not a letter
 */
template<class Char>
bool isletter(Char ch)
{
  return ctype<Char>.is(std::ctype_base::alpha, ch);
}

/** Convert to lowercase.
 * @param ch the character to test
 * @return the character converted to lowercase
 */
template<class Char>
Char lowercase(Char ch)
{
  return ctype<Char>.tolower(ch);
}

/** Compare two characters without regard to case. */
template<class Char>
bool same_char(Char a, Char b)
{
  return lowercase(a) == lowercase(b);
}

Listing 59-1.Supporting Cast for the is_palindrome Function Template

```

下一个任务是重写`is_palindrome`本身。模板实际上有三个模板参数，`basic_string_view`有两个。第一个是人物类型，接下来的两个是我们此时不必关心的细节。重要的是，如果您想模板化您自己的处理字符串的函数，您应该处理所有三个模板参数。

然而，在开始之前，在将函数作为标准算法的参数时，您必须意识到一个小障碍:参数必须是真实的函数，而不是函数模板的名称。换句话说，如果你必须使用函数模板，比如`lowercase`和`non_letter`，你必须实例化模板并传递模板实例。当您将`non_letter`和`same_char`传递给`remove_if`和`equal`算法时，一定要传递正确的模板参数。如果`Char`是字符类型的模板参数，使用`non_letter<Char>`作为`remove_if`的仿函数参数。

**将** `is_palindrome` **函数重写为带有两个模板参数**的函数模板。第一个模板参数是字符类型:称之为`Char`。调用第二个模板参数`Traits`。您必须对`std::basic_string_view`模板使用这两个参数。清单 [59-2](#PC3) 展示了我版本的`is_palindrome`函数，它被转换成一个模板，因此它可以处理窄和宽的字符串。

```
import <ranges>;
import <string_view>;

/** Determine whether @p str is a palindrome.
 * Only letter characters are tested. Spaces and punctuation don't count.
 * Empty strings are not palindromes because that's just too easy.
 * @param str the string to test
 * @return true if @p str is the same forward and backward
 */
template<class Char, class Traits>
bool is_palindrome(std::basic_string_view<Char, Traits> str)
{
  auto letters_only{ str | std::views::filter(isletter<Char>) };
  auto reversed{ letters_only | std::ranges::views::reverse };
  return std::equal(
    std::ranges::begin(letters_only), std::ranges::end(letters_only),
    std::ranges::begin(reversed),     std::ranges::end(reversed),
    same_char<Char>);
}

Listing 59-2.Changing is_palindrome to a Function Template

```

除了传递给`basic_string_view`之外，`is_palindrome`函数从不使用`Traits`模板参数。如果您对该参数感到好奇，请查阅语言参考资料，但要注意它有点高级。

调用`is_palindrome`很容易，因为编译器使用自动类型推断来确定您使用的是窄字符串还是宽字符串，并相应地实例化模板。因此，调用者根本不必为模板费心。

不再赘述，`isletter`和`lowercase`函数模板可以处理宽字符参数。这是因为区域设置是模板，在字符类型上参数化，就像字符串和 I/O 类模板一样。

然而，为了使用宽字符，您必须使用宽字符执行 I/O，这是下一节的主题。

## 宽字符输入输出

通过从`std::wcin`开始读取，您可以从标准输入中读取宽字符。通过写入`std::wcout`或`std::wcerr`来写入宽字符。一旦您从流中读取或写入任何内容，相应的窄流和宽流的字符宽度是固定的，并且您不能更改它—您必须决定是使用窄字符还是宽字符，并在流的生存期内保持该选择。所以，一个程序必须使用`cin`或`wcin`，但不能两者都用。输出流也是如此。`<iostream>`头声明了所有标准流的名称，窄流和宽流。`<istream>`头定义了所有的输入流类和操作符；`<ostream>`定义输出类和操作符。更准确的说，`<istream>`和`<ostream>`定义模板，字符类型是第一个模板参数。

`<istream>`头定义了`std::basic_istream`类模板，在字符类型上参数化。同一个头声明了两个 typedefs，如下所示:

```
using istream = basic_istream<char>;
using wistream = basic_istream<wchar_t>;

```

正如您所猜测的，`<ostream>`头是相似的，定义了`basic_ostream`类模板和`ostream`和`wostream`类型定义。

`<fstream>`头遵循相同的模式— `basic_ifstream`和`basic_ofstream`是类模板，带有类型定义，如下所示:

```
using ifstream  = basic_ifstream<char>;
using wifstream = basic_ifstream<wchar_t>;
using ofstream  = basic_ofstream<char>;
using wofstream = basic_ofstream<wchar_t>;

```

**从清单** [**22-5**](22.html#PC5) **重写主程序，测试带有宽字符 I/O** 的 `is_palindrome` **函数模板。现代的桌面环境应该能够支持宽字符，但是您可能必须学习一些新的特性，以弄清楚如何让您的文本编辑器保存具有宽字符的文件。您可能还需要加载一些额外的字体。最有可能的情况是，您可以提供一个普通的窄文本文件作为输入，程序就会运行良好。如果你很难找到一个合适的输入文件，尝试一下回文文件，你可以下载本书中的其他例子。文件名表示字符集。例如，`palindrome-utf8.txt`包含 UTF-8 输入。当读取一个宽流时，你必须确定你的 C++环境期望什么格式，并选择正确的文件。我的解决方案如清单 [59-3](#PC6) 所示。**

```
int main()
{
  std::locale::global(std::locale{""});
  std::wcin.imbue(std::locale{});
  std::wcout.imbue(std::locale{});

  std::wstring line{};
  while (std::getline(std::wcin, line))
    if (is_palindrome(std::wstring_view{line}))
      std::wcout << line << L'\n';
}

Listing 59-3.The main Program for Testing is_palindrome

```

从文件中读取宽字符或将宽字符写入文件不同于读取或写入窄字符。所有文件 I/O 都要经过一个额外的字符转换步骤。C++总是将文件解释为一系列字节。当读取或写入窄字符时，将字节转换为窄字符是不可行的，但是当读取或写入宽字符时，C++库必须解释字节以形成宽字符。它通过累加一个或多个相邻的字节来形成每个宽字符。决定哪些字节是宽字符的元素以及如何组合字符的规则由多字节字符集的编码规则指定。

## 多字节字符集

多字节字符集起源于亚洲，那里对字符的需求超过了单字节字符集(如 ASCII)中可用的少数字符位。欧洲国家设法将他们的字母表放入 8 位字符集中，但是像中文、日文、韩文和越南文这样的语言需要更多的位来表示成千上万的表意文字、音节和原生字符。

亚洲语言的需求刺激了使用两个字节来编码一个字符的字符集的发展——因此有了通用术语*双字节字符集* (DBCS)，并概括为*多字节字符集* (MBCS)。发明了许多 DBCSes，有时一个字符有多种编码。例如，在中文 Big 5 中，表意文字丁具有双字节值`"\xA4\x42"`。在 EUC-韩国字符集(在韩国很流行)中，相同的表意文字有不同的编码:`"\xEF\xCB"`。

典型的 DBCS 使用设置了最高有效位的字符(在一个 8 位字节中)来表示双字符。最高有效位清零的字符将取自单字节字符集(SBCS)。一些 DBC 委托特定的 SBCS；其他人则保持开放，因此 DBCS 和 SBCS 的不同组合会有不同的约定。在单个字符流中混合单字节和双字节字符对于表示混合亚洲和西方文本的字符流的常见用法是必要的。使用多字节字符比使用单字节字符更困难。例如，字符串的`size()`函数不会告诉你一个字符串中有多少个字符。您必须检查字符串的每个字节，以了解字符的数量。对字符串进行索引更加困难，因为您必须小心不要索引到双字节字符的中间。

有时，单个字符流比简单地在一个特定的 SBCS 和一个特定的 DBCS 之间切换需要更多的灵活性。有时流必须混合多个双字节字符集。ISO 2022 标准就是允许在其他辅助字符集之间转换的字符集的一个例子。*移位序列*(也称为*转义序列*，不要与 C++反斜杠转义序列混淆)决定使用哪个字符集。例如，ISO 2022-JP 在日本被广泛使用，并允许在 ASCII、JIS X 0201(SBCS)和 JIS X 0208(DBCS)之间切换。每行文本以 ASCII 开始，shift 序列在字符串中间改变字符集。例如，换档顺序`"\x1B$B"`切换到 JIS X 0208-1983。

在包含移位序列的文件或文本流中寻找任意位置显然是有问题的。一个必须在多字节文本流中查找的程序，除了流位置之外，还必须跟踪移位序列。如果不知道流中最近的移位序列，程序就无法知道用哪个字符集来解释后面的字符。

ISO 2022-JP 的许多变体允许附加的字符集。这里的重点不是提供关于亚洲字符集的教程，而是让您了解编写一个真正开放、通用和灵活的机制的复杂性，该机制可以支持世界上丰富多样的字符集和语言环境。这些以及类似的问题导致了 Unicode 项目的出现。

## 统一码

Unicode 试图通过将所有主要变体统一到一个大的、快乐的字符集来摆脱整个字符集的混乱。在很大程度上，Unicode 联合会取得了成功。Unicode 字符集已被采纳为 ISO 10646 的国际标准。然而，Unicode 项目不仅仅包括字符集；它还指定了大小写折叠、字符排序等规则。

Unicode 提供了 1114112 个可能的字符值(称为*代码点*)。到目前为止，Unicode Consortium 已经为字符分配了大约 100，000 个码位，因此还有很大的扩展空间。表示一百万个码位的最简单方法是使用 32 位整数，事实上，这是 Unicode 的一种常见编码。然而，这不是唯一的编码。Unicode 标准还定义了允许您使用一个或两个 16 位整数和一个或四个 8 位整数来表示代码点的编码。

表示 Unicode 码位的标准方式是 U+，后面跟一个至少有四位的十六进制数。因此，`'\x41'`是 U+0041(拉丁文大写 *A* )的 C++编码，希腊文π的码位是 U+03C0。音乐的八分音符具有代码点 U+266A 或 U+1d 160；前一个码位在一组杂七杂八的符号里，刚好包括一个八分音符。后一个代码点是一组音乐符号的一部分，您将需要它来处理任何与音乐相关的字符。

UTF-32 是将码位存储为 32 位整数的编码名称。要在 C++中表示 UTF-32 码位，在字符前面加上`U`(大写字母 *U* )。这样的字符文字有类型`char32_t`。例如，要表示字母 *A* ，用`U'A'`；对于小写希腊π，用`U'\x03c0'`；对于音乐的八分音符，使用`U'\x266a'`或`U'\x1d160'`。对字符串文字做同样的操作，标准库为一个字符串`char32_t`定义了类型`std::u32string`。例如，要表示字符π ≈ 3.14，请使用以下公式:

```
std::u32string pi_approx_3_14{ U"\x03c0 \x2248 3.14" };

```

另一种常见的 Unicode 编码使用一到四个 8 位单元组成一个码位。西欧语言中的常见字符通常可以用一个字节表示，其他许多字符只需要两个字节。不常用的字符需要三个或四个。结果是一种支持所有 Unicode 码位的编码，并且几乎总是比其他编码消耗更少的内存。这个字符集被称为 UTF-8。UTF-8 字符以普通字符文字的方式书写，以`u8`开头。UTF 8 字符串文字的类型是`char8_t`。一架 UTF-8 弦有`std:`式`:u8string`。

表示一个希腊字母π只需要两个字节，但是与 UTF-32 中的两个低位字节的值不同:`u8"\xcf\x80"`。第八个音符需要三或四个字节，同样使用不同于 UTF-32 的编码:`u8"\` `xe2\` `x99\xaa"`或`u8"\xf0\x9d\x85\xa0"`。

在程序中处理 UTF-8 的主要困难是，知道一个字符串中有多少代码点的唯一方法是扫描整个字符串。`size()`成员函数返回字符串中存储单元的数量，但是每个码位需要一到四个存储单元。另一方面，UTF-8 的优点是，您可以在 UTF-8 字节流中查找任意位置，并知道该位置是否在多字节字符的中间，因为多字节字符总是有其最高有效位集。通过检查编码，您可以判断一个字节是多字节字符的第一个字节还是后面的字节。

UTF-8 是文件和网络传输的常用编码。它已经成为许多桌面环境、文字处理器(包括我用来写这本书的那个)、网页和其他日常应用的事实上的标准。

其他一些环境使用 UTF-16，它用一个或两个 16 位整数表示一个码位。UTF-16 字符文本的 C++类型是`char16_t`，字符串类型是`std::u16string`。用`u`前缀(小写字母 *u* )写出这样一个字面值，比如`u'\x03c0'`。

Unicode 的设计者将最常见的代码点保留在较低的 16 位区域(称为*基本多语言平面*，或 BMP)。当一个码位在 BMP 之外，也就是它的值超过 U+FFFF 时，它需要两个 UTF-16 的存储单元，被称为*代理对*。例如，丁需要两个 16 位存储单元:`u"\` `xD834\` `xDD1E"`。

因此，您会遇到与 UTF-8 相同的问题，即一个存储单元不一定代表一个代码点，因此 UTF-16 作为内存中的表示法并不理想。但是大多数程序处理的绝大多数代码点都可以放在一个 UTF-16 存储单元中，所以 UTF-16 通常需要的内存是 UTF-32 的一半，而且在很多情况下，一个`u16string`的`size()`就是字符串中代码点的数量(虽然不扫描字符串你无法确定)。

一些程序员通过完全忽略代理对来解决使用 UTF-16 的困难。他们假设`size()`确实返回了字符串中代码点的数量，所以只有当所有代码点都来自 BMP 时，他们的程序才能正常工作。这意味着你失去了访问古代文字，专门的字母和符号，以及不常用的表意文字。

对于外部表示，UTF 8 比 UTF-16 和 UTF-32 编码有优势，因为您不必处理字节序。Unicode 标准定义了一种机制，用于编码和显示 UTF-16 或 UTF-32 文本流的字节序，但这只是为您做了额外的工作。

Note

最高有效字节的位置称为“字节序”“大端”平台是最高有效字节优先的平台。“小端”平台将最低有效字节放在最前面。流行的英特尔 x86 平台是小端的。

## 通用字符名称

Unicode 在 C++标准中又一次正式出现。您可以使用字符的 Unicode 码位来指定字符。使用`\uXXXX`或`\UXXXXXXXX`，用十六进制码位替换`XXXX`或`XXXXXXXX`。与`\x`转义不同，您必须在`\u`中使用四个十六进制数字，或者在`\U`中使用八个十六进制数字。这些字符结构被称为*通用字符名*。

因此，在字符串中对国际字符进行编码的更好方法是使用通用字符名。这有助于使你免受本地字符集的影响。另一方面，如果编译器无法将 Unicode 码位映射到本机字符，您就无法控制编译器的操作。因此，如果您的原生字符集是 ISO 8859-7(希腊语)，下面的代码应该用值`'\xf0'`初始化变量`pi`，但是如果您的原生字符集是 ISO 8859-1 (Latin-1)，编译器不能映射它，因此可能会给您一个空格或问号，或者编译器可能会拒绝编译它:

```
char pi{'\u03c0'};

```

还要注意`\u`和`\U`不是转义序列(不像`\x`)。您可以在程序中的任何地方使用它们，而不仅仅是在字符或字符串中。使用 Unicode 字符名称可以让您在不知道编码细节的情况下使用 UTF-8 和 UTF-16 字符串。因此，对于希腊文小写π，更好的 UTF-8 字符串写法是`u8"\` `u03c0"`，编译器会存储编码后的字节`"\xcf\x80"`。

如果你幸运的话，你将能够避免通用的角色名字。相反，您的工具将允许您直接编辑 Unicode 字符。该编辑器只是读取和写入通用字符名，而不是处理 Unicode 编码问题。因此，程序员编辑 WYSIWYG 国际文本，源代码保留了最大的可移植性。因为任何地方都允许通用字符名称，所以您也可以在注释中使用国际文本。如果你真的想玩得开心，试着在标识符名称中使用国际字母。不是所有的编译器都支持这个特性，尽管标准要求如此。因此，您应该编写一个声明

```
double π{3.14159265358979};

```

您的智能编辑器会在源文件中存储以下内容:

```
double \u03c0{3.14159265358979};

```

符合标准的编译器会接受它，并允许您使用π作为标识符。我不建议在标识符中使用扩展字符，除非你知道每个阅读你代码的人都在使用能够识别通用字符名的工具。否则，它们会使代码更难阅读、理解和维护。

你的编译器支持字符串中的通用字符名吗？_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _**你的编译器支持标识符中的通用字符名吗？**_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

## Unicode 困难

尽管 Unicode 有表面上的好处，但 C++支持仍然很少。虽然您可以编写 Unicode 字符文本和字符串文本，但是标准库没有提供有用的支持。试试这个练习:修改回文程序，用`char32_t`代替`wchar_t`。**会发生什么？**

*   _____________________________________________________________

没用的。Unicode 没有 I/O 流类。对于`char8_t`、`char16_t`或`char32_t`，不存在`isalnum`等的模板专门化。尽管标准库提供了一些在 Unicode 字符串和`wstring`之间进行转换的函数，但支持仅限于此。

如果你必须以任何有意义的方式使用国际字符，你需要一个第三方库。使用最广泛的库是 Unicode 国际组件(ICU)。请访问该书的网站获取最新链接。

第 3 部分的下一个也是最后一个主题是加深您对文本 I/O 的理解。****