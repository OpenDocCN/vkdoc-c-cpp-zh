# 11.增量和减量

本文介绍了增量(`++`)运算符，它在 C++语言中有多种用途。不奇怪，它有一个对应的递减值:`--`。这篇文章仔细研究了这些操作符，它们经常出现，是语言名称的一部分。

Note

我知道你 C，Java 等。自从我在探索 [7](07.html) 中写了`i = i + 1`之后，程序员们就一直在等待这种探索。正如你在探索 [9](09.html) 中看到的，在 C++中`++`操作符比你所熟悉的更有意义。所以我等到现在才讨论。

## 增量

操作符为 C、Java、Perl 和许多其他程序员所熟悉。c 是第一种广泛使用的语言，它引入这个运算符来表示“增量”或“加 1”C++扩展了它从 C 继承的用法；标准库以几种新的方式使用`++`操作符，比如推进迭代器。

增量运算符有两种形式:前缀和后缀。理解这两种风格之间区别的最好方法是进行演示，如清单 [11-1](#PC1) 所示。

```
import <iostream>;

int main()
{
  int x{42};

  std::cout << "x   = " << x   << "\n";
  std::cout << "++x = " << ++x << "\n";
  std::cout << "x   = " << x   << "\n";
  std::cout << "x++ = " << x++ << "\n";
  std::cout << "x   = " << x   << "\n";
}

Listing 11-1.Demonstrating the Difference Between Prefix and Postfix Increment

```

**预测程序的输出。**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

**实际产量是多少？**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

**解释前缀(** `++x` **)和后缀(** `x++` **)增量的区别。**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

简单来说，前缀运算符首先递增变量:表达式的值是递增后的值。后缀运算符保存旧值，递增变量，并将旧值用作表达式的值。

一般来说，使用前缀而不是后缀，除非你需要后缀的功能。这种差异很少是显著的，但是后缀运算符必须保存旧值的副本，这可能会带来很小的性能开销。如果不必使用后缀，为什么要付出那个代价呢？

## 减量

递增运算符有一个递减对应:`-` -。减量运算符是减一，而不是加一。减量也有前缀和后缀的味道。前缀运算符前减，后缀运算符后减。

您可以递增和递减任何数值类型的变量；然而，只有一些迭代器允许减量。

例如，输出迭代器只向前移动。您可以使用递增运算符(前缀或后缀)，但不能使用递减运算符。自己测试一下。编写一个使用`std::ostream_iterator`的程序，并尝试在迭代器上使用减量运算符。(如果你需要提示，请看清单 [10-3](10.html#PC3) 。将`ostream_iterator`对象保存在一个变量中。然后使用递减运算符。程序没意义没关系；无论如何它都不会通过编译器。)

您会得到什么样的错误信息？

*   _____________________________________________________________

*   _____________________________________________________________

不同的编译器发出不同的消息，但消息的本质应该是没有定义`--`运算符。如果你需要程序方面的帮助，请参见清单 [11-2](#PC2) 。

```
 1 import <algorithm>;
 2 import <iostream>;
 3 import <iterator>;
 4 import <ranges>;
 5 import <vector>;
 6
 7 int main()
 8 {
 9   std::vector<int> data;
10   std::ranges::copy(std::ranges::istream_view<int>(std::cin),
11                     std::back_inserter(std::cout));
12   std::ranges::sort(data);
13   std::ostream_iterator<int> output{ std::cout, "\n" };
14   --output;
15   std::ranges::copy(input, output);
16 }

Listing 11-2.Erroneous Program That Applies Decrement to an Output Iterator

```

在探索 [10](10.html) 的最后，你写了一个调用`std::ranges::reverse()`函数的程序。让我们来看看这个函数是如何工作的。提示:它使用递增和递减运算符。

与其他类似的算法一样，`std::ranges::reverse`函数接受一个 range 对象作为参数。它使用范围的 begin 迭代器和 end sentinel 来表示要反转的范围的界限。然后，大多数范围算法执行一点小技巧，将 end sentinel 转换为 end iterator。通过在范围的开始和结束之间创建一个对称，我们可以通过递增 begin 迭代器和递减 end 迭代器直到它们交叉路径来实现反转。其他算法不需要减少结束迭代器，但它们仍然是一个只有迭代器的函数，因为所有这些函数在 C++ 17 中都已经存在，所以通过调用 C++ 17 迭代器函数来实现 C++ 20 范围函数是很容易的。

## 成员类型

首先要注意的是,`int`向量的迭代器类型如下:

```
std::vector<int>::iterator

```

通常对对象的成员使用点(`.`)操作符，但是成员类型使用`::`(称为作用域操作符)，因为类型与对象不同。其他成员类型包括`size_type`，它是用于存储`size()`成员函数的值的类型。`value_type`成员类型是范围元素的类型；对于`vector`这样的容器，它是尖括号内的类型。

## 回到迭代器

知道您不需要键入成员类型的全名，您可能会松一口气。C++提供了一个快捷方式`auto`。当您不需要键入完整的类型名时，请使用`auto`作为类型，因为类型在上下文中是显而易见的。在这种情况下，`begin()`成员函数总是返回一个迭代器。原来`end()`也返回迭代器，所以我们不必学习如何将 sentinel 转换成迭代器。(这很简单，但是涉及到一些我们还没有涉及到的 C++。)在这种情况下，`end()`返回一个可以被透明地视为迭代器和哨兵的类型。

换句话说，您可以定义一个变量，称为`left`，它保存左侧迭代器，如下所示:

```
auto left{ data.begin() };

```

类似地，`right`保存右边的迭代器，它从向量的末尾开始:

```
auto right{ data.end() };

```

然而，有一点不同。`left`迭代器实际上指向了向量的一个元素(假设向量不为空)，而`right`没有。它指向一个结束标记。如果我们递减它，它将指向向量的最后一个元素(即`back()`)。

要获得迭代器指向的值，使用`*left`，这被称为*解引用*迭代器。因此，当以这种方式使用时，`*`操作符被称为*解引用操作符*。

`left`迭代器将递增，`right`迭代器将递减，直到它们相遇。这意味着我们希望 for 循环只要`left != right`不等于`right`就迭代，也就是说`left`不等于【】，或者它们不指向范围内的相同位置。使用迭代器时，一个常见的错误是不小心使用了解引用操作符并比较值，而不是比较位置。密切注意那些星号！

最后一步是知道如何反转两个元素，给定两个迭代器。最简单的方法是创建一个临时对象，如下所示:

```
auto temporary{ *left };
*left = *right;
*right = temporary;

```

当处理基本类型时，这可能是最快的选择。但是当您改变类型时，您不希望不得不重写您的代码。相反，使用 C++函数`std::iter_swap()`，它交换两个迭代器指向的值。它使用我还没有介绍过的功能实现了最佳效果:

```
std::iter_swap(left, right);

```

记住这个函数交换参数指向的值，并且不改变变量`left`和`right`的值。

你现在已经有了你需要的所有部分。**写一个程序，将整数读入一个向量，然后反转向量中元素的顺序(不调用标准库的 reverse 函数)，并打印结果。**

用偶数和奇数的整数测试你的程序。将您的程序与清单 [11-3](#PC8) 中的程序进行比较。

```
import <algorithm>;
import <iostream>;
import <iterator>;
import <ranges>;
import <vector>;

int main()
{
  std::vector<int> data{};
  std::ranges::copy(std::ranges::istream_view<int>(std::cin),
                    std::back_inserter(data));

  for (auto start{data.begin()}, end{data.end()}; start != end; /*empty*/)
  {
    --end;
    if (start != end)
    {
      std::iter_swap(start, end);
      ++start;
    }
  }

  std::ranges::copy(data, std::ostream_iterator<int>(std::cout, "\n"));
}

Listing 11-3.Reversing the Input Order

```

`start`迭代器指向`data`向量的开头，而`end`最初指向一个超过末尾的向量。如果向量为空，`for`循环终止，不执行循环体。然后循环体递减`end`，使其指向向量的一个实际元素。

请注意，程序会在每次递增后仔细比较`start != end`，并在每次递减操作后再次比较。如果程序只有一次比较，`start`和`end`就有可能互相通过。循环条件永远不会为真，程序会表现出未定义的行为，所以天会塌下来，地会吞下我，或者更糟。

还要注意`for`循环有一个空的后迭代部分。迭代逻辑出现在循环体的不同位置，这不是编写循环的首选方式，但在这种情况下是必要的。

您可以重写循环，这样后迭代逻辑只出现在循环头中。一些程序员认为，在循环体中分布增量和减量会使循环更难理解，尤其是更难证明循环正确终止。另一方面，把所有东西都塞进循环头会让循环条件变得特别难以理解，正如你在清单 [11-4](#PC9) 中看到的。

```
import <algorithm>;
import <iostream>;
import <iterator>;
import <ranges>;
import <vector>;

int main()
{
  std::vector<int> data{};
  std::ranges::copy(std::ranges::istream_view<int>(std::cin),
                    std::back_inserter(data));

  for (auto start{data.begin()}, end{data.end()};
       start != end and start != --end;
       ++start)
  {
      std::iter_swap(start, end);
  }

  std::ranges::copy(data, std::ostream_iterator<int>(std::cout, "\n"));
}

Listing 11-4.Rewriting the for Loop

```

为了在循环头中保留所有的逻辑，有必要使用一个新的操作符:`and`。在下一篇文章中，您将会学到更多关于这个操作符的知识；同时，只要相信它实现了一个逻辑`and`操作，继续读下去。

大多数有经验的 C++程序员可能更喜欢清单 [11-4](#PC9) ，而大多数初学者可能更喜欢清单 [11-3](#PC8) 。在条件中间隐藏减量会使代码更难阅读和理解。太容易忽略减量了。然而，随着你获得 C++的经验，你会对增量和减量更加适应，清单 [11-4](#PC9) 会开始让你喜欢。

Note

比起清单 [11-4](#PC9) ，我更喜欢清单 [11-3](#PC8) 。我真的不喜欢在复杂的条件中隐藏增量和减量操作符。

随着你对 C++了解的越来越多，你会发现这个程序的其他方面也需要改进。我鼓励你重温旧程序，看看你的新技术如何简化编程任务。当我在本书中重温这些例子时，我也会这样做。

清单 [11-4](#PC9) 引入了`and`操作符。下一篇文章将更仔细地研究这个操作符，以及其他逻辑操作符和它们在条件中的使用。