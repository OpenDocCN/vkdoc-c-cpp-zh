# 51.功能模板

您在 Exploration [25](25.html) 中看到，重载的魔力让 C++实现了绝对值函数的改进接口。取而代之的是三个不同的名字(`abs`、`labs`和`fabs`)，C++对所有三个函数都有一个名字。重载对需要调用`abs`函数的程序员有帮助，但对实现者帮助不大，实现者仍然必须编写三个外观和行为都相同的独立函数。如果库作者能写一次`abs`函数而不是三次，那不是很好吗？毕竟，这三个实现可能是相同的，只是返回类型和参数类型不同。本文介绍了这种称为泛型编程的编程风格。

## 通用函数

有时，您希望为整数和浮点类型提供重载函数，但实现本质上是相同的。绝对值就是一个例子；对于任何类型`T`，函数看起来都是一样的(我使用名称`absval`，以避免与标准库的`abs`混淆或冲突)，如清单 [51-1](#PC1) 所示。

```
T absval(T x)
{
  if (x < 0)
    return -x;
  else
    return x;
}

Listing 51-1.Writing an Absolute Value Function

```

将`T`替换为`int`，将`T`替换为`double`，或者使用任何其他数字类型。你甚至可以用`rational`代替`T`，而`absval`功能仍然按照你期望的方式工作。那么，为什么要浪费宝贵的时间编写、重写、再重写同一个函数呢？通过对函数定义的简单添加，您可以将函数转换为通用函数，也就是说，可以与任何合适的类型`T`一起工作的函数，这可以在清单 [51-2](#PC2) 中看到。

```
template<class T>
T absval(T x)
{
  if (x < 0)
    return -x;
  else
    return x;
}

Listing 51-2.Writing a Function Template

```

第一行是关键。`template`关键字意味着后面是一个模板，在这种情况下，是一个*函数模板*定义。尖括号分隔了以逗号分隔的模板参数列表。函数模板是根据参数类型`T`创建函数的模式。在函数模板定义中，`T`代表一个类型，可能是任何类型。`absval`函数的调用者决定了将替代`T`的模板参数。

定义函数模板时，编译器会记住该模板，但不会生成任何代码。编译器会一直等到你使用函数模板，然后生成一个真正的函数。可以想象一下，编译器获取模板的源文本，用模板参数(如`int`)替换模板参数`T`，然后编译结果文本。下一节将告诉您更多关于如何使用函数模板的内容。

## 使用函数模板

使用函数模板很容易，至少在大多数情况下是如此。只需调用`absval`函数，编译器会根据函数参数类型自动确定模板参数。你可能需要一点时间来熟悉模板参数和模板实参的概念，它们与函数形参和函数实参有很大的不同。

在`absval`的情况下，模板参数是`T`，模板实参必须是类型。不能将类型作为函数参数传递，但模板是不同的。你在程序中并没有真正“传递”任何东西。模板魔术发生在编译时。编译器看到了`absval`的模板定义，然后看到了`absval`函数模板的调用。编译器检查函数参数的类型，并根据函数参数的类型确定模板参数。编译器用模板参数替换`T`，并生成一个新的`absval`函数实例，为模板参数类型定制。因此，在下面的例子中，编译器发现`x`具有类型`int`，所以它用`int`替换`T`。

```
int x{-42};
int y{absval(x)};

```

编译器生成一个函数，就像库实现者编写了以下代码一样:

```
int absval(int x)
{
  if (x < 0)
    return -x;
  else
    return x;
}

```

后来，在同一个程序中，也许你在一个`rational`对象上调用`absval`:

```
rational r{-420, 10};
rational s{absval(r)};

```

编译器生成一个新的`absval`实例:

```
rational absval(rational x)
{
  if (x < 0)
    return -x;
  else
    return x;
}

```

在这个新的`absval`实例中，`<`操作符是接受`rational`参数的重载操作符。求反操作符也是一个定制操作符，它接受一个`rational`参数。换句话说，当编译器生成一个`absval`的实例时，它通过编译源代码来完成，就像模板作者写的那样。

编写一个包含`absval`函数模板定义和一些测试代码的示例程序，用各种参数类型调用`absval`。让自己相信函数模板确实有效。在清单 [51-3](#PC7) 中将你的测试程序与我的进行比较。

```
import <iostream>;
import rational;  // Listing 49-10

template<class T>
T absval(T x)
{
  if (x < 0)
    return -x;
  else
    return x;
}

int main()
{
  std::cout << absval(-42) << '\n';
  std::cout << absval(-4.2) << '\n';
  std::cout << absval(42) << '\n';
  std::cout << absval(4.2) << '\n';
  std::cout << absval(-42L) << '\n';
  std::cout << absval(rational{42, 5}) << '\n';
  std::cout << absval(rational{-42, 5}) << '\n';
  std::cout << absval(rational{42, -5}) << '\n';
}

Listing 51-3.Testing the absval Function Template

```

## 编写函数模板

编写函数模板比编写普通函数更难。当你写一个像`absval`这样的模板时，问题是你不知道`T`实际上会是什么类型。所以，函数必须是通用的。编译器会阻止你使用某些类型的`T`。模板体使用`T`的方式隐含了它的限制。

特别是，`absval`对`T`施加了以下限制:

*   `T` *必须是可复制的。*这意味着你必须能够复制一个类型为`T`的对象，这样参数可以传递给函数，结果可以返回。如果`T`是一个类类型，那么这个类必须有一个可访问的复制构造函数，也就是说，复制构造函数不能是私有的。

*   `T` *必须与* `0` *可比使用* `<` *运算符*。您可能会重载`<`操作符，或者编译器会将`0`转换为`T`或将`T`转换为`int`。

*   *必须为* `T`类型的操作数定义一元 `operator-` *。结果类型必须是`T`或者编译器可以自动转换成`T`的类型。*

内置的数值类型都符合这些要求。`rational`类型也符合这些要求，因为它支持自定义操作符。举例来说，`string`类型没有，因为当右边的操作数是整数时，它缺少比较运算符，并且它缺少一元求反(`-`)运算符。假设你试图在一个`string`上呼叫`absval`。

```
std::string test{"-42"};
std::cout << absval(test) << '\n';

```

你认为会发生什么？

*   _____________________________________________________________

*   _____________________________________________________________

试试看。到底发生了什么？

*   _____________________________________________________________

*   _____________________________________________________________

编译器抱怨缺少`std::string`的比较和求反运算符。使用模板时，传递有用的错误消息的一个困难是，是给出使用模板的行号，还是给出模板定义中的行号。有时候，你会两者兼得。有时，除非您尝试使用模板，否则编译器无法报告模板定义中的错误。它可以立即报告其他错误。**仔细阅读清单** [**51-4**](#PC9) **。**

```
template<class T>
T add(T lhs, T rhs)
{
  return lhs(rhs);
}

int main()
{
}

Listing 51-4.Mystery Function Template

```

**错误是什么？**

_____________________________________________________________

你的编译器会报告它吗？

_____________________________________________________________

因为编译器不知道类型`T`，所以无法判断`lhs(rhs)`是什么意思。可以定义一个表达式有效的类型，但是这可能与`add`的函数名不匹配。我们知道我们想要对`T`使用数值类型，所以`lhs(rhs)`是愚蠢的。毕竟`3(4)`是什么意思？

如何让你的编译器报告错误？

_____________________________________________________________

添加一行代码来使用模板。例如，将此添加到`main`:

```
return add(0, 0);

```

现在，每个编译器都会在模板定义中报告不是真正的函数调用表达式。

## 模板参数

每当你在一个 C++程序中看到`T`，很可能你正在看一个模板。向后查看源文件，直到找到模板头，也就是以`template`关键字开始的声明部分。这就是你应该找到模板参数的地方。使用`T`作为模板参数名仅仅是一个惯例，但是它的使用几乎是普遍的。使用`class`来声明`T`可能看起来有点奇怪，尤其是因为您已经看到了几个模板参数实际上不是一个类的例子。

有些程序员不使用`class`来声明模板参数类型，而是使用另一个关键字`typename`，在这个上下文中意思是一样的。`typename`相对于`class`的优势在于它避免了对非类类型的任何混淆。缺点是`typename`在模板上下文中有不止一种用法，这会在更复杂的模板定义中混淆人类读者。学会阅读这两种风格，但我在编写自己的模板时更喜欢使用`class`，而且在大多数 C++代码中`class`比`typename`出现得更频繁。

有时候，你会看到比`T`更具体的参数名。如果模板有多个参数，那么每个参数都必须有一个惟一的名称，所以您肯定会看到除了`T`之外的名称。例如，`std::ranges::copy`算法是一个带有两个模板参数的函数模板:输入范围类型和输出迭代器类型。因此，`copy`的定义可能类似于清单 [51-5](#PC11) 。

```
template<class InputRange, class OutputIterator>
OutputIterator copy(InputRange range, OutputIterator output)
{
  for (auto const& item : range)
    *output++ = item;
  return output;
}

Listing 51-5.One Way to Implement the copy Algorithm

```

很简单，不是吗？(真正的`copy`函数更复杂，需要检查有效的参数并对某些类型进行优化。然而，在复杂性之下，可能是一个看起来像清单 [51-5](#PC11) 的函数，尽管有不同的参数名。)

使用`copy`算法时，编译器根据函数参数类型确定`InputRange`和`OutputIterator`的值。正如您在`absval`中看到的，函数对模板参数的要求都是隐式的。因为`InputRange`必须是一个范围，`std::ranges::begin(range)`必须返回起始迭代器，`std::ranges::end(range)`必须返回哨兵。起始迭代器必须满足输入迭代器的要求，即运算符`*`返回一个项，`operator++`推进迭代器，迭代器必须与 sentinel 具有可比性。`OutputIterator`也必须以输出迭代器的方式实现`*`和`++`。

**写一个** `find` **算法的简单实现。**这个算法的范围形式提出了一些棘手的问题，所以让我们实现函数的迭代器形式。(好奇的话想一下`find()`的区间版。它的返回类型是什么？模板参数是范围类型，`std::ranges::begin()`返回一个迭代器，这是`find()`想要的返回类型。但是如果没有找到这个值，`find()`必须返回`std::ranges::end()`的标记值，即使它有不同的类型。所以`find()`必须将 sentinel 值转换成迭代器类型。在接下来的探索中，您将了解更多关于模板的知识，这将帮助您掌握这些问题。现在我们回到`find()`的迭代器形式。)

模板有两个参数:`InputIterator`和`T`。该函数有三个参数。前两个类型为`InputIterator`,指定了要搜索的范围。第三个参数的类型是`T`，是要搜索的值。将您的解决方案与清单 [51-6](#PC12) 进行比较。

```
template<class InputIterator, class T>
InputIterator find(InputIterator start, InputIterator end, T value)
{
  for ( ; start != end; ++start)
      if (*start == value)
          return start;
  return end;
}

Listing 51-6.Implementing the find Algorithm

```

许多标准算法本质上都很简单。现代的实现经过了大量的优化，手动优化代码的本质就是这样，结果通常与原始代码几乎没有相似之处，并且优化后的代码可能更难阅读。尽管如此，简单性仍然保留在标准库的架构中，它广泛依赖于模板。

## 模板参数

当编译器自动从函数参数中推导出模板参数时，模板是最容易使用的。然而，它不能总是这样做，所以你可能必须明确地告诉编译器你想要什么。例如，`min`、`max`和`mixmax`标准算法的简单形式采用单个模板参数。清单 [51-7](#PC13) 显示了`min`功能的一种可能实现，以供参考。

```
template<class T>
T min(T a, T b)
{
  if (b < a)
    return b;
  else
    return a;
}

Listing 51-7.The std::min Algorithm

```

如果两个参数类型相同，编译器可以推导出所需的类型，一切都正常了。

```
int x{10}, y{20}, z{std::min(x, y)};

```

另一方面，如果函数参数类型不同，编译器就不能判断模板参数使用哪种类型。

```
int x{10};
long y{20};
std::cout << std::min(x, y); // error

```

为什么会这样？假设您编写了自己的函数作为非模板。

```
long my_min(long a, long b)
{
  if (b < a)
    return b;
  else
    return a;
}

```

编译器可以通过将`x`从`int`转换为`long`来处理`my_min(x, y)`。但是，作为模板，编译器不执行任何自动类型转换。编译器无法理解您的想法，也不知道您希望模板参数具有第一个函数参数或第二个函数参数的类型，或者有时是第一个，有时是第二个。相反，编译器要求你确切地写出你的意思。在这种情况下，您可以通过将所需的类型括在尖括号中来告诉编译器模板参数使用什么类型。

```
int x{10};
long y{20};
std::cout << std::min<long>(x, y); // okay: compiler converts x to type long

```

如果模板有多个参数，请用逗号分隔参数。例如，清单 [51-8](#PC18) 显示了`input_sum`函数，它从标准输入中读取项目，并通过`+=`操作符累加它们。累加器的类型可以不同于项目类型。因为函数参数中没有使用 item 和 accumulator 类型，所以编译器无法推断出参数参数，所以您必须显式地提供它们。

```
import <iostream>;

template<class T, class U>
U input_sum(std::istream& in)
{
  T x{};
  U sum{0};
  while (in >> x)
    sum += x;
  return sum;
}

int main()
{
  long sum{input_sum<int, long>(std::cin)};
  std::cout << sum << '\n';
}

Listing 51-8.Multiple Template Arguments

```

**写一个函数，isprime，做一个函数模板**，这样就可以对`int`、`short`或者`long`参数使用同一个函数模板。该函数确定其参数是否为质数，即只能被 1 及其自身整除的数。将您的解决方案与清单 [51-9](#PC19) 中的我的解决方案进行比较。

```
template<class T>
bool isprime(T n)
{
    if (n < 2)
        return false;
    else if (n <= 3)
        return true;
    else if (n % 2 == 0)
        return false;
    else
    {
        for (T test{3}, limit{n / 2}; test < limit; test += 2)
            if (n % test == 0)
                return false;
        return true

;
    }
}

Listing 51-9.The isprime Function Template

```

## 缩写函数模板

编写某些模板的一个更短的方法是使用`auto`关键字作为函数参数类型，类似于它可以用来定义局部变量的方式。对任何函数参数类型使用`auto`会将函数变成函数模板。每个`auto`参数就像添加一个模板参数。例如，您可以使用`auto`重写清单 [51-5](#PC11) ，如清单 [51-10](#PC20) 所示。

```
auto copy(auto range, auto output)
{
  for (auto const& item : range)
    *output++ = item;
  return output;
}

Listing 51-10.Another Way to Implement the copy Algorithm

```

返回类型也是`auto`，它告诉编译器从函数中的`return`语句确定返回类型。在这种情况下，返回类型与`output`参数的类型相同，这正是我们想要的。

对于`copy`(清单 [51-6](#PC12) )的迭代器形式，使用`auto`要困难得多，因为每个`auto`函数参数都有一个单独的模板参数作为其类型。强制两个参数具有相同的类型是普通函数模板最容易做到的。但是，当一个函数模板的每个函数参数都有一个单独的模板参数时，缩写形式可能是编写函数模板的一种简洁方式。

## 声明和定义

我似乎不能停止谈论声明和定义。模板给这个情节带来了另一个转折。使用模板时，规则会发生变化。在使用函数模板之前，编译器必须看到的不仅仅是一个声明。编译器通常需要完整的函数模板定义。换句话说，如果你在一个模块中定义一个模板，那么这个模块必须包含这个函数模板的主体。假设您想在多个项目中共享`isprime`函数。通常，您会将函数声明放在一个模块中，比如说`prime`，并且您可能想要一个单独的模块实现。

然而，当你将`isprime`转换成一个函数模板时，你必须将定义放在模块接口中，这样编译器就可以从模板中创建具体的函数，比如说，为`isprime<int>`或`isprime<long>`创建函数。

## 成员函数模板

在探索 [36](36.html) 中，我们为`rational`类编写了三个几乎相同的函数:`to_long_double`、`to_double`和`to_float`。它们都做同样的事情:在转换成目标类型后，将分子除以分母。每当有多个函数以相同的方式使用相同的代码做相同的事情时，就有了一个候选模板，如下所示:

```
template<class T, class R>
T convert(R const& r)
{
  return static_cast<T>(r.numerator()) / r.denominator();
}

```

与任何函数模板一样，`R`上唯一的要求是类型为`R`的对象具有名为`numerator()`和`denominator()`的成员函数，并且这些函数具有适用于`operator/`的返回类型(可以重载)。要使用`convert`函数，您必须提供目标类型`T`，作为显式模板参数，但是您可以让编译器从函数参数中推导出`R`:

```
rational r{42, 10};
double d{ convert<double>(r) };

```

您可以从最右边的参数开始，省略编译器可以推导出的模板参数。正如您在本文前面所看到的，如果编译器可以推导出所有的参数，那么您可以完全省去尖括号。

函数模板也可以是成员函数。您可能更喜欢使用成员函数模板，而不是将`rational`对象作为参数传递，如下所示:

```
rational r{42, 10};
double d{ r.convert<double>() };

```

成员函数模板避免了与其他可能被命名为`convert`的自由函数的冲突。但是它也限制了你的函数的效用。作为一个非成员函数(也称为自由函数)，它适用于任何看起来像有分子和分母的有理数类型的类型。即使是你没见过的类型，只要满足 convert()函数的基本限制，就可以了。但是作为一个成员函数，它不可避免地与您的 rational 类型而不是其他人的类型联系在一起。您将会看到标准 C++库有许多免费的函数，这些函数被设计用来处理各种用户编写的类型。这是非常好的设计。

泛型编程是一种强大的技术，随着您在接下来的几篇文章中对它了解得越来越多，您将会看到这种编程范式是多么的有表现力和有用。