# 10.算法和范围

前面的探索介绍了使用`std::ranges::sort`对整数向量进行排序的向量和范围。这种探索更深入地研究了范围，并介绍了更通用的算法，这些算法对对象范围执行有用的操作。

## 算法

`std::ranges::sort`函数是通用算法的一个例子，之所以这样命名是因为这些函数实现了通用算法并进行通用操作。也就是说，它们适用于任何可以表示为一系列值的东西。大多数标准算法都是在`<algorithm>`头中声明的，尽管`<numeric>`头包含一些面向数字的算法。

标准算法运行所有常见的编程活动:排序、搜索、复制、比较、修改等等。搜索可以是线性的或二进制的。包括`std::ranges::sort`在内的许多函数对序列中的元素进行重新排序。不管它们做什么，几乎所有的通用算法都有一些共同的特征。(一些算法，如`std::max`、`std::min`和`std::minmax`，对数值而不是范围进行操作。)范围有不同的风格，取决于迭代器的类型和范围数据的性质。

vector 是一个*大小的*范围的例子，也就是说，一个 C++库可以在常量时间内确定大小的范围。假设一个程序定义了从文件中读取的文本行的范围；无法预先知道行数，因此这样的范围不可能是大小合适的范围。

范围的风格也取决于迭代器的类型。C++有六种不同的迭代器，但是你可以把它们大致分为两类:读和写。

*read* 迭代器指的是值序列中的一个位置，它允许从序列中读取。大多数算法需要一个带有相应标记的读迭代器来获取输入数据。有些算法是只读的，有些算法可以修改迭代值。

大多数算法还需要一个*写*迭代器，通常称为*输出*迭代器。大多数算法只使用单一输出迭代器，而不使用输出范围。这是因为输出范围的大小不一定是已知的，直到算法已经在其输入上运行了它的过程。

如果调整了输入范围的大小，算法可以使用该信息来设置输出范围的大小，但并非所有输出范围都调整了大小。例如，将一个向量的值写入输出流有一个大小合适的输入，但没有一个大小合适的输出。为了保持算法的通用性，它们很少要求一定大小的范围作为输入，也很少接受一个范围作为输出。

因为典型的算法不会也不能检查输出迭代器的溢出，所以必须确保输出序列有足够的空间来容纳算法将要写入的所有内容。

例如，`std::ranges::copy`算法将输入范围中的值复制到输出迭代器中。该函数有两个参数:输入范围和输出迭代器。您必须确保输出有足够的容量。调用`resize`成员函数来设置输出向量的大小，如清单 [10-1](#PC1) 所示。

```
#include <cassert>
import <algorithm>;
import <vector>;

int main()
{
  std::vector<int> input{ 10, 20, 30 };
  std::vector<int> output{};
  output.resize(input.size());
  std::ranges::copy(input, output.begin());
  // Now output has a complete copy of input.
  assert(input == output);
}

Listing 10-1.Demonstrating the std::ranges::copy Function

```

`assert`函数是一种快速验证你认为是真的东西实际上是真的方法。你断言一个逻辑语句，如果你错了，程序终止，并给出一条消息来标识这个断言。`assert`函数的声明不同于标准库的其余部分，使用了`#include <cassert>`而不是`import`。`c`意味着 C++库从 C 标准库继承了这个头文件，`#include`是 C 导入声明的方式。请注意，`assert`是标准库成员以`std::`开头的罕见例外之一。

如果程序是正确的，它正常运行和退出。但是如果我们犯了一个错误，断言就会触发，程序就会失败并显示一条消息。

**测试清单** [**中的程序 10-1**](#PC1) **。**看看断言失败时会发生什么，**注释掉对** `std::ranges::copy` **的调用，并再次运行它。写下你得到的信息。**

*   _____________________________________________________________

*   _____________________________________________________________

还要注意`input`的初始化。清单 [10-1](#PC1) 展示了“通用初始化”的另一个应用(如探索 [4](04.html) 中所介绍的)。花括号内的逗号分隔值用于初始化向量的元素。

## 输出迭代器

如果输出是一个向量，能够调用`resize()`是好的，但是您也可以使用输出迭代器将值写入文件或控制台。获取一个输出文件，比如`std::cout`，并构造一个`std::ostream_iterator<int>{std::cout}`对象，将它转换成一个输出迭代器，输出`int`的值。(使用`import <iterator>`获得迭代器相关声明的声明。)更好的是，您可以将一个字符串作为第二个参数传递，迭代器在它写入的每个值之后都会写入该字符串。**复制清单** [**9-1**](09.html#PC1) **并用调用将数据复制到标准输出的** `copy()` **函数替换输出循环。**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

将您的程序与清单 [10-2](#PC2) 进行比较。

```
import <algorithm>;
import <iostream>;
import <iterator>;
import <vector>;

int main()
{
  std::vector<int> data;
  int element;
  while (std::cin >> element)
    data.emplace_back(element);

  std::ranges::sort(data);

  std::ranges::copy(data, std::ostream_iterator<int>{std::cout, "\n"});
}

Listing 10-2.Demonstrating the std::ostream_iterator Class

```

正如您可以使用`ostream_iterator`将一个范围写入标准输出，您也可以使用标准库将值从标准输入直接读入一个范围。你认为这门课叫什么？

*   _____________________________________________________________

猜得好，但是记住输入是一个范围，输出只是一个迭代器。如果把输入当作一个范围的类的名字是`std::input_range`不是很好吗？但名字其实是`std::ranges::istream_view`。*视图*是一种易于复制或分配的范围。通过将这种类型命名为视图，它告诉你可以分配一个`istream_view`变量而不会导致运行时损失。

现在的工作是使用`std::ranges::copy()`函数将一系列`int`值从`std::cin`复制到`data`向量。但是这里我们遇到了一个问题，即设置`data`的大小以匹配输入值的数量。`emplace_back()`函数扩展了向量的大小以容纳新值，那么我们如何安排为从`istream_view`中读取的每个元素调用`emplace_back()`？

答案是一种特殊的输出迭代器，叫做`std::back_inserter`。将`data`作为参数传递给`back_inserter`，写入输出迭代器的每个值都被添加到`data`的末尾。现在你已经有了需要重写的清单 [10-2](#PC2) ，这样它就不包含任何循环，而是使用范围函数调用来完成所有的工作。

*   _______________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

在清单 [10-3](#PC3) 中比较你的程序和我的程序。

```
 1 import <algorithm>;
 2 import <iostream>;
 3 import <iterator>;
 4 import <ranges>;
 5 import <vector>;
 6
 7 int main()
 8 {
 9   std::vector<int> data;
10   std::ranges::copy(std::ranges::istream_view<int>(std::cin),
11                     std::back_inserter(data));
12   std::ranges::sort(data);
13   std::ranges::copy(data, std::ostream_iterator<int>{std::cout, "\n"});
14 }

Listing 10-3.Demonstrating the std::back_inserter Function

```

丑陋的 C++真相:有时需要括号有时需要花括号有时需要尖括号有时需要方括号。你怎么知道什么时候用什么？通过记忆语言和库的规则。好吧，没那么糟。方括号用于下标，尖括号用于类型。但是圆括号和花括号可能会让人非常困惑。

在 Exploration [2](02.html) 中，我让你在初始化变量时使用花括号。在动态创建对象(如迭代器)时，也是如此。例如，您可以创建一个`ostream_iterator`对象并将其传递给一个函数，比如`copy`。因为您正在创建一个对象，所以应该使用花括号。但是`back_inserter`呢？它实际上是一个函数，使用它的参数创建并返回一个`back_insert_iterator`对象。通过使用其参数(`data`)的类型(`std::vector<int>`),`back_inserter()`可以创建正确类型的`back_insert_iterator`对象。这种复杂性的结果是，你需要记住什么是函数，什么是类型。

标准库包含了太多的函数，这里就不再赘述了。只是为了体验一下什么是可用的，将第 13 行的`copy`函数改为`unique_copy`。你认为这会如何改变程序的行为？

*   _____________________________________________________________

*   _____________________________________________________________

试试看。如果您看不出任何差异，**尝试以下输入**:

```
10 42 3 1 42 5 3 10 3

```

现在你可以看到当一个数字重复时,`unique_copy`只复制一个值。因此，您应该会看到前面输入的以下输出:

```
1
3
5
10
42

```

我们再试试一个函数。不叫`sort()`，叫`reverse()`。一定要把`unique_copy()`改回`copy()`，因为`unique_copy()`只有在输入排序后才能正常工作。名字 reverse 告诉你从程序中可以得到什么。**试试看，确保你理解了。和我一样的投入，你得到了什么？**

```
3
10
3
5
42
1
3
42
10

```

在探索 [9](09.html) 中，在引入远程`for`循环之前，我向你扔了一个丑陋的`for`循环只是为了吓唬你。是时候开始分解那些丑陋的代码，并理解各个部分的含义了。下一篇文章将仔细研究方便的增量(`++`)操作符。