# 5.简单输入

到目前为止，探索主要集中在产量上。现在是时候把注意力转向输入了。给定输出操作符是`<<`，**你期望输入操作符是什么？**_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

这不用火箭科学家来推断，是吗？输入操作符是`>>`，输出操作符的反方向。可以把操作符想象成指向信息流动方向的箭头:从输入流到变量，或者从变量到输出流。

清单 [5-1](#PC1) 显示了一个执行输入和输出的简单程序。

```cpp
import <iostream>;

int main()
{
   std::cout << "Enter a number: ";
   int x;
   std::cin >> x;
   std::cout << "Enter another number: ";
   int y;
   std::cin >> y;

   int z{x + y};
   std::cout << "The sum of " << x << " and " << y << " is " << z << "\n";
}

Listing 5-1.Demonstrating Input and Output

```

**清单** [**5-1**](#PC1) **从标准输入中读取多少个数字？**_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

假设您输入`42`和`21`作为两个输入值。**你对产量有什么期望？**

*   _____________________________________________________________

现在运行程序，检查你的预测。希望你拿到了`63`。假设您键入以下内容作为输入:

```cpp
42*21

```

你预测会有什么样的产出？

*   _____________________________________________________________

测试你的假设。**实际产量是多少？**

*   _____________________________________________________________

你看到发生了什么吗？如果没有，尝试将`xyz`作为程序的输入。试试`42-21`。试试`42.21`。

这个程序展示了两个你必须理解的不同的行为。首先，要读取一个`int`，输入流必须包含一个有效的整数。整数可以以符号(`-`或`+`)开头，但其后必须全是数字；不允许中间有空白。当输入操作到达不能作为有效整数一部分的第一个字符(如`*`)时，输入操作停止。如果从输入流中读取了至少一个数字，则读取成功，输入文本被转换为整数。如果输入流不是以有效的整数开头，则读取失败。如果读取失败，则不修改输入变量。

第二种行为是你在之前的探索中发现的；未初始化的`int`变量导致未定义的行为。换句话说，如果读取失败，变量包含垃圾，或者更糟。例如，当您学习浮点数时，您将了解到未初始化的浮点变量中的一些位模式会导致程序终止。在一些专门的硬件上，未初始化的整数也可以做到这一点。这个故事的寓意是，使用未初始化的变量会导致未定义的行为。那很糟糕。所以不要做。

因此，当输入为`xyz`时，两次读取都失败，并导致未定义的行为。您可能会看到这两个数字的垃圾值。当输入为`42-21`时，第一个数字为`42`，第二个数字为`-21`，所以结果是正确的。但是当输入的是`42.21`时，第一个数字是`42`，第二个数字是垃圾，因为整数不能以点开头(`.`)。

一旦输入操作失败，所有后续的输入尝试也将失败，除非您采取补救措施。这就是为什么如果第一个数字无效，程序不会等待你输入第二个数字。C++可以告诉你什么时候输入操作失败，所以你的程序可以避免使用垃圾值。此外，您可以重置流的错误状态，以便在处理错误后继续读取。我将在以后的探索中介绍这些技术。现在，确保您的输入是有效和正确的。

当你的程序没有初始化变量时，一些编译器会警告你，但是为了安全起见，最好始终初始化每个变量。如您所见，即使程序立即尝试在变量中存储一个值，也可能不会成功，这可能会导致意外的行为。

你想过整数会这么复杂吗？当然，字符串更简单，因为不需要解释它们或转换它们的值。让我们看看它们是否真的比整数简单。清单 [5-2](#PC3) 类似于清单 [5-1](#PC1) ，但是它将文本读入`std::string`变量。

```cpp
import <iostream>;
import <string>;

int main()
{
   std::cout << "What is your name? ";
   std::string name{};
   std::cin >> name;
   std::cout << "Hello, " << name << ", how are you? ";
   std::string response{};
   std::cin >> response;
   std::cout << "Good-bye, " << name << ". I'm glad you feel " << response << "\n";
}

Listing 5-2.Reading Strings

```

清单 [5-2](#PC3) 显然不是人工智能的模型，但它很好地演示了一件事。假设输入如下:

```cpp
Ray Lischner
Fine

```

你期望的结果是什么？

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

运行程序，测试你的假设。你是对的吗？_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

**解释。**

*   _____________________________________________________________

*   _____________________________________________________________

尝试不同的输入，并尝试辨别 C++用来在输入流中分隔字符串的规则。准备好了吗？去吧。我会一直等到你做完。

这么快就回来了？C++如何在输入流中分隔字符串？

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

任何空白字符(空白字符的确切列表取决于您的实现，但通常包括空格、制表符、换行符等)都会结束一个字符串，至少就输入操作而言是这样。具体来说，C++跳过前导空白字符。然后它累积非空格字符形成字符串。字符串在下一个空白字符处结束。

那么当你混合整数和字符串时会发生什么呢？编写一个程序，要求输入一个人的名字(仅名字)和年龄(年龄)，然后将输入回显到标准输出中。你想先要哪个？阅读后打印信息。

表 [5-1](#Tab1) 显示了您的程序的一些样本输入。在每一个旁边，**写下你对程序输出的预测。**然后运行程序，**写出实际输出。**

表 5-1。

姓名和年龄的输入示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

投入

 | 

预测产量

 | 

实际输出

 |
| --- | --- | --- |
| `Ray44` |   |   |
| `44Ray` |   |   |
| `Ray 44` |   |   |
| `44 Ray` |   |   |
| `Ray44` |   |   |
| `44Ray` |   |   |
| `44-Ray` |   |   |
| `Ray-44` |   |   |

把标准输入想象成一串字符。不管用户如何输入这些字符，程序都会看到它们一个接一个地出现。(好吧，它们通过缓冲区负载大量到达，但这是一个次要的实现细节。就你而言，你的程序一次读取一个字符，这个字符来自缓冲区，而不是实际的输入设备，这并不重要。)因此，程序总是保持流中当前位置的概念。下一个读取操作总是从该位置开始。

在开始任何输入操作之前，如果输入位置处的字符是空白字符，则程序跳过(即，读取并丢弃)该字符。它一直读取并丢弃字符，直到到达一个非空格字符。然后开始实际的读取。

如果程序试图读取一个整数，它会在输入位置抓取字符，并检查它对一个整数是否有效。否则，读取失败，并且输入位置不移动。否则，输入操作将保留该字符和所有后续字符，它们是整数的有效元素。输入操作将文本解释为整数，并将值存储在变量中。因此，在读取一个整数后，您知道输入位置指向的字符是*而不是*一个有效的整数字符。

读取字符串时，从流中抓取所有字符，直到到达一个空白字符。因此，字符串变量不包含任何空白字符。如前所述，下一个读操作将跳过空白。

当用户关闭控制台或终端时，或者当用户键入特殊的击键序列来告诉操作系统结束输入时(如 UNIX 上的 Ctrl+D 或 DOS 或 Windows 上的 Ctrl+Z)，输入流在文件的末尾结束(如果从文件中读取)。一旦到达输入流的末尾，所有后续的读取尝试都将失败。这就是导致循环在探索 [2](02.html) 中结束的原因。

清单 [5-3](#PC5) 显示了我的名字优先程序版本。当然，你们的计划在细节上会有所不同，但基本大纲应该与你们的一致。

```cpp
import <iostream>;
import <string>;

int main()
{
   std::cout << "What is your name? ";
   std::string name{};
   std::cin >> name;

   std::cout << "Hello, " << name << ", how old are you? ";
   int age{};
   std::cin >> age;

   std::cout << "Good-bye, " << name << ". You are " << age << " year";
   if (age != 1)
      std::cout << 's';
   std::cout << " old.\n";
}

Listing 5-3.Getting the User’s Name and Age

```

现在修改程序，颠倒姓名和年龄的顺序，再次尝试所有输入值。解释你观察到的现象。

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

当输入操作由于畸形输入而失败时，流进入错误状态；例如，当程序试图读取一个整数时，输入流包含字符串“Ray”。所有后续读取流的尝试都会导致错误，而不会真正尝试读取。即使流随后尝试读取一个字符串(否则会成功),错误状态也是粘滞的，字符串读取也会失败。

换句话说，当程序不能读取用户的年龄时，它也不能读取名字。这就是为什么程序会把名字和年龄都写对，或者都写错。

清单 [5-4](#PC6) 显示了我版本的年龄优先计划。

```cpp
import <iostream>;
import <string>;

int main()
{
   std::cout << "How old are you? ";
   int age{};
   std::cin >> age;

   std::cout << "What is your name? ";
   std::string name{};
   std::cin >> name;

   std::cout << "Good-bye, " << name << ". You are " << age << " year";
   if (age != 1)
      std::cout << 's';
   std::cout << " old.\n";
}

Listing 5-4.Getting the User’s Age and Then Name

```

表 [5-2](#Tab2) 显示了每种情况下输出的截断版本(只有姓名和年龄)。

表 5-2。

用 C++方式解释输入

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

投入

 | 

先说名字

 | 

年龄第一

 |
| --- | --- | --- |
| `Ray44` | `"Ray44"`，`0` | `0`，`""` |
| `44Ray` | `44Ray"`，`0` | `44`，`"Ray"` |
| `Ray 44` | `"Ray"`，`44` | `0`，`""` |
| `44 Ray` | `"44"`，`0` | `44`，`"Ray"` |
| `Ray44` | `"Ray"`，`44` | `0`，`""` |
| `44Ray` | `"44"`，`0` | `44`，`"Ray"` |
| `44#Ray` | `"44#Ray"`，`0` | `44`，`"#Ray"` |
| `Ray#44` | `"Ray#44"`，`0` | `0`，`""` |

处理输入流中的错误需要一些更高级的 C++，但是处理代码中的错误是您现在可以处理的事情。接下来的探索将帮助您解开编译器错误消息。