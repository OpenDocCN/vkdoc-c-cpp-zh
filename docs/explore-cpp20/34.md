# 三十四、编写类

`rational`类型是*类*的一个例子。既然您已经看到了编写自己的类的具体示例，那么是时候了解管理所有类的一般规则了。这个探索和接下来的四个探索为 C++ 编程的这个重要方面奠定了基础。

## 剖析一个班级

一个类有一个名字和*成员*——数据成员、成员函数，甚至成员类型定义和嵌套类。用关键字`struct`开始一个类定义。(您可能想知道为什么不用关键字`class`开始一个类定义。请耐心等待；一切都将在探索中变得清晰 36 。)用花括号把类定义体括起来，定义以分号结束。在花括号中，您列出了所有成员。以类似于局部变量定义的方式声明数据成员。编写成员函数的方式与编写自由函数的方式相同。清单 34-1 显示了一个只包含数据成员的简单类定义。

```cpp
struct point
{
  double x;
  double y;
};

Listing 34-1.Class Definition for a Cartesian Point

```

清单 34-2 展示了 C++ 如何让你在一个声明中列出多个数据成员。除了琐碎的类，这种风格并不常见。我更喜欢单独列出每个成员，这样我就可以包含一个注释来解释这个成员，它的用途，什么约束适用于它，等等。即使没有评论，一点额外的澄清也大有帮助。

```cpp
struct point
{
  double x, y;
};

Listing 34-2.Multiple Data Members in One Declaration

```

与 C++ 源文件中的任何其他名称一样，在使用类名之前，编译器必须看到它的声明或定义。您可以在自己的定义中使用类名。

使用类名作为类型名，定义局部变量、函数参数、函数返回类型，甚至其他数据成员。编译器从类定义的最开始就知道类名，所以你可以在类定义中使用它的名字作为类型名。

当您使用类类型定义变量时，编译器会留出足够的内存，以便变量可以存储该类的每个数据成员的副本。例如，定义一个类型为`point`的对象，该对象包含`x`和`y`成员。定义另一个类型为`point`的对象，该对象包含自己独立的`x`和`y`成员。

使用点(`.`)运算符来访问成员，就像您在本书中一直做的那样。对象是左边的操作数，成员名是右边的操作数，如清单 34-3 所示。

```cpp
import <iostream>;

struct point
{
  double x;
  double y;
};

int main()
{
  point origin{}, unity{};
  origin.x = 0;
  origin.y = 0;
  unity.x = 1;
  unity.y = 1;
  std::cout << "origin = (" << origin.x << ", " << origin.y << ")\n";
  std::cout << "unity  = (" << unity.x  << ", " << unity.y  << ")\n";
}

Listing 34-3.Using a Class and Its Members

```

## 成员函数

除了数据成员，您还可以拥有成员函数。成员函数定义看起来非常类似于普通的函数定义，只是您将它们定义为类定义的一部分。此外，成员函数可以调用同一类的其他成员函数，并且可以访问同一类的数据成员。清单 34-4 展示了添加到类`point`中的一些成员函数。

```cpp
#include <cmath> // for sqrt and atan2

struct point
{
  /// Distance to the origin.
  double distance()
  {
    return std::sqrt(x*x + y*y);
  }
  /// Angle relative to x-axis.
  double angle()
  {
    return std::atan2(y, x);
  }

  /// Add an offset to x and y.
  void offset(double off)
  {
    offset(off, off);
  }
  /// Add an offset to x and an offset to y
  void offset(double  xoff, double yoff)
  {
    x = x + xoff;
    y = y + yoff;
  }

  /// Scale x and y.
  void scale(double mult)
  {
    this->scale(mult, mult);
  }
  /// Scale x and y.
  void scale(double xmult, double ymult)
  {
    this->x = this->x * xmult;
    this->y = this->y * ymult;
  }
  double x;
  double y;
};

Listing 34-4.Member Functions for Class point

```

对于每个成员函数，编译器都会生成一个名为`this`的隐藏参数。当调用成员函数时，编译器将对象作为隐藏参数传递。在成员函数中，可以用表达式`*this`访问对象。C++ 语法规则规定成员操作符(`.`)的优先级高于`*`操作符，因此需要在`*this`(例如`(*this).x`)两边加上括号。为了语法上的方便，编写相同表达式的另一种方式是`this-` > `x`，您可以在清单 34-4 中看到几个例子。

编译器足够聪明，知道何时使用成员名，所以使用`this->`是可选的。如果一个名字没有局部定义，并且是一个成员的名字，编译器会认为你想使用这个成员。为了清晰起见，一些程序员喜欢总是包含`this->`——在一个大程序中，您很容易忘记哪些名称是成员名称。其他程序员发现额外的`this->`很杂乱，只在必要时才使用。我的推荐是后者。您需要学习阅读 C++ 类，其中一项必要的技能是能够阅读类定义，找到成员名称，并在阅读类定义时跟踪这些名称。

许多程序员使用一种更微妙的技术，包括使用特殊的前缀或后缀来表示数据成员名称。例如，一种常见的技术是对所有数据成员使用前缀`m_`(“m”是*成员*的缩写)。另一种常见的技术没有那么麻烦:使用普通的下划线(`_`)后缀。比起前缀，我更喜欢后缀，因为后缀比前缀干扰少，所以它们不会模糊名字的重要部分。从现在开始，我将采用在每个数据成员名称后添加下划线的做法。

NO LEADING UNDERSCORE

如果您只想使用下划线来表示成员，请将其用作后缀，而不是前缀。C++ 标准将某些名称搁置一边，并禁止您使用它们。实际的规则有些冗长，因为 C++ 从 C 标准库中继承了许多限制。例如，您不应该使用任何以`E`开头、后跟数字或大写字母的名称。(这条规则看起来很神秘，但是 C 标准库为数学函数中的范围错误定义了几个错误代码名，比如`ERANGE`。该规则允许库在将来添加新名称，并允许那些实现库的人添加特定于供应商的名称。)

我喜欢简单，所以我遵循三个基本原则。这些规则比正式的 C++ 规则稍微严格一些，但并不繁琐:

*   不要使用包含两个连续下划线(`like__this`)的任何名称。

*   不要使用任何以下划线(`_like_this`)开头的名称。

*   不要使用全大写的名称(`LIKE_THIS`)。

使用保留名称会导致未定义的行为。编译器可能不会抱怨，但结果是不可预测的。通常，标准的库实现必须为其内部使用发明许多额外的名称。通过定义应用程序程序员不能使用的某些名称，C++ 确保了库作者可以在库中使用这些名称。如果您不小心使用了与内部库名冲突的名称，结果可能是混乱或者仅仅是函数实现中的细微变化。

## 构造器

正如你在 Exploration 30 中学到的，构造器是一个特殊的成员函数，它初始化一个对象的数据成员。您已经看到了如何编写构造器的几种变体，现在是时候再学习一些了。

当你声明一个数据成员时，你也可以提供一个初始化器。初始化器是一个缺省值，编译器在构造器没有初始化成员时使用。使用正常的初始化语法，在花括号中提供一个或多个值。

```cpp
struct point {
  int x = 1;
  int y;
  point() {} // initializes x to 1 and y to 0
};

```

仅当特定成员需要所有或几乎所有构造器中的单个值时，才使用这种方式初始化数据成员。通过将初始值从构造器中分离出来，使得构造器更难阅读和理解。人类读者必须阅读构造器和数据成员声明，才能知道对象是如何初始化的。另一方面，使用默认初始化器是确保内置类型的数据成员(如`int`)总是被初始化的一个好方法。

回想一下，构造器可以重载，编译器根据初始化器中的参数选择调用哪个构造器。我喜欢用花括号初始化一个对象。花括号中的值以与普通函数的函数参数相同的方式传递给构造器。事实上，C++ 03 使用圆括号来初始化对象，所以初始化式看起来非常像函数调用。C++ 的更高版本仍然允许这种风格的初始化式，但是在几乎所有其他情况下，花括号更好。探索 31 演示了花括号提供了更好的类型安全性。

花括号的另一个关键区别是，你可以用花括号中的一系列值初始化一个容器，比如一个`vector`，如下所示:

```cpp
std::vector<int> data{ 1, 2, 3 };

```

这就引入了一个问题。vector 类型有几个构造器。例如，双参数构造器允许您用单个值的多个副本初始化一个向量。例如，一个有十个零的向量可以初始化如下:

```cpp
std::vector<int> ten_zeroes(10, 0);

```

请注意，我使用了括号。如果我用花括号呢？试试看。会发生什么？

*   ______________________________________________________________

*   _____________________________________________________________

向量用两个整数初始化:10 和 0。规则是容器将花括号视为一系列用来初始化容器内容的值。大括号还可以用在其他一些情况下，比如复制一个容器，但是如果构造器的参数看起来像容器值，那么编译器可能会这样解释它们，或者发出一个关于不明确的错误消息。

用与普通成员函数几乎相同的方式编写构造器，但有一些不同:

*   省略返回类型。

*   使用普通的`return;`(不返回值的返回语句)。

*   使用类名作为函数名。

*   在冒号后添加一个初始化列表来初始化数据成员。初始化器也可以调用另一个构造器，将参数传递给那个构造器。将构造委托给一个公共构造器是确保所有构造器都正确执行规则的一个好方法。

清单 34-5 展示了几个添加到类`point`的构造器的例子。

```cpp
struct point
{
  point()
  : point{0.0, 0.0}
  {}
  point(double x, double y)
  : x_{x}, y_{y}
  {}
  point(point const& pt)
  : point{pt.x_, pt.y_}
  {}
  double x_;
  double y_;
};

Listing 34-5.Constructors for Class point

```

初始化是类类型和内置类型的主要区别之一。如果你定义一个没有初始化器的内置类型的对象，你会得到一个垃圾值，但是类类型的对象总是通过调用一个构造器来初始化。您总是有机会初始化对象的数据成员。内置类型和类类型之间的区别在 C++ 用来初始化构造器中的数据成员的规则中也很明显。

构造器的初始化列表是可选的，但是我建议你总是提供它，除非每个数据成员都有一个初始化列表。初始值设定项列表出现在冒号之后，冒号跟在构造器参数列表的右括号之后；它按照在类定义中声明的顺序初始化每个数据成员，忽略初始化列表中的顺序。为了避免混淆，总是按照与数据成员相同的顺序编写初始化列表。成员初始值设定项用逗号分隔，可以根据需要任意多行。每个成员初始化器提供单个数据成员的初始值，或者使用类名调用另一个构造器。列出成员名，后面用花括号括起它的初始化式。初始化数据成员与初始化变量相同，遵循相同的规则。

如果你没有为你的类写任何构造器，编译器会写它自己的默认构造器。编译器的默认构造器就像一个省略了初始化列表的构造器。

```cpp
struct point {
  point() {} // x_ is initialized to 0, and y_ is uninitialized
  double x_{};
  double y_;
};

```

编译器给你写构造器的时候，构造器是*隐式*。如果编写任何构造器，编译器会取消隐式默认构造器。如果你想要一个默认的构造器，你必须自己写。

在某些应用程序中，您可能希望避免初始化`point`的数据成员的开销，因为您的应用程序会立即为`point`对象分配一个新值。然而，大多数时候，谨慎是最好的。

一个*复制构造器*接受一个与类相同类型的参数，通过引用传递。当您通过值将对象传递给函数时，或者当函数返回对象时，编译器会自动生成对复制构造器的调用。还可以用另一个`point`对象的值初始化一个`point`对象，编译器生成代码来调用复制构造器。

```cpp
point pt1;          // default constructor
point p2{pt1};      // copy constructor

```

如果你不写自己的复制构造器，编译器会为你写一个。自动复制构造器调用每个数据成员的复制构造器，就像清单 34-5 中的一样。因为我写了一个和编译器隐式写的一模一样的，所以没有理由显式写。让编译器完成它的工作。

为了帮助你可视化编译器如何调用构造器，请阅读清单 34-6 。注意它是如何为每次构造器的使用打印一条消息的。

```cpp
import <iostream>;

struct demo
{
  demo()      : demo{0} { std::cout << "default constructor\n"; }
  demo(int x) : x_{x} { std::cout << "constructor(" << x << ")\n"; }
  demo(demo const& that)
  : x_{that.x_}
  {
    std::cout << "copy constructor(" << x_ << ")\n";
  }
  int x_;
};

demo addone(demo d)
{
  ++d.x_;
  return d;
}

int main()
{
  demo d1{};
  demo d2{d1};
  demo d3{42};
  demo d4{addone(d3)};
}

Listing 34-6.Visual Constructors

```

**预测运行清单** **34-6** **中程序的输出。**

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

*   _____________________________________________________________

检查你的预测。你是对的吗？_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

当向函数传递参数和接受返回值时，编译器会执行一些小的优化。例如，C++ 标准不是将一个`demo`对象复制到`addone`返回值，然后复制返回值来初始化`d4`，而是指导编译器移除对复制构造器的不必要调用。当我运行这个程序时，我得到了这个:

```cpp
constructor(0)
default constructor
copy constructor(0)
constructor(42)
copy constructor(42)
copy constructor(43)

```

## 默认和删除的构造器

如果不提供任何构造器，编译器将隐式编写一个默认构造器和一个复制构造器。如果你写了至少一个任意类型的构造器，编译器不会隐式地写一个默认的构造器，但是如果你自己没有写，它仍然会给你一个复制构造器。

您可以控制编译器的隐式行为，而无需编写任何自己的构造器。为构造器写一个不带体的函数头，用`=default`得到编译器的隐式定义。使用`=delete`抑制该功能。例如，如果您不希望任何人创建类的副本，请注意以下几点:

```cpp
struct dont_copy
{
   dont_copy(dont_copy const&) = delete;
};

```

更常见的是让编译器编写它的复制构造器，但是明确地告诉人类读者。随着你对 C++ 了解的越来越多，你会发现编译器为你写构造器的规则，以及何时写构造器的规则，比我目前所介绍的要复杂得多。当你要求编译器隐式地提供一个构造器时，我敦促你养成声明的习惯，即使这看起来很明显。

```cpp
struct point
{
  point() = default;
  point(point const&) = default;
  int x, y;
};

```

那很容易。接下来的探索从一个真正的挑战开始。